<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shoushi`s Notes</title>
  
  
  <link href="http://localhost:4000/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2023-04-16T13:06:51.493Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>liqun.guan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次Drool使用不当导致的OOM异常</title>
    <link href="http://localhost:4000/2023/04/16/java/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/"/>
    <id>http://localhost:4000/2023/04/16/java/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/</id>
    <published>2023-04-16T12:20:50.463Z</published>
    <updated>2023-04-16T13:06:51.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次Drool使用不当导致的OOM异常"><a href="#记一次Drool使用不当导致的OOM异常" class="headerlink" title="记一次Drool使用不当导致的OOM异常"></a>记一次Drool使用不当导致的OOM异常</h1><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>​李宁项目属于两个服务进行集群部署，在25号时候，66，67两个ip都出现tomcat假死现象，组件日志均有打印，接口无法访问，定时任务不跑。</p><span id="more"></span><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><h5 id="分析一："><a href="#分析一：" class="headerlink" title="分析一："></a>分析一：</h5><p>​当时认为假死是程序中有死锁或者死循环之类的问题导致，但是无依据，遂让实施拉取25号的66ip的dump文件，（67的为了线上继续运行，先重启解决）。</p><p>​拉取到dump文件后，先使用jdk自带的<strong>jvisualvm</strong>进行分析，看到发生了oom，报错信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;ARTEMIS_TASK_CLUSTER_SCHEDULER_Worker-15&quot;</span> prio=<span class="number">5</span> tid=<span class="number">100</span> RUNNABLE</span><br><span class="line">    at java.lang.OutOfMemoryError.&lt;init&gt;(OutOfMemoryError.java:<span class="number">48</span>)</span><br><span class="line">    at java.util.Arrays.copyOf(Arrays.java:<span class="number">3332</span>)</span><br><span class="line">       Local Variable: <span class="type">char</span>[]#<span class="number">1570195</span></span><br><span class="line">    at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="number">124</span>)</span><br><span class="line">    at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="number">448</span>)</span><br><span class="line">       Local Variable: java.lang.String#<span class="number">1563273</span></span><br><span class="line">    at java.lang.StringBuffer.append(StringBuffer.java:<span class="number">270</span>)</span><br><span class="line">    at java.text.MessageFormat.subformat(MessageFormat.java:<span class="number">1335</span>)</span><br><span class="line">        Variable: java.lang.StringBuffer#<span class="number">4</span></span><br><span class="line">       Local Variable: java.text.MessageFormat#<span class="number">3</span></span><br><span class="line">    at java.text.MessageFormat.format(MessageFormat.java:<span class="number">865</span>)</span><br><span class="line">    at java.text.Format.format(Format.java:<span class="number">157</span>)</span><br><span class="line">    at java.text.MessageFormat.format(MessageFormat.java:<span class="number">841</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.Util.rtp(Util.java:<span class="number">68</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.StdJDBCDelegate.rtp(StdJDBCDelegate.java:<span class="number">3029</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.StdJDBCDelegate.updateTriggerStatesForJobFromOtherState(StdJDBCDelegate.java:<span class="number">1513</span>)</span><br><span class="line">       Local Variable: java.lang.String#<span class="number">616911</span></span><br><span class="line">       Local Variable: org.quartz.JobKey#<span class="number">2</span></span><br><span class="line">       Local Variable: java.lang.String#<span class="number">622049</span></span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport.triggeredJobComplete(JobStoreSupport.java:<span class="number">3103</span>)</span><br><span class="line">       Local Variable: org.quartz.impl.triggers.CronTriggerImpl#<span class="number">3</span></span><br><span class="line">       Local Variable: org.quartz.impl.JobDetailImpl#<span class="number">2</span></span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport$<span class="number">45.</span>executeVoid(JobStoreSupport.java:<span class="number">3055</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport$VoidTransactionCallback.execute(JobStoreSupport.java:<span class="number">3715</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport$VoidTransactionCallback.execute(JobStoreSupport.java:<span class="number">3713</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport.executeInNonManagedTXLock(JobStoreSupport.java:<span class="number">3799</span>)</span><br><span class="line">       Local Variable: com.sun.proxy.$Proxy1251#<span class="number">1</span></span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport.retryExecuteInNonManagedTXLock(JobStoreSupport.java:<span class="number">3754</span>)</span><br><span class="line">       Local Variable: java.lang.String#<span class="number">621730</span></span><br><span class="line">       Local Variable: org.springframework.scheduling.quartz.LocalDataSourceJobStore#<span class="number">1</span></span><br><span class="line">       Local Variable: org.quartz.impl.jdbcjobstore.JobStoreSupport$<span class="number">45</span>#<span class="number">1</span></span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport.triggeredJobComplete(JobStoreSupport.java:<span class="number">3051</span>)</span><br><span class="line">    at org.quartz.core.QuartzScheduler.notifyJobStoreJobComplete(QuartzScheduler.java:<span class="number">1804</span>)</span><br><span class="line">    at org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">269</span>)</span><br><span class="line">       Local Variable: org.quartz.core.JobRunShell#<span class="number">2</span></span><br></pre></td></tr></table></figure><p>经过查看代码分析，此处就是一个简单的quartz集群的查询字符串，不可能过大导致内存溢出，排除。</p><h5 id="分析二："><a href="#分析二：" class="headerlink" title="分析二："></a>分析二：</h5><p>​经过jvisualvm查看，确实存在较大的内存占用，但是不直观，具体不明，查资料得知一个很强大👍的工具<strong>MAT</strong>。</p><p>​MAT依赖于jdk11，此外需要修改MemoryAnalyzer.ini文件，指定jdk路径以及加大内存。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-startup</span><br><span class="line">plugins/org.eclipse.equinox.launcher_1.6.400.v20210924-0641.jar</span><br><span class="line">-vm</span><br><span class="line">C:\Program Files\Java\jdk-11\bin\javaw.exe</span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.2.400.v20211117-0650</span><br><span class="line">-vmargs</span><br><span class="line">-Xmx4g</span><br></pre></td></tr></table></figure><p>​1.将dump文件导入MAT，分析得到饼状图，看到有一个占据这3.1GB的大对象存活</p><img src="media/解决drools使用不当导致的oom/image-20230307132550052.png" alt="image-20230307132550052" style="zoom: 50%;" /><p>​2. 点击查看Dominator Tree，查看大对象<img src="/media/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/image-20230307132715519.png" alt="image-20230307132715519"></p><ol start="3"><li><p>查看定位到大对象是和drools相关的statefulSeesions,属于kieBaseMap内置的一个HashSet.</p><p><img src="/media/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/image-20230307133023685.png" alt="image-20230307133023685"></p></li><li><p>大对象定位到后进行代码分析</p><p>drools有状态会话时，必须调用dispose()方法，以确保没有内存泄漏。代码中相关dispose的调用在执行规则后调用，当kieSession.fireAllRules();出错时，即规则代码出错时，会抛异常跳出当前方法而导致跳过dispose（）方法的调用，发生内存泄露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">helperList</span><span class="params">(String key, List&lt;Object&gt; gList)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">KieSession</span> <span class="variable">kieSession</span> <span class="operator">=</span> getSession(key);</span><br><span class="line">        kieSession.setGlobal(GLOB_LIST, gList);</span><br><span class="line">        kieSessionSetGlobalServiceList(key,kieSession);</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>验证，若出现大量的异常，则会在外层被catch住进行日志输出。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">droolsHelperListByKey</span><span class="params">(String key, Object... objects)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; gList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        gList.addAll(Arrays.asList(objects));</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isEmpty(key) || CollectionUtil.isEmpty(kieBaseMap) || CollectionUtil.isEmpty(ruleMap)) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;droolsHelperListByKey drools getRule is empty key:[&#123;&#125;]&quot;</span>, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                helperList(key, gList);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;droolsHelperListByKey error :&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>日志搜索：</p><p><img src="/media/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/image-20230307133559960.png" alt="image-20230307133559960"></p><p>至此，分析结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于资源类的数据，务必要保证资源的释放操作。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;记一次Drool使用不当导致的OOM异常&quot;&gt;&lt;a href=&quot;#记一次Drool使用不当导致的OOM异常&quot; class=&quot;headerlink&quot; title=&quot;记一次Drool使用不当导致的OOM异常&quot;&gt;&lt;/a&gt;记一次Drool使用不当导致的OOM异常&lt;/h1&gt;&lt;h3 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h3&gt;&lt;p&gt;​		李宁项目属于两个服务进行集群部署，在25号时候，66，67两个ip都出现tomcat假死现象，组件日志均有打印，接口无法访问，定时任务不跑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="项目实践" scheme="http://localhost:4000/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Volatile 详解</title>
    <link href="http://localhost:4000/2023/04/16/java/volitile%E8%AF%A6%E8%A7%A3/"/>
    <id>http://localhost:4000/2023/04/16/java/volitile%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-04-16T12:19:06.458Z</published>
    <updated>2023-04-16T13:06:58.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中Volatile关键字详解"><a href="#Java中Volatile关键字详解" class="headerlink" title="Java中Volatile关键字详解"></a>Java中Volatile关键字详解</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><hr><h3 id="先补充一下概念：Java-内存模型中的可见性、原子性和有序性。"><a href="#先补充一下概念：Java-内存模型中的可见性、原子性和有序性。" class="headerlink" title="先补充一下概念：Java 内存模型中的可见性、原子性和有序性。"></a><strong>先补充一下概念：Java 内存模型中的可见性、原子性和有序性。</strong></h3><p><strong>可见性：</strong></p><p>　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p><p>　　<strong>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</strong>也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a &#x3D; 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p><p>　　在 Java 中 volatile、synchronized 和 final 实现可见性。</p><span id="more"></span><p><strong>原子性：</strong></p><p>　　<strong>原子是世界上的最小单位，具有不可分割性。</strong>比如 a&#x3D;0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a &#x3D; a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p><p>　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p><p><strong>有序性：</strong></p><p>　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p><p><strong>下面内容摘录自《Java Concurrency in Practice》：</strong></p><p>　　下面一段代码在多线程环境下，将存在问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 1 /**</span><br><span class="line"> 2  * @author zhengbinMac</span><br><span class="line"> 3  */</span><br><span class="line"> 4 public class NoVisibility &#123;</span><br><span class="line"> 5     private static boolean ready;</span><br><span class="line"> 6     private static int number;</span><br><span class="line"> 7     private static class ReaderThread extends Thread &#123;</span><br><span class="line"> 8         @Override</span><br><span class="line"> 9         public void run() &#123;</span><br><span class="line">10             while(!ready) &#123;</span><br><span class="line">11                 Thread.yield();</span><br><span class="line">12             &#125;</span><br><span class="line">13             System.out.println(number);</span><br><span class="line">14         &#125;</span><br><span class="line">15     &#125;</span><br><span class="line">16     public static void main(String[] args) &#123;</span><br><span class="line">17         new ReaderThread().start();</span><br><span class="line">18         number = 42;</span><br><span class="line">19         ready = true;</span><br><span class="line">20     &#125;</span><br><span class="line">21 &#125;</span><br></pre></td></tr></table></figure><p>　　NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p><p>　　在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行春旭进行判断，无法得到正确的结论。</p><p>　　这个看上去像是一个失败的设计，但却能使JVM充分地利用现代多核处理器的强大性能。例如，在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并将数值缓存在处理器特定的缓存中。</p><h2 id="二、Volatile原理"><a href="#二、Volatile原理" class="headerlink" title="二、Volatile原理"></a>二、Volatile原理</h2><hr><p>　　Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p><p><img src="/media/volitile%E8%AF%A6%E8%A7%A3/731716-20160708224602686-2141387366.png" alt="img"></p><p>　　当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p><p>　　而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p><h3 id="当一个变量定义为-volatile-之后，将具备两种特性："><a href="#当一个变量定义为-volatile-之后，将具备两种特性：" class="headerlink" title="当一个变量定义为 volatile 之后，将具备两种特性："></a>当一个变量定义为 volatile 之后，将具备两种特性：</h3><p>　　1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：<a href="http://www.cnblogs.com/zhengbin/p/6407137.html">Java内存模型</a>）来完成。</p><p>　　2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个<strong>内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</p><h3 id="volatile-性能："><a href="#volatile-性能：" class="headerlink" title="volatile 性能："></a>volatile 性能：</h3><p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java中Volatile关键字详解&quot;&gt;&lt;a href=&quot;#Java中Volatile关键字详解&quot; class=&quot;headerlink&quot; title=&quot;Java中Volatile关键字详解&quot;&gt;&lt;/a&gt;Java中Volatile关键字详解&lt;/h1&gt;&lt;h2 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、基本概念&lt;/strong&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;先补充一下概念：Java-内存模型中的可见性、原子性和有序性。&quot;&gt;&lt;a href=&quot;#先补充一下概念：Java-内存模型中的可见性、原子性和有序性。&quot; class=&quot;headerlink&quot; title=&quot;先补充一下概念：Java 内存模型中的可见性、原子性和有序性。&quot;&gt;&lt;/a&gt;&lt;strong&gt;先补充一下概念：Java 内存模型中的可见性、原子性和有序性。&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;可见性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。&lt;/strong&gt;也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a &amp;#x3D; 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。&lt;/p&gt;
&lt;p&gt;　　在 Java 中 volatile、synchronized 和 final 实现可见性。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并发" scheme="http://localhost:4000/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>G1详解</title>
    <link href="http://localhost:4000/2023/04/12/java/G1/"/>
    <id>http://localhost:4000/2023/04/12/java/G1/</id>
    <published>2023-04-12T13:31:29.997Z</published>
    <updated>2023-04-16T13:06:44.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>Garbage First(G1)是垃圾收集领域的最新成果，同时也是HotSpot在JVM上力推的垃圾收集器，并赋予取代CMS的使命。如果使用Java 8&#x2F;9，那么有很大可能希望对G1收集器进行评估。本文详细首先对JVM其他的垃圾收集器进行总结，并与G1进行了简单的对比；然后通过G1的内存模型、G1的活动周期，对G1的工作机制进行了介绍；同时还在介绍过程中，描述了可能需要引起注意的优化点。笔者希望通过本文，让有一定JVM基础的读者能尽快掌握G1的知识点。<strong>另，本文较长，建议收藏阅读。</strong></p><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a><strong>第一章 概述</strong></h2><p>G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。</p><span id="more"></span><h2 id="第二章-JVM-GC收集器的回顾与比较"><a href="#第二章-JVM-GC收集器的回顾与比较" class="headerlink" title="第二章 JVM GC收集器的回顾与比较"></a><strong>第二章 JVM GC收集器的回顾与比较</strong></h2><p><img src="/media/G1/1620.jpeg" alt="img"></p><p>从JDK3(1.3)开始，HotSpot团队一直努力朝着高效收集、减少停顿(STW: Stop The World)的方向努力，也贡献了从串行到CMS乃至最新的G1在内的一系列优秀的垃圾收集器。上图展示了JDK的垃圾回收大家庭，以及相互之间的组合关系，下面就几种典型的组合应用进行简单的介绍。</p><h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a><strong>串行收集器</strong></h3><p><img src="/media/G1/1620-16620838632904.jpeg" alt="img"></p><p>串行收集器组合 Serial + Serial Old</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启选项：-<span class="attr">XX</span>:+<span class="title class_">SerialGC</span></span><br></pre></td></tr></table></figure><p>复制</p><p>串行收集器是最基本、发展时间最长、久经考验的垃圾收集器，也是client模式下的默认收集器配置。  串行收集器采用单线程stop-the-world的方式进行收集。当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点(Safepoint)时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存。单线程也意味着复杂度更低、占用内存更少，但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核CPU的场合。</p><h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a><strong>并行收集器</strong></h3><p><img src="/media/G1/1620-16620838632905.jpeg" alt="img"></p><p>并行收集器组合 Parallel Scavenge + Parallel Old</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启选项：-<span class="attr">XX</span>:+<span class="title class_">UseParallelGC</span>或-<span class="attr">XX</span>:+<span class="title class_">UseParallelOldGC</span>(可互相激活)</span><br></pre></td></tr></table></figure><p>复制</p><p>并行收集器是以关注吞吐量为目标的垃圾收集器，也是server模式下的默认收集器配置，对吞吐量的关注主要体现在年轻代Parallel Scavenge收集器上。</p><p>并行收集器与串行收集器工作模式相似，都是stop-the-world方式，只是暂停时并行地进行垃圾收集。年轻代采用复制算法，老年代采用标记-整理，在回收的同时还会对内存进行压缩。关注吞吐量主要指年轻代的Parallel Scavenge收集器，通过两个目标参数-XX:MaxGCPauseMills和-XX:GCTimeRatio，调整新生代空间大小，来降低GC触发的频率。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</p><h3 id="并发标记清除收集器"><a href="#并发标记清除收集器" class="headerlink" title="并发标记清除收集器"></a><strong>并发标记清除收集器</strong></h3><p><img src="/media/G1/1620-16620838632906.jpeg" alt="img"></p><p>并发标记清除收集器组合 ParNew + CMS + Serial Old</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启选项：-<span class="attr">XX</span>:+<span class="title class_">UseConcMarkSweepGC</span></span><br></pre></td></tr></table></figure><p>复制</p><p>并发标记清除(CMS)是以关注延迟为目标、十分优秀的垃圾回收算法，开启后，年轻代使用STW式的并行收集，老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现在老年代CMS上。</p><p>年轻代ParNew与并行收集器类似，而老年代CMS每个收集周期都要经历：初始标记、并发标记、重新标记、并发清除。其中，初始标记以STW的方式标记所有的根对象；并发标记则同应用线程一起并行，标记出根对象的可达路径；在进行垃圾回收前，CMS再以一个STW进行重新标记，标记那些由mutator线程(指引起数据变化的线程，即应用线程)修改而可能错过的可达对象；最后得到的不可达对象将在并发清除阶段进行回收。值得注意的是，初始标记和重新标记都已优化为多线程执行。CMS非常适合堆内存大、CPU核数多的<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>端应用，也是G1出现之前大型应用的首选收集器。</p><p>但是CMS并不完美，它有以下缺点：</p><ol><li>由于并发进行，CMS在收集与应用线程会同时会增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间；</li><li>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，进行一次压缩的Full GC。</li></ol><h3 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a><strong>Garbage First</strong></h3><p><img src="/media/G1/1620-16620838632917.jpeg" alt="img"></p><p>Garbage First (G1)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启选项：-<span class="attr">XX</span>:+<span class="title class_">UseG1GC</span></span><br></pre></td></tr></table></figure><p>复制</p><p>之前介绍的几组垃圾收集器组合，都有几个共同点：</p><ul><li>年轻代、老年代是独立且连续的内存块；</li><li>年轻代收集使用单eden、双survivor进行复制算法；</li><li>老年代收集必须扫描整个老年代区域；</li><li>都是以尽可能少而块地执行GC为设计原则。</li></ul><p>G1垃圾收集器也是以关注延迟为目标、服务器端应用的垃圾收集器，被HotSpot团队寄予取代CMS的使命，也是一个非常具有调优潜力的垃圾收集器。虽然G1也有类似CMS的收集动作：初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。事实上，G1收集与以上三组收集器有很大不同：</p><ol><li>G1的设计原则是”首先收集尽可能多的垃圾(Garbage First)”。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；</li><li>G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；</li><li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；</li><li>G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</li></ol><h2 id="第三章-G1的内存模型"><a href="#第三章-G1的内存模型" class="headerlink" title="第三章 G1的内存模型"></a><strong>第三章 G1的内存模型</strong></h2><h3 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a><strong>分区概念</strong></h3><p><img src="/media/G1/1620-16620838632918.jpeg" alt="img"></p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a><strong>分区</strong></h4><p>分区 Region</p><p>G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize&#x3D;n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p><h4 id="卡片"><a href="#卡片" class="headerlink" title="卡片"></a><strong>卡片</strong></h4><p>卡片 Card</p><p>在每个分区内部又被分成了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h4><p>堆 Heap</p><p>G1同样可以通过-Xms&#x2F;-Xmx来指定堆空间大小。当发生年轻代收集或混合收集时，通过计算GC与应用的耗费时间比，自动调整堆空间大小。如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低；目标参数-XX:GCTimeRatio即为GC与应用的耗费时间比，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。另外，当空间不足，如对象空间分配或转移失败时，G1会首先尝试增加堆空间，如果扩容失败，则发起担保的Full GC。Full GC后，堆尺寸计算结果也会调整堆空间。</p><h3 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a><strong>分代模型</strong></h3><h4 id="分代"><a href="#分代" class="headerlink" title="分代"></a><strong>分代</strong></h4><p><img src="/media/G1/1620-16620838632919.jpeg" alt="img"></p><p>分代 Generation</p><p>分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但G1依然使用了分代的思想。与其他垃圾收集器类似，G1将内存在逻辑上划分为年轻代和老年代，其中年轻代又划分为Eden空间和Survivor空间。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间。</p><p>整个年轻代内存会在初始空间-XX:G1NewSizePercent(默认整堆5%)与最大空间-XX:G1MaxNewSizePercent(默认60%)之间动态变化，且由参数目标暂停时间-XX:MaxGCPauseMillis(默认200ms)、需要扩缩容的大小以及分区的已记忆集合(RSet)计算得到。当然，G1依然可以设置固定的年轻代大小(参数-XX:NewRatio、-Xmn)，但同时暂停目标将失去意义。</p><h4 id="本地分配缓冲"><a href="#本地分配缓冲" class="headerlink" title="本地分配缓冲"></a><strong>本地分配缓冲</strong></h4><p>本地分配缓冲 Local allocation buffer (Lab)</p><p>值得注意的是，由于分区的思想，每个线程均可以”认领”某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和GC线程都会独立的使用分区，进而减少同步时间，提升GC效率，这个分区称为本地分配缓冲区(Lab)。</p><p>其中，应用线程可以独占一个本地缓冲区(TLAB)来创建的对象，而大部分都会落入Eden区域(巨型对象或分配失败除外)，因此TLAB的分区属于Eden空间；而每次垃圾收集时，每个GC线程同样可以独占一个本地缓冲区(GCLAB)用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；对于从Eden&#x2F;Survivor空间晋升(Promotion)到Survivor&#x2F;老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(PLAB)。</p><h4 id="分区模型"><a href="#分区模型" class="headerlink" title="分区模型"></a><strong>分区模型</strong></h4><p>G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。</p><p><img src="/media/G1/1620-166208386329110.jpeg" alt="img"></p><h4 id="巨型对象"><a href="#巨型对象" class="headerlink" title="巨型对象"></a><strong>巨型对象</strong></h4><p>巨型对象 Humongous Region</p><p>一个大小达到甚至超过分区大小一半的对象称为巨型对象(Humongous Object)。当线程为巨型分配空间时，不能简单在TLAB进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(Humongous Region)。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。</p><p>巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为开始巨型(StartsHumongous)，相邻连续分区被标记为连续巨型(ContinuesHumongous)。由于无法享受Lab带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象。</p><h4 id="已记忆集合"><a href="#已记忆集合" class="headerlink" title="已记忆集合"></a><strong>已记忆集合</strong></h4><p>已记忆集合 Remember Set (RSet)</p><p>在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p><p>事实上，并非所有的引用都需要记录在RSet中，如果一个分区确定需要扫描，那么无需RSet也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入RSet中；同时，G1 GC每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在RSet中记录。最后只有老年代的分区可能会有RSet记录，这些分区称为拥有RSet分区(an RSet’s owning region)。</p><h4 id="Per-Region-Table"><a href="#Per-Region-Table" class="headerlink" title="Per Region Table"></a><strong>Per Region Table</strong></h4><p>Per Region Table (PRT)</p><p>RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常”受欢迎”，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：</p><p>稀少：直接记录引用对象的卡片索引 细粒度：记录引用对象的分区索引 粗粒度：只记录引用情况，每个分区对应一个比特位 由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p><p>收集集合 (CSet)</p><p><img src="/media/G1/1620-166208386329111.jpeg" alt="img"></p><p>收集集合 CSet</p><p>收集集合(CSet)代表每次GC暂停时回收的一系列目标分区。在任意一次收集暂停中，CSet所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。</p><p>候选老年代分区的CSet准入条件，可以通过活跃度阈值-XX:G1MixedGCLiveThresholdPercent(默认85%)进行设置，从而拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代分区，可根据CSet对堆的总大小占比-XX:G1OldCSetRegionThresholdPercent(默认10%)设置数量上限。</p><p>由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。</p><h3 id="年轻代收集集合"><a href="#年轻代收集集合" class="headerlink" title="年轻代收集集合"></a><strong>年轻代收集集合</strong></h3><p>年轻代收集集合 CSet of Young Collection</p><p>应用线程不断活动后，年轻代空间会被逐渐填满。<strong>当JVM分配对象到Eden区域失败(Eden区已满)时</strong>，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。</p><p>同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、Survivor尺寸、Survivor填充容量-XX:TargetSurvivorRatio(默认50%)、最大任期阈值-XX:MaxTenuringThreshold(默认15)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p><h4 id="混合收集集合"><a href="#混合收集集合" class="headerlink" title="混合收集集合"></a><strong>混合收集集合</strong></h4><p>混合收集集合 CSet of Mixed Collection</p><p>年轻代收集不断活动后，老年代的空间也会被逐渐填充。<strong>当老年代占用空间超过整堆比IHOP阈值-XX:InitiatingHeapOccupancyPercent(默认45%)时</strong>，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似。</p><p>为了确定包含到年轻代收集集合CSet的老年代分区，JVM通过参数混合周期的最大总次数-XX:G1MixedGCCountTarget(默认8)、堆废物百分比-XX:G1HeapWastePercent(默认5%)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。</p><h2 id="第四章-G1的活动周期"><a href="#第四章-G1的活动周期" class="headerlink" title="第四章 G1的活动周期"></a><strong>第四章 G1的活动周期</strong></h2><h3 id="G1垃圾收集活动汇总"><a href="#G1垃圾收集活动汇总" class="headerlink" title="G1垃圾收集活动汇总"></a><strong>G1垃圾收集活动汇总</strong></h3><p><img src="/media/G1/1620-166208386329112.jpeg" alt="img"></p><h3 id="RSet的维护"><a href="#RSet的维护" class="headerlink" title="RSet的维护"></a><strong>RSet的维护</strong></h3><p>由于不能整堆扫描，又需要计算分区确切的活跃度，因此，G1需要一个增量式的完全标记并发算法，通过维护RSet，得到准确的分区引用信息。在G1中，RSet的维护主要来源两个方面：写栅栏(Write Barrier)和并发优化线程(Concurrence Refinement Threads)</p><h4 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a><strong>栅栏</strong></h4><p><img src="/media/G1/1620-166208386329113.jpeg" alt="img"></p><h4 id="栅栏-Barrier"><a href="#栅栏-Barrier" class="headerlink" title="栅栏 Barrier"></a><strong>栅栏 Barrier</strong></h4><p>我们首先介绍一下栅栏(Barrier)的概念。栅栏是指在原生代码片段中，当某些语句被执行时，栅栏代码也会被执行。而G1主要在赋值语句中，使用写前栅栏(Pre-Write Barrrier)和写后栅栏(Post-Write Barrrier)。事实上，写栅栏的指令序列开销非常昂贵，应用吞吐量也会根据栅栏复杂度而降低。</p><h4 id="写前栅栏-Pre-Write-Barrrier"><a href="#写前栅栏-Pre-Write-Barrrier" class="headerlink" title="写前栅栏 Pre-Write Barrrier"></a><strong>写前栅栏 Pre-Write Barrrier</strong></h4><p>即将执行一段赋值语句时，等式左侧对象将修改引用到另一个对象，那么等式左侧对象原先引用的对象所在分区将因此丧失一个引用，那么JVM就需要在赋值语句生效之前，记录丧失引用的对象。JVM并不会立即维护RSet，而是通过批量处理，在将来RSet更新(见SATB)。</p><h4 id="写后栅栏-Post-Write-Barrrier"><a href="#写后栅栏-Post-Write-Barrrier" class="headerlink" title="写后栅栏 Post-Write Barrrier"></a><strong>写后栅栏 Post-Write Barrrier</strong></h4><p>当执行一段赋值语句后，等式右侧对象获取了左侧对象的引用，那么等式右侧对象所在分区的RSet也应该得到更新。同样为了降低开销，写后栅栏发生后，RSet也不会立即更新，同样只是记录此次更新日志，在将来批量处理(见Concurrence Refinement Threads)。</p><h3 id="起始快照算法"><a href="#起始快照算法" class="headerlink" title="起始快照算法"></a><strong>起始快照算法</strong></h3><p>起始快照算法 Snapshot at the beginning (SATB)</p><p>Taiichi Tuasa贡献的增量式完全并发标记算法起始快照算法(SATB)，主要针对标记-清除垃圾收集器的并发标记阶段，非常适合G1的分区块的堆结构，同时解决了CMS的主要烦恼：重新标记暂停时间长带来的潜在风险。</p><p>SATB会创建一个对象图，相当于堆的逻辑快照，从而确保并发标记阶段所有的垃圾对象都能通过快照被鉴别出来。当赋值语句发生时，应用将会改变了它的对象图，那么JVM需要记录被覆盖的对象。因此写前栅栏会在引用变更前，将值记录在SATB日志或缓冲区中。每个线程都会独占一个SATB缓冲区，初始有256条记录空间。当空间用尽时，线程会分配新的SATB缓冲区继续使用，而原有的缓冲去则加入全局列表中。最终在并发标记阶段，并发标记线程(Concurrent Marking Threads)在标记的同时，还会定期检查和处理全局缓冲区列表的记录，然后根据标记位图分片的标记位，扫描引用字段来更新RSet。此过程又称为并发标记&#x2F;SATB写前栅栏。</p><h3 id="并发优化线程"><a href="#并发优化线程" class="headerlink" title="并发优化线程"></a><strong>并发优化线程</strong></h3><p>并发优化线程 Concurrence Refinement Threads</p><p>G1中使用基于Urs Hölzle的快速写栅栏，将栅栏开销缩减到2个额外的指令。栅栏将会更新一个card table type的结构来跟踪代间引用。</p><p>当赋值语句发生后，写后栅栏会先通过G1的过滤技术判断是否是跨分区的引用更新，并将跨分区更新对象的卡片加入缓冲区序列，即更新日志缓冲区或脏卡片队列。与SATB类似，一旦日志缓冲区用尽，则分配一个新的日志缓冲区，并将原来的缓冲区加入全局列表中。</p><p>并发优化线程(Concurrence Refinement Threads)，只专注扫描日志缓冲区记录的卡片来维护更新RSet，线程最大数目可通过-XX:G1ConcRefinementThreads(默认等于-XX:ParellelGCThreads)设置。并发优化线程永远是活跃的，一旦发现全局列表有记录存在，就开始并发处理。如果记录增长很快或者来不及处理，那么通过阈值-X:G1ConcRefinementGreenZone&#x2F;-XX:G1ConcRefinementYellowZone&#x2F;-XX:G1ConcRefinementRedZone，G1会用分层的方式调度，使更多的线程处理全局列表。如果并发优化线程也不能跟上缓冲区数量，则Mutator线程(Java应用线程)会挂起应用并被加进来帮助处理，直到全部处理完。因此，必须避免此类场景出现。</p><h3 id="并发标记周期"><a href="#并发标记周期" class="headerlink" title="并发标记周期"></a><strong>并发标记周期</strong></h3><p>并发标记周期 Concurrent Marking Cycle</p><p>并发标记周期是G1中非常重要的阶段，这个阶段将会为混合收集周期识别垃圾最多的老年代分区。整个周期完成根标记、识别所有(可能)存活对象，并计算每个分区的活跃度，从而确定GC效率等级。</p><p>当达到IHOP阈值-XX:InitiatingHeapOccupancyPercent(老年代占整堆比，默认45%)时，便会触发并发标记周期。整个并发标记周期将由初始标记(Initial Mark)、根分区扫描(Root Region Scanning)、并发标记(Concurrent Marking)、重新标记(Remark)、清除(Cleanup)几个阶段组成。其中，初始标记(随年轻代收集一起活动)、重新标记、清除是STW的，而并发标记如果来不及标记存活对象，则可能在并发标记过程中，G1又触发了几次年轻代收集。</p><h3 id="并发标记线程"><a href="#并发标记线程" class="headerlink" title="并发标记线程"></a><strong>并发标记线程</strong></h3><p>并发标记线程 Concurrent Marking Threads</p><p><img src="/media/G1/1620-166208386329114.jpeg" alt="img"></p><p>要标记存活的对象，每个分区都需要创建位图(Bitmap)信息来存储标记数据，来确定标记周期内被分配的对象。G1采用了两个位图Previous Bitmap、Next Bitmap，来存储标记数据，Previous位图存储上次的标记数据，Next位图在标记周期内不断变化更新，同时Previous位图的标记数据也越来越过时，当标记周期结束后Next位图便替换Previous位图，成为上次标记的位图。同时，每个分区通过顶部开始标记(TAMS)，来记录已标记过的内存范围。同样的，G1使用了两个顶部开始标记Previous TAMS(PTAMS)、Next TAMS(NTAMS)，记录已标记的范围。</p><p>在并发标记阶段，G1会根据参数-XX:ConcGCThreads(默认GC线程数的1&#x2F;4，即-XX:ParallelGCThreads&#x2F;4)，分配并发标记线程(Concurrent Marking Threads)，进行标记活动。每个并发线程一次只扫描一个分区，并通过”手指”指针的方式优化获取分区。并发标记线程是爆发式的，在给定的时间段拼命干活，然后休息一段时间，再拼命干活。</p><p>每个并发标记周期，在初始标记STW的最后，G1会分配一个空的Next位图和一个指向分区顶部(Top)的NTAMS标记。Previous位图记录的上次标记数据，上次的标记位置，即PTAMS，在PTAMS与分区底部(Bottom)的范围内，所有的存活对象都已被标记。那么，在PTAMS与Top之间的对象都将是隐式存活(Implicitly Live)对象。在并发标记阶段，Next位图吸收了Previous位图的标记数据，同时每个分区都会有新的对象分配，则Top与NTAMS分离，前往更高的地址空间。在并发标记的一次标记中，并发标记线程将找出NTAMS与PTAMS之间的所有存活对象，将标记<a href="https://cloud.tencent.com/product/cdcs?from=10680">数据存储</a>在Next位图中。同时，在NTAMS与Top之间的对象即成为已标记对象。如此不断地更新Next位图信息，并在清除阶段与Previous位图交换角色。</p><h4 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a><strong>初始标记</strong></h4><p>初始标记 Initial Mark</p><p>初始标记(Initial Mark)负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要将Mutator线程(Java应用线程)暂停掉，也就是需要一个STW的时间段。事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为借道(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，初始标记是并发执行，直到所有的分区处理完。</p><h4 id="根分区扫描"><a href="#根分区扫描" class="headerlink" title="根分区扫描"></a><strong>根分区扫描</strong></h4><p>根分区扫描 Root Region Scanning</p><p>在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)，同时扫描的Suvivor分区也被称为根分区(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p><h4 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a><strong>并发标记</strong></h4><p>并发标记 Concurrent Marking</p><p>和应用线程并发执行，并发标记线程在并发标记阶段启动，由参数-XX:ConcGCThreads(默认GC线程数的1&#x2F;4，即-XX:ParallelGCThreads&#x2F;4)控制启动数量，每个线程每次只扫描一个分区，从而标记出存活对象图。在这一阶段会处理Previous&#x2F;Next标记位图，扫描标记对象的引用字段。同时，并发标记线程还会定期检查和处理STAB全局缓冲区列表的记录，更新对象引用信息。参数-XX:+ClassUnloadingWithConcurrentMark会开启一个优化，如果一个类不可达(不是对象不可达)，则在重新标记阶段，这个类就会被直接卸载。所有的标记任务必须在堆满前就完成扫描，如果并发标记耗时很长，那么有可能在并发标记过程中，又经历了几次年轻代收集。如果堆满前没有完成标记任务，则会触发担保机制，经历一次长时间的串行Full GC。</p><h4 id="存活数据计算"><a href="#存活数据计算" class="headerlink" title="存活数据计算"></a><strong>存活数据计算</strong></h4><p>存活数据计算 Live Data Accounting</p><p>存活数据计算(Live Data Accounting)是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。</p><h4 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a><strong>重新标记</strong></h4><p>重新标记 Remark</p><p>重新标记(Remark)是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。这个阶段也是并行执行的，通过参数-XX:ParallelGCThread可设置GC暂停时可用的GC线程数。同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</p><h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a><strong>清除</strong></h4><p>清除 Cleanup</p><p>紧挨着重新标记阶段的清除(Clean)阶段也是STW的。Previous&#x2F;Next标记位图、以及PTAMS&#x2F;NTAMS，都会在清除阶段交换角色。清除阶段主要执行以下操作：</p><p>RSet梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数-XX:+PrintAdaptiveSizePolicy可以开启打印启发式算法决策细节； 整理堆分区，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合； 识别所有空闲分区，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期。</p><h3 id="年轻代收集-x2F-混合收集周期"><a href="#年轻代收集-x2F-混合收集周期" class="headerlink" title="年轻代收集&#x2F;混合收集周期"></a><strong>年轻代收集&#x2F;混合收集周期</strong></h3><p>年轻代收集和混合收集周期，是G1回收空间的主要活动。当应用运行开始时，堆内存可用空间还比较大，只会在年轻代满时，触发年轻代收集；随着老年代内存增长，当到达IHOP阈值-XX:InitiatingHeapOccupancyPercent(老年代占整堆比，默认45%)时，G1开始着手准备收集老年代空间。首先经历并发标记周期，识别出高收益的老年代分区，前文已述。但随后G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集。在这次STW中，G1将保准整理混合收集周期。接着再次让应用线程运行，当接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集，这些连续多次的混合收集称为混合收集周期(Mixed Collection Cycle)。</p><h4 id="GC工作线程数"><a href="#GC工作线程数" class="headerlink" title="GC工作线程数"></a><strong>GC工作线程数</strong></h4><p>GC工作线程数 -XX:ParallelGCThreads</p><p>JVM可以通过参数-XX:ParallelGCThreads进行指定GC工作的线程数量。参数-XX:ParallelGCThreads默认值并不是固定的，而是根据当前的CPU资源进行计算。如果用户没有指定，且CPU小于等于8，则默认与CPU核数相等；若CPU大于8，则默认JVM会经过计算得到一个小于CPU核数的线程数；当然也可以人工指定与CPU核数相等。</p><h4 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a><strong>年轻代收集</strong></h4><p>年轻代收集 Young Collection</p><p>每次收集过程中，既有并行执行的活动，也有串行执行的活动，但都可以是多线程的。在并行执行的任务中，如果某个任务过重，会导致其他线程在等待某项任务的处理，需要对这些地方进行优化。</p><h4 id="并行活动"><a href="#并行活动" class="headerlink" title="并行活动"></a><strong>并行活动</strong></h4><p>外部根分区扫描 Ext Root Scanning：此活动对堆外的根(JVM系统目录、VM数据结构、JNI线程句柄、硬件寄存器、全局变量、线程对栈根)进行扫描，发现那些没有加入到暂停收集集合CSet中的对象。如果系统目录(单根)拥有大量加载的类，最终可能其他并行活动结束后，该活动依然没有结束而带来的等待时间。</p><p>更新已记忆集合 Update RS：并发优化线程会对脏卡片的分区进行扫描更新日志缓冲区来更新RSet，但只会处理全局缓冲列表。作为补充，所有被记录但是还没有被优化线程处理的剩余缓冲区，会在该阶段处理，变成已处理缓冲区(Processed Buffers)。为了限制花在更新RSet的时间，可以设置暂停占用百分比-XX:G1RSetUpdatingPauseTimePercent(默认10%，即-XX:MaxGCPauseMills&#x2F;10)。值得注意的是，如果更新日志缓冲区更新的任务不降低，单纯地减少RSet的更新时间，会导致暂停中被处理的缓冲区减少，将日志缓冲区更新工作推到并发优化线程上，从而增加对Java应用线程资源的争夺。</p><p>RSet扫描 Scan RS：在收集当前CSet之前，考虑到分区外的引用，必须扫描CSet分区的RSet。如果RSet发生粗化，则会增加RSet的扫描时间。开启诊断模式-XX:UnlockDiagnosticVMOptions后，通过参数-XX:+G1SummarizeRSetStats可以确定并发优化线程是否能够及时处理更新日志缓冲区，并提供更多的信息，来帮助为RSet粗化总数提供窗口。参数-XX：G1SummarizeRSetStatsPeriod&#x3D;n可设置RSet的统计周期，即经历多少此GC后进行一次统计</p><p>代码根扫描 Code Root Scanning：对代码根集合进行扫描，扫描JVM编译后代码Native Method的引用信息(nmethod扫描)，进行RSet扫描。事实上，只有CSet分区中的RSet有强代码根时，才会做nmethod扫描，查找对CSet的引用。</p><p>转移和回收 Object Copy：通过选定的CSet以及CSet分区完整的引用集，将执行暂停时间的主要部分：CSet分区存活对象的转移、CSet分区空间的回收。通过工作窃取机制来<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>地选定复制对象的线程，并且复制和扫描对象被转移的存活对象将拷贝到每个GC线程分配缓冲区GCLAB。G1会通过计算，预测分区复制所花费的时间，从而调整年轻代的尺寸。</p><p>终止 Termination：完成上述任务后，如果任务队列已空，则工作线程会发起终止要求。如果还有其他线程继续工作，空闲的线程会通过工作窃取机制尝试帮助其他线程处理。而单独执行根分区扫描的线程，如果任务过重，最终会晚于终止。</p><p>GC外部的并行活动 GC Worker Other：该部分并非GC的活动，而是JVM的活动导致占用了GC暂停时间(例如JNI编译)。</p><h4 id="串行活动"><a href="#串行活动" class="headerlink" title="串行活动"></a><strong>串行活动</strong></h4><p>代码根更新 Code Root Fixup：根据转移对象更新代码根。</p><p>代码根清理 Code Root Purge：清理代码根集合表。</p><p>清除全局卡片标记 Clear CT：在任意收集周期会扫描CSet与RSet记录的PRT，扫描时会在全局卡片表中进行标记，防止重复扫描。在收集周期的最后将会清除全局卡片表中的已扫描标志。</p><p>选择下次收集集合 Choose CSet：该部分主要用于并发标记周期后的年轻代收集、以及混合收集中，在这些收集过程中，由于有老年代候选分区的加入，往往需要对下次收集的范围做出界定；但单纯的年轻代收集中，所有收集的分区都会被收集，不存在选择。</p><p>引用处理 Ref Proc：主要针对软引用、弱引用、虚引用、final引用、JNI引用。当Ref Proc占用时间过多时，可选择使用参数-XX:ParallelRefProcEnabled激活多线程引用处理。G1希望应用能小心使用软引用，因为软引用会一直占据内存空间直到空间耗尽时被Full GC回收掉；即使未发生Full GC，软引用对内存的占用，也会导致GC次数的增加。</p><p>引用排队 Ref Enq：此项活动可能会导致RSet的更新，此时会通过记录日志，将关联的卡片标记为脏卡片。</p><p>卡片重新脏化 Redirty Cards：重新脏化卡片。</p><p>回收空闲巨型分区 Humongous Reclaim：G1做了一个优化：通过查看所有根对象以及年轻代分区的RSet，如果确定RSet中巨型对象没有任何引用，则说明G1发现了一个不可达的巨型对象，该对象分区会被回收。</p><p>释放分区 Free CSet：回收CSet分区的所有空间，并加入到空闲分区中。</p><p>其他活动 Other：GC中可能还会经历其他耗时很小的活动，如修复JNI句柄等。</p><h4 id="并发标记周期后的年轻代收集"><a href="#并发标记周期后的年轻代收集" class="headerlink" title="并发标记周期后的年轻代收集"></a><strong>并发标记周期后的年轻代收集</strong></h4><p>并发标记周期后的年轻代收集 Young Collection Following Concurrent Marking Cycle</p><p>当G1发起并发标记周期之后，并不会马上开始混合收集。G1会先等待下一次年轻代收集，然后在该收集阶段中，确定下次混合收集的CSet(Choose CSet)。</p><h4 id="混合收集周期"><a href="#混合收集周期" class="headerlink" title="混合收集周期"></a><strong>混合收集周期</strong></h4><p>混合收集周期 Mixed Collection Cycle</p><p>单次的混合收集与年轻代收集并无二致。根据暂停目标，老年代的分区可能不能一次暂停收集中被处理完，G1会发起连续多次的混合收集，称为混合收集周期(Mixed Collection Cycle)。G1会计算每次加入到CSet中的分区数量、混合收集进行次数，并且在上次的年轻代收集、以及接下来的混合收集中，G1会确定下次加入CSet的分区集(Choose CSet)，并且确定是否结束混合收集周期。</p><h3 id="转移失败的担保机制-Full-GC"><a href="#转移失败的担保机制-Full-GC" class="headerlink" title="转移失败的担保机制 Full GC"></a><strong>转移失败的担保机制 Full GC</strong></h3><p>转移失败的担保机制 Full GC</p><p>转移失败(Evacuation Failure)是指当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的Full GC。Full GC会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。</p><p><strong>G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</strong></p><p><strong>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区 从老年代分区转移存活对象时，无法找到可用的空闲分区 分配巨型对象时在老年代无法找到足够的连续分区 由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。</strong></p><h2 id="第五章-总结"><a href="#第五章-总结" class="headerlink" title="第五章 总结"></a><strong>第五章 总结</strong></h2><p>G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能；同时，我们也看到G1对内存空间的浪费较高，但通过**首先收集尽可能多的垃圾(Garbage First)**的设计原则，可以及时发现过期对象，从而让内存占用处于合理的水平。</p><p>本文转载自博客：<a href="https://blog.csdn.net/coderlius/article/details/79272773">https://blog.csdn.net/coderlius/article/details/79272773</a></p><p><strong>作者：coderlius</strong></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>参考资料</strong></p><p>[1] Charlie H, Monica B, Poonam P, Bengt R. Java Performance Companion [2] 周志明. 深入理解JVM虚拟机</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Garbage First(G1)是垃圾收集领域的最新成果，同时也是HotSpot在JVM上力推的垃圾收集器，并赋予取代CMS的使命。如果使用Java 8&amp;#x2F;9，那么有很大可能希望对G1收集器进行评估。本文详细首先对JVM其他的垃圾收集器进行总结，并与G1进行了简单的对比；然后通过G1的内存模型、G1的活动周期，对G1的工作机制进行了介绍；同时还在介绍过程中，描述了可能需要引起注意的优化点。笔者希望通过本文，让有一定JVM基础的读者能尽快掌握G1的知识点。&lt;strong&gt;另，本文较长，建议收藏阅读。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一章-概述&quot;&gt;&lt;a href=&quot;#第一章-概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;第一章 概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="http://localhost:4000/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL——锁</title>
    <link href="http://localhost:4000/2023/04/01/mysql/%E9%94%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://localhost:4000/2023/04/01/mysql/%E9%94%81%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-04-01T09:21:36.580Z</published>
    <updated>2023-04-16T13:05:34.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL——锁（全面总结）"><a href="#MySQL——锁（全面总结）" class="headerlink" title="MySQL——锁（全面总结）"></a>MySQL——锁（全面总结）</h1><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁机制用于管理对共享资源的并发访问。</p><span id="more"></span><h2 id="lock和latch"><a href="#lock和latch" class="headerlink" title="lock和latch"></a>lock和latch</h2><p>在<a href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>中，lock和Latch都称为锁，但是两者意义不同。</p><p>latch称为闩锁（shuang suo），其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又分为mutex互斥锁 和 rwLock读写锁。其目的是为了保证并发线程操作临界资源的正确性。通常没有死锁的检测机制。</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620.jpeg" alt="img"></p><p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或者rollback后进行释放。有死锁检测机制。</p><p>通过<code>show engine innodb mutex</code>可以查看InnoDB存储引擎的中latch，具体字段详情如下表：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842881.jpeg" alt="img"></p><h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>有几个索引，需要分别向索引加锁。</p><h3 id="共享锁、排他锁"><a href="#共享锁、排他锁" class="headerlink" title="共享锁、排他锁"></a>共享锁、排他锁</h3><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p><p><strong>共享锁（S Lock）</strong>：允许事务读一行数据</p><p><strong>排他锁（X Lock）</strong>：允许事务删除 或 更新一行数据</p><p>如果一个事务T1已经获取了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁。因为读取并不会改变行的数据，所以可以多个事务同时获取共享锁，称这种情况为<strong>锁兼容</strong>。但若有其他的事务T3想获得行R的排他锁，则其必须等待事务T1、T2释放行r上面的共享锁，称这种情况为<strong>锁不兼容</strong>。下面显示了共享锁和排他锁的兼容性：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842892.jpeg" alt="img"></p><p>从表6-3可以看出X锁与任何锁都不兼容，而S锁仅和S锁兼容。S锁和X锁都是行锁，兼容是指对同一行记录锁的兼容情况。</p><p><strong>普通 select 语句默认不加锁，而CUD操作默认加排他锁。</strong></p><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>Record Lock，<strong>仅锁定一行记录</strong>（如共享锁、排他锁）</p><ul><li>记录锁总是会去锁定索引记录，如果表在建立的时候，没有设置任何一个索引，那么InnoDB会使用隐式的主键来进行锁定。</li><li>查询条件的列是唯一索引的情况下，临键锁退化为记录锁</li></ul><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>Gap Lock，<strong>锁定一个范围，但不包含记录本身。</strong></p><p>关闭间隙锁的2种方式：</p><p>（1）将事务隔离级别变为read committed</p><p>（2）将参数innodb_locks_unsafe_for_binlog设置为1</p><p>在上述配置下，除了外键和唯一性检查依然需要间隙锁，其余情况仅适用行锁进行锁定。</p><h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><p>Next-Key Lock，等于记录锁 + 间隙锁，<strong>锁定一个范围，并且锁定记录本身</strong>。主要是阻止多个事务将记录插入到同一个范围内，从而避免幻读。</p><p>假如一个索引有10、11、13、20这四个值，那么该索引可能被锁定的区间为：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842893.jpeg" alt="img"></p><p>若事务T1已经通过临键锁锁定了如下范围： </p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842894.jpeg" alt="img"></p><p>当插入新的记录12时，则锁定的范围变成：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842895.jpeg" alt="img"></p><p><strong>当查询的索引是唯一索引的时候，InnoDB会将临键锁优化成记录锁，从而提高并发</strong>。这时候，将不再由间隙锁避免幻读的问题。</p><p>在可重复读的情况下，MVCC的SELECT操作只会查找行版本号小于当前事务版本号的记录，其他事务（事务开启时间比当前事务晚）新插入的记录版本号不满足条件，就不会查出来。</p><p>对于辅助索引，当执行类似<code>select * from z where b = 3 for update;</code>加锁语句时，会加上临键锁，并且下一个键值的范围也会加上间隙锁。（这里参考《<a href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a>技术内幕》，里面有具体例子）</p><p>值得注意的是，对于唯一键值的锁定，由临键锁优化为记录锁，仅存在于<strong>查询所有的唯一索引</strong>。若唯一索引由多列组成，而查询仅是查找多个唯一索引中的一个，那么查询其实是range类型查询，而不是point类型查询，故InnoDB存储引擎还是继续使用临键锁。</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842906.jpeg" alt="img"></p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842907.jpeg" alt="img"></p><p>在InnoDB存储引擎中，通过使用临键锁来避免不可重复读的问题（即幻读）。在使用临键锁的情况下，对于索引的扫描，不仅仅锁住扫描的到索引，而且还锁住这些索引覆盖的范围。因此，在这些范围内插入都是不允许的。这样子就避免了其他事务在这些范围内插入数据导致不可重复读的问题。</p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>概念：<strong>事务可能要加共享&#x2F;排它锁了，先提前声明一个意向</strong></p><p>意向锁有这样一些特点：</p><p>（1）意向锁是表级别的锁</p><p>（2）意向锁分为：</p><ul><li><strong>意向共享锁</strong>(intention shared lock, IS)，它预示着，事务有意向对表中的<strong>某些行</strong>加共享S锁 </li><li><strong>意向排它锁</strong>(intention exclusive lock, IX)，它预示着，事务有意向对表中的<strong>某些行</strong>加排它X锁</li></ul><p>（3）意向锁协议：</p><ul><li><strong>事务要获得某些行的共享锁，必须先获得表的意向共享锁IS</strong></li><li><strong>事务要获取某些行的排他锁，必须先获得表的意向排他锁IX</strong></li></ul><p>（4）由于意向锁仅仅表明意向，它其实是比较弱的锁，<strong>意向锁之间并不相互互斥，而是可以并行</strong>，其<strong>兼容互斥表</strong>如下：</p><p>​          IS          IX</p><p>IS      兼容      兼容</p><p>IX      兼容      兼容</p><p>（5）既然意向锁之间都相互兼容，<strong>那其意义在哪里呢</strong>？它会与共享锁&#x2F;排它锁互斥，其<strong>兼容互斥表</strong>如下：</p><p>​          S          X</p><p>IS      兼容      互斥</p><p>IX      互斥      互斥</p><p>（排它锁是很强的锁，不与其他类型的锁兼容。这也很好理解，修改和删除某一行的时候，必须获得强锁，禁止这一行上的其他并发，以保障数据的一致性。）</p><p>InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。<strong>为了支持不同粒度上进行加锁操作</strong>，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更粗的粒度上进行加锁。如图6-3所示：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842908.jpeg" alt="img"></p><p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象上锁，那么首先需要对粗粒度的对象进行上锁。如上图，如果需要对页上的记录上X锁，那么需要分别对数据库A、表、页 上意向锁IX，最后对记录r上排他锁X。</p><p>若其中任何一部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，事务T1在对记录r加X锁之前，已有事务T2对表1进行了S表锁，那么表1上面已经存在S锁，之后事务T1试图在表1上加IX锁（获取记录r的X锁必须先获取表1的IX锁），由于不兼容，所以事务T1需要等待事务T2释放表锁。</p><h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>对已有数据行的<strong>修改与删除</strong>，必须排他锁，那对于<strong>数据的插入</strong>，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。</p><p><strong>插入意向锁</strong>，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），<strong>它是专门针对insert操作的</strong>。</p><p>它的用处是：<strong>多个事务，在同一个索引上插入记录时，如果插入的位置不冲突，不会阻塞彼此。</strong></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">在<span class="title class_">MySQL</span>，<span class="title class_">InnoDB</span>，<span class="variable constant_">RR</span>下：</span><br><span class="line"></span><br><span class="line"><span class="title function_">t</span>(id unique <span class="variable constant_">PK</span>, name);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">数据表中有数据：</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>, shenjian</span><br><span class="line"></span><br><span class="line"><span class="number">20</span>, zhangsan</span><br><span class="line"></span><br><span class="line"><span class="number">30</span>, lisi</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">事务A先执行，在<span class="number">10</span>与<span class="number">20</span>两条记录中插入了一行，还未提交：</span><br><span class="line"></span><br><span class="line">insert into t <span class="title function_">values</span>(<span class="number">11</span>, xxx);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">事务B后执行，也在<span class="number">10</span>与<span class="number">20</span>两条记录中插入了一行：</span><br><span class="line"></span><br><span class="line">insert into t <span class="title function_">values</span>(<span class="number">12</span>, ooo);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)会使用什么锁？</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)事务B会不会被阻塞呢？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">回答：虽然事务隔离级别是<span class="variable constant_">RR</span>，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：</span><br><span class="line"></span><br><span class="line">使用的是插入意向锁</span><br><span class="line"></span><br><span class="line">并不会阻塞事务B</span><br></pre></td></tr></table></figure><p>复制</p><h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><p>自增锁是MySQL一种特殊的锁，如果<strong>表中存在自增字段，MySQL便会自动维护一个自增锁。</strong></p><p>在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长计数器的表进行插入操作时，这个计数器会被初始化，执行如下操作来得到计数器的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(auto_inc_col) from t for </span><br></pre></td></tr></table></figure><p>插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式成为<strong>Auto-Inc Locking</strong>。这种锁其实是采用一种表锁的机制，为了提高插入的性能，<strong>自增长锁不是在一个事务完成以后才释放，而是在完成自增长值插入的SQL后立即释放。</strong></p><p>虽然<strong>Auto-Inc Locking</strong>从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成）。</p><p>从MySQL5.12版本开始，InnoDB存储引擎提供了一种轻量级互斥量的自增长实现方式。这种方式大大提高了自增长值插入的性能。并且从该版本开始，InnoDB存储引起提供了一个参数innodb_innodb_autoinc_lock_mode来控制自增长模式，该参数的默认值为1。首先看下<strong>自增长的插入分类</strong>，如下图：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842909.jpeg" alt="img"></p><p>下图展示了innodb_innodb_autoinc_lock_mode的不同值对自增的影响：（<strong>值为1、2的时候，看不懂。。</strong>）</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429110.jpeg" alt="img"></p><p>InnoDB存储引擎中自增长的实现和MyISAM不同。<strong>MyISAM存储引擎是表锁设计，自增长不用考虑并发插入的问题</strong>。<strong>在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列</strong>，如果不是第一个列，则MySQL会抛出异常。MyISAM存储引擎没有这个问题。</p><p>参考：<a href="http://blog.itpub.net/15498/viewspace-2141640/">http://blog.itpub.net/15498/viewspace-2141640/</a></p><h3 id="外键与锁"><a href="#外键与锁" class="headerlink" title="外键与锁"></a>外键与锁</h3><p><strong>如果没有为外键显式添加索引，InnoDB自动为外键创建索引，这样子避免表锁。</strong></p><p>对于外键值的插入或更新，首先需要查询父表中的记录，即select父表。但不使用一致性非锁定读，因为这样子会发生数据不一致的问题。因此这时使用的是select…lock in share mode，即主动对父表加一个共享锁（这也解释了为了外键一定要索引，如果没有索引，就只能使用表锁了）。如果这时父表已经加了X锁，子表上面的操作将会被阻塞，如下图：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429111.jpeg" alt="img"></p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429212.jpeg" alt="img"></p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MVCC数据多版本又称为<strong>一致性非锁定读</strong>。指<strong>InnoDB通过行多版本控制的方式来读取当前数据库中行的数据</strong>。如果读取的行正在执行delete或者update操作，这时读操作不会因此去等待行上锁的释放。相反的，InnoDB存储引擎会去读取行的一个快照数据。</p><p>在默认配置下，即事务的隔离界别为<strong>REPEATABLE READ（可重复读）</strong>模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。</p><p>快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p><p>非锁定度机制极大的提高了数据库的并发性。这是InnoDB默认的读取方式，即读取不会占用表上的锁。但是在不同事务隔离界别下，读取的方式不同，并不是在每个事务隔离界别下都是采用非锁定的一致性读。此外，即使都是使用非锁定的一致性读，但是对于快照数据的定义也是各不相同。</p><p>快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。<strong>一个行记录可能有不止一个快照数据</strong>，一般称这种技术为<strong>行多版本技术</strong>，由此带来的并发控制，称之为<strong>多版本并发控制</strong> MVCC。</p><p>在<strong>事务隔离界别read committed 和 repeatable read</strong>（InnoDB默认的事务隔离界别）下，InnoDB使用非锁定一致性读。然而，对于快照数据的定义却不相同。</p><ul><li>在read committed隔离级别下，非一致性读总是读取被锁定行的最新一份快照数据（如果没有被锁定，则读取行的最新数据；如果行锁定了，则读取该行的最新一个快照）。</li><li>在repeatable read事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的快照。</li></ul><h3 id="MVCC的优缺点"><a href="#MVCC的优缺点" class="headerlink" title="MVCC的优缺点"></a>MVCC的优缺点</h3><p>MVCC在大多数情况下代替了行锁，<strong>实现了对读的非阻塞，读不加锁，读写不冲突</strong>，极大的提高了读效率。</p><p>缺点是每行记录都需要<strong>额外的存储空间</strong>，需要做更多的行维护和检查工作。</p><p>注意<strong>写写不能并行</strong>。一个事务的写操作是会加排他锁的，其他事务如果对该记录进行修改，必须等待之前的事务释放锁。</p><h3 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h3><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>undo log是为回滚而用，具体内容就是复制事务开始前的<strong>行</strong>到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。在Innodb中，undo log被划分为多个段，具体某行的undo log就保存在某个段中，称为回滚段。<strong>可以认为undo log和回滚段是同一意思</strong>。</p><p>为了便于理解MVCC的实现原理，这里简单介绍一下undo log的工作过程</p><p>在不考虑redo log 的情况下利用undo log工作的简化过程为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">序号动作</span><br><span class="line"><span class="number">1</span>   开始事务</span><br><span class="line"><span class="number">2</span> 记录数据行数据备份到undo log</span><br><span class="line"><span class="number">3</span> 更新数据</span><br><span class="line"><span class="number">4</span> 将undo log写到磁盘</span><br><span class="line"><span class="number">5</span> 提交事务</span><br></pre></td></tr></table></figure><p>复制</p><p>（1）undo log的持久化必须在在数据持久化之前，这样才能保证系统崩溃时，可以用undo log来回滚事务</p><p>（2）Innodb通过undo log保存了已更改行的旧版本的快照。</p><p>（3）提交事务做的事情有：写redo log和binlog，并且把数据持久化到磁盘（可以通过参数控制）</p><h4 id="InnoDB中的隐藏列"><a href="#InnoDB中的隐藏列" class="headerlink" title="InnoDB中的隐藏列"></a>InnoDB中的隐藏列</h4><p>InnoDB的内部实现中为每一行数据增加了三个隐藏列用于实现MVCC。</p><table><thead><tr><th align="left">列名</th><th align="left">长度(字节)</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">DB_TRX_ID</td><td align="left">6</td><td align="left">插入或更新行的最后一个事务的事务ID。（删除视为更新，将其标记为已删除）</td></tr><tr><td align="left">DB_ROLL_PTR</td><td align="left">7</td><td align="left">写入回滚段的撤消日志记录（若行已更新，则撤消日志记录包含在更新行之前重建行内容所需的信息）</td></tr><tr><td align="left">DB_ROW_ID</td><td align="left">6</td><td align="left">行ID（隐藏单调自增id）</td></tr></tbody></table><p>一行记录的结构如下：</p><table><thead><tr><th align="left">数据列</th><th align="left">…</th><th align="left">DB_ROW_ID</th><th align="left">DB_TRX_ID</th><th align="left">DB_ROLL_PTR</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h4 id="MVCC的SQL规则"><a href="#MVCC的SQL规则" class="headerlink" title="MVCC的SQL规则"></a>MVCC的SQL规则</h4><p>MVCC只在READ COMMITED 和 REPEATABLE READ 两个隔离级别下工作。READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE 则会对所有读取的行都加锁。另外事务的版本号是递增的。</p><p><strong>SELECT</strong></p><p>InnoDB只查找 行的事务ID 小于当前事务ID 的数据行（避免幻读）</p><p><strong>INSERT</strong></p><p>新插入的每一行保存当前事务ID作为行的事务ID</p><p><strong>DELETE</strong></p><p>删除的每一行保存当前事务ID作为行的事务ID</p><p><strong>UPDATE</strong></p><p>实际上是删除旧行，插入新行。</p><p>保存当前的事务ID作为新行的事务ID，同时保存当前事务ID到旧行的事务ID。</p><h4 id="MVCC插入示例"><a href="#MVCC插入示例" class="headerlink" title="MVCC插入示例"></a>MVCC插入示例</h4><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429213.jpeg" alt="img"></p><p>F1F6是字段名称，16是对应的数据。后面3个隐藏字段分别对应行ID、事务ID、回滚指针。</p><p><strong>初始状态</strong></p><p>假如有一条初始的数据，可以认为行ID为1，其他两个字段为空。</p><p><strong>事务1更改该行的值</strong></p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429314.jpeg" alt="img"></p><p>当事务1更改该行的值时，会进行如下操作：</p><ul><li>用排他锁锁定该行</li><li><strong>把该行修改前的值复制到undo log</strong>，即上图中下面的行</li><li>使回滚指针指向undo log中的行</li><li>修改当前的行的值，填写事务编号</li><li>释放锁</li></ul><p><strong>事务2更改该行的值</strong></p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429315.jpeg" alt="img"></p><p>与事务1相同，此时undo log中有2条记录，并且通过回滚指针连在一起。</p><p>因此，如果undo log一直不删除，则可以通过当前记录的回滚指针回溯到该行创建时的初始内容，所幸的是在<strong>InnoDB中存在清理线程，它会查询比现在最老的事务还早的undo log，并删除它们，从而保证undo log文件不会无限增长</strong>。</p><h4 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h4><p>主要用来判断当前版本数据的可见性。</p><p>在InnoDB中，创建一个新事务的时候，InnoDB会将当前系统中的活跃事务列表（trx_sys-&gt;trx_list）创建一个副本（read view），副本中保存的是系统当前不应该被本事务看到的其他事务id列表。当用户在这个事务中要读取该行记录的时候，innodb会将该行当前的版本号与该read view进行比较。 具体的算法如下:</p><ol><li>设该行的当前事务id为trx_id_0，read view中最早的事务id为trx_id_1, 最迟的事务id为trx_id_2。</li><li>如果trx_id_0&lt; trx_id_1的话，那么表明该行记录所在的事务已经在本次新事务创建之前就提交了，所以该行记录的当前值是可见的。跳到步骤6.</li><li>如果trx_id_0&gt;trx_id_2的话，那么表明该行记录所在的事务在本次新事务创建之后才开启，所以该行记录的当前值不可见.跳到步骤5。</li><li>如果trx_id_1&lt;&#x3D;trx_id_0&lt;&#x3D;trx_id_2, 那么表明该行记录所在事务在本次新事务创建的时候处于活动状态，从trx_id_1到trx_id_2进行遍历，如果trx_id_0等于他们之中的某个事务id的话，那么不可见。跳到步骤5.</li><li>从该行记录的DB_ROLL_PTR指针所指向的回滚段中取出最新的undo-log的版本号，将它赋值该trx_id_0，然后跳到步骤2.</li><li>将该可见行的值返回。</li></ol><p>需要注意的是，新建事务(当前事务)与正在内存中commit 的事务不在活跃事务链表中。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>读操作远远大于写操作的场景，因此适用于绝大多数互联网场景。</p><h2 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h2><p>在默认的配置下，即事务的隔离级别为可重复度，InnoDB存储引擎的select操作使用一致性非锁定读（即MVCC）。但是在某些情况下，用户需要显示的对数据库读取操作进行加锁，以保证数据逻辑的一致性。而这要求数据库支持加锁语句，InnoDB存储引擎对select支持两种一致性的锁定读操作：</p><ul><li>select …  for update</li><li>select … lock in share mode;</li></ul><p><strong>select…for update对读取的行记录加一个X锁</strong>，其他事务不能对已锁定的行加上任何锁。</p><p><strong>select…lock in share mode对读取的行记录加一个S锁</strong>，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。</p><p>对于一致性非锁定读，即时读取的行已经被执行了select…for update，也是可以进行读取的。</p><p>select…for update或者select…lock in share mode必须在事务中，因为当事务提交了，锁也就释放了。从而避免锁没有释放，可能导致死锁的情况。</p><p><strong>如果不加筛选条件（或者筛选条件不走索引），会升级为表锁</strong></p><p><strong>索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。</strong></p><p>参考：<a href="https://blog.csdn.net/u012099869/article/details/52778728">https://blog.csdn.net/u012099869/article/details/52778728</a> </p><h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>脏数据</strong>：指的是<strong>事务对缓冲池中行记录的修改，并且还没有提交</strong>。即事务未提交的数据。</p><p><strong>脏读</strong>：指当前事务可以读到其他事务的未提交的数据。如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，显然违反了事务的隔离性。</p><p><strong>脏读的条件</strong>：需要事务的隔离级别为<strong>读未提交</strong>。</p><p><strong>示例</strong>：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429316.jpeg" alt="img"></p><p><strong>解决</strong>：设置事务的隔离级别为“读已提交”或者更高的隔离界别。</p><p>​    那<strong>为什么“读已提交”能解决脏读的问题？</strong>  我的理解是，在“读已提交”的情况下，读取的是快照的最新版本的数据，那么既然读取的是快照数据了，那么这些数据肯定是之前的事务提交过了的。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>不可重复读</strong>：指在在一个事务内多次读取同一个数据集合，在这个事务还没有结束时，另外一个事务也访问了同一个数据集合，并且做了一些修改或新增操作。因此，在第一个事务的两次读数据之间，由于第二个事务的修改，第一个事务两次读取到的数据可能是不一样的（具体看隔离级别）。这种称为<strong>不可重复读</strong>。</p><p><strong>示例</strong>：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429317.jpeg" alt="img"></p><p><strong>幻读：同一事务下，连续执行2次相同的sql，可能返回不同的结果，第二次的sql可能返回之前不存在的行。</strong></p><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p><strong>丢失更新</strong>：指一个事务的更新操作被另外一个事务的更新操作所覆盖，从而导致数据的不一致。</p><p><strong>丢失更新的实例</strong>：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429318.jpeg" alt="img"></p><p><strong>解决办法</strong>：对用户读取的记录加上一个排他锁，这样子其他事务就必须等待前一个事务的完成。从而避免并发问题。</p><p><strong>解决办法的示例</strong>：</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429419.jpeg" alt="img"></p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><strong>阻塞</strong>：事务因为等待其他事务释放锁而等待</p><p><strong>超时</strong>：等待其他事务释放锁，超过超时时间，就认为是超时。</p><p><strong>innodb_lock_wait_timeout</strong>：用来控制超时时间，默认是50秒。可以在MYSQL运行时进行设置。</p><p><strong>innodb_rollback_on_timeout</strong>：用来设定是否在等待超时时对进行中的事务进行回滚操作。默认是OFF，不回滚。不可以在MySQL启动时进行修改。用户在超时的情况下，必须判断是是否需要commit或者rollback，之后再进行下一步的操作。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>概念</strong>：死锁是指两个或者两个以上的事务，因争夺资源而造成的一种互相等待的现象。若无外力作用，所有事务都将无法推进下去。</p><h3 id="FIFO处理死锁"><a href="#FIFO处理死锁" class="headerlink" title="FIFO处理死锁"></a>FIFO处理死锁</h3><p><strong>解决数据库死锁最简单的方法</strong>：设置超时时间。即当两个事务互相等待时，当一个等待时间超过设置的阈值时，其中一个事务进行回滚，另外一个等待的事务就能继续执行。</p><p>超时机制虽然简单，但是其使用FIFO的方式来选择超时回滚的事务，假如第一个超时的事务 更新了很多行，远比第二个事务多，因此占用了更多的undo log，这时FIFO的方式，就显得不适用了，因为第一个事务回滚时间明显比第二个事务回滚时间长很多。</p><h3 id="等待图"><a href="#等待图" class="headerlink" title="等待图"></a>等待图</h3><p>因为FIFO处理死锁可能不适用，所以数据库普遍采用了wait-for graph（等待图）的方式来进行死锁检测。和超时机制比较，这是一种更为主动的死锁检测方式，InnoDB也采用了这种方式。</p><p>等待图要求数据库保存以下两种信息：</p><p>（1）锁的信息链表（见图6-5 右）</p><p>（2）事务等待链表（见图6-5 左）</p><p>通过上述链表可以构造出一张图，而在这个<strong>图中存在回路，则代表存在死锁</strong>。在等待图中，事务为图中的节点。在图中，事务T1指向事务T2边的定义为：</p><p>（1）事务T1等待事务T2所占用的资源</p><p>（2）事务之间在等待相同的资源，而事务T1在事务T2之后</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429420.jpeg" alt="img"></p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429421.jpeg" alt="img"></p><p>发现死锁后，InnoDB会马上回滚一个undo量最小的事务。 </p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p><strong>概念</strong>：<strong>将当前锁的粒度降低，比如说把行锁升级为表锁，那样子会导致并发性能降低。</strong></p><p>InnoDB不是根据每个记录来产生行锁的，而是根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式，因此不管一个事务锁住页中一条还是多条记录，都是用一个锁，其开销通常是一致的。</p><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429422.jpeg" alt="img"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>快照读、当前读指的是什么，有什么区别？</strong></p><p>快照读:</p><ul><li>读取数据的备份，不用加锁，这个数据可能是旧数据.</li><li>比如说普通的select语句。</li></ul><p>当前读:</p><ul><li>读取的数据最新版本 </li><li>读数据的时候会加上锁，保证其他事务不会并发修改这条记录。 </li><li>如select … lock in share mode select … for update insert update delete</li></ul><p>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MySQL——锁（全面总结）&quot;&gt;&lt;a href=&quot;#MySQL——锁（全面总结）&quot; class=&quot;headerlink&quot; title=&quot;MySQL——锁（全面总结）&quot;&gt;&lt;/a&gt;MySQL——锁（全面总结）&lt;/h1&gt;&lt;h1 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h1&gt;&lt;p&gt;锁机制用于管理对共享资源的并发访问。&lt;/p&gt;</summary>
    
    
    
    
    <category term="mysql" scheme="http://localhost:4000/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL慢查询</title>
    <link href="http://localhost:4000/2023/04/01/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    <id>http://localhost:4000/2023/04/01/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2/</id>
    <published>2023-04-01T09:21:36.576Z</published>
    <updated>2023-04-16T13:05:07.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你的哪些SQL慢？看看MySQL慢查询日志吧"><a href="#你的哪些SQL慢？看看MySQL慢查询日志吧" class="headerlink" title="你的哪些SQL慢？看看MySQL慢查询日志吧"></a>你的哪些SQL慢？看看MySQL慢查询日志吧</h1><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/c54e191f715b46f790314f91ee307dd9tplv-k3u1fbpfcp-zoom-crop-mark3024302430241702.awebp" alt="你的哪些SQL慢？看看MySQL慢查询日志吧"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在项目里面，多多少少都隐藏着一些执行比较慢的SQL, 不同的开发测试人员在平时使用的过程中多多少少都能够遇到，但是无法立马有时间去排查解决。那么如果有一个文件能够将这些使用过程中比较慢的SQL记录下来，定期去分析排查，那该多美好啊。这种情况MySQL也替我们想到了，它提供了SQL慢查询的日志，本文就分享下如何使用吧。</p><span id="more"></span><h2 id="什么是慢查询日志？"><a href="#什么是慢查询日志？" class="headerlink" title="什么是慢查询日志？"></a>什么是慢查询日志？</h2><p>MySQL的慢询日志，提供了记录在MySQL中响应时间超过指定阈值语句的功能，比如设定阈值为3秒，那么任何SQL执行超过3秒都会被记录下来。</p><p>我们借助慢查询日志功能可以发现哪些那些执行时间特别长的询，并且有针对性地进行优化，从而提高系统的整体效率。</p><h2 id="怎么开启慢查询日志？"><a href="#怎么开启慢查询日志？" class="headerlink" title="怎么开启慢查询日志？"></a>怎么开启慢查询日志？</h2><p>默认情况下，MySQL数据库<strong>没有开启</strong>慢查询日志，因为多多少少会带来一定性能的影响。我们可以在开发测试环境、或者生产环境做调优的时候开启，<strong>那怎么查看是否开启了呢？</strong></p><ol><li><strong>查看慢SQL是否开启</strong></li></ol><p>执行下面命令查看是否开启慢SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/d27eadf02574490392490f937b367416tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p><ul><li><code>OFF</code>: 未开启</li><li><code>ON</code>: 开启</li></ul><ol><li><strong>如何开启慢查询</strong></li></ol><p>执行下面的命令开启慢查询日志</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> set global <span class="attr">slow_query_log</span>=<span class="string">&#x27;ON&#x27;</span><span class="comment">;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/25c5256478534072aeaeae967b8a164btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p><ol><li><strong>修改慢查询阈值</strong></li></ol><p>前面介绍了SQL执行到达了制定的时间阈值后记录到慢查询日志中，那么如何设置呢？</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set global <span class="attr">long_query_time</span> = N<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">set <span class="attr">long_query_time</span> = N</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><p>设置global的方式对当前<code>session</code>的<code>long_query_time</code>失效。对新连接的客户端有效。所以可以一并执行下述语句</p></li><li><p>N表示设置的阈值，单位为秒</p></li></ul><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/193484811274457cb7bfc12be950bfe7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p><ul><li>这里的<code>show global variables like &#39;%long_query_time%&#39;;</code>可以查看阈值大小</li></ul><ol><li><strong>如何设置永久生效</strong></li></ol><p>前面是通过命令行的方式设置，如果MySQL重启，那么配置就会重置。我们可以通过修改MySQL的配置<code>my.cfg</code>或者<code>my.ini</code>永久生效。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="literal">ON</span>  <span class="comment"># 开启慢查询日志开关</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=/var/lib/mysql/alvin-slow.log  <span class="comment"># 慢查询日志的目录和文件名信息</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">3</span>  <span class="comment"># 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line"><span class="attr">log_output</span>=FILE</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="慢查询日志在哪里呢？"><a href="#慢查询日志在哪里呢？" class="headerlink" title="慢查询日志在哪里呢？"></a>慢查询日志在哪里呢？</h2><p>前面讲解了如何开启MySQL的慢查询日志，那么它把日志记录在哪里了呢?</p><ol><li><strong>查看慢查询日志位置</strong></li></ol><p>通过<code>show variables like &#39;%slow_query_log_file%&#39;;</code>命令可以查看慢SQL文件位置，如下图所示：</p><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/b8cde05cdcac4b069abc4cab2c48e223tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p><ol><li><strong>修改慢查询日志位置</strong></li></ol><p>也很简单，执行下面的命令即可：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global <span class="attr">slow_query_log_file</span> = <span class="string">&#x27;/usr/local/mysql/data/alvin-slow-slow.log&#x27;</span><span class="comment">;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="怎么查看慢SQL内容？"><a href="#怎么查看慢SQL内容？" class="headerlink" title="怎么查看慢SQL内容？"></a>怎么查看慢SQL内容？</h2><p>现在我们已经知道慢查询日志在哪里了，那么如何查看里面的内容呢？我们这里用一个例子演示下吧。</p><ol><li><strong>执行一个查询的SQL</strong></li></ol><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/ca631d0a573c4afbac3c6c853b74a7aatplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p><ul><li>执行花了1秒多，超过了前面设置的阈值1s</li></ul><ol><li><strong>查看慢查询数目</strong></li></ol><p>执行下面命令查询当前系统中有多少条慢查询记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/554c1a7baf8c497985dfa3b06849bc50tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p><ul><li>value&#x3D;1, 表明刚刚的日志被记录了。</li></ul><ol><li><strong>查看日志内容</strong></li></ol><p>通过<code>cat</code>命令查看文件内容，可以看到对应的慢SQL。</p><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/a054f8b478b24c2c8112ecf49c5e280btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p><h3 id="慢查询日志分析工具mysqldumpslow"><a href="#慢查询日志分析工具mysqldumpslow" class="headerlink" title="慢查询日志分析工具mysqldumpslow"></a>慢查询日志分析工具mysqldumpslow</h3><p>果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 <code>mysqldumpslow</code> 。</p><p><code>mysqldumpslow</code> 命令的具体参数如下：</p><ul><li><p>-a: 不将数字抽象成N，字符串抽象成S</p></li><li><p>-s: 是表示按照何种方式排序：</p></li><li><ul><li>c: 访问次数</li><li>l: 锁定时间</li><li>r: 返回记录</li><li>t: 查询时间</li><li>al:平均锁定时间</li><li>ar:平均返回记录数</li><li>at:平均查询时间 （默认方式）</li><li>ac:平均查询次数</li></ul></li><li><p>-t: 即为返回前面多少条的数据；</p></li><li><p>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</p></li></ul><p>可mysqldumpslow位置mysql的bin目录下，以通过执行 mysqldumpslow –help命令查看使用。</p><p><strong>举例：</strong> 我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t <span class="number">5</span> /usr/<span class="keyword">local</span>/mysql/data/alvin-slow-slow.<span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/17062293febf4466b0b27e4abcccea76tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p><p><strong>常见的用法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /usr/local/mysql/data/alvin-slow-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /usr/local/mysql/data/alvin-slow-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g <span class="string">&quot;left join&quot;</span> /usr/local/mysql/data/alvin-slow-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /usr/local/mysql/data/alvin-slow-slow.log | more</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="怎么删除慢SQL日志？"><a href="#怎么删除慢SQL日志？" class="headerlink" title="怎么删除慢SQL日志？"></a>怎么删除慢SQL日志？</h2><p>现在慢查询日志很多了啊，为了不互相混淆，我要删除一些慢SQL日志，怎么删除呢？</p><ol><li>手动删除慢查询日志文件即可, 也就是<code>rm</code>命令。</li><li>使用命令<code>mysqladmin flush-logs </code>重置慢sql日志内容，完整命令如下 ：</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs slow</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;你的哪些SQL慢？看看MySQL慢查询日志吧&quot;&gt;&lt;a href=&quot;#你的哪些SQL慢？看看MySQL慢查询日志吧&quot; class=&quot;headerlink&quot; title=&quot;你的哪些SQL慢？看看MySQL慢查询日志吧&quot;&gt;&lt;/a&gt;你的哪些SQL慢？看看MySQL慢查询日志吧&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/c54e191f715b46f790314f91ee307dd9tplv-k3u1fbpfcp-zoom-crop-mark3024302430241702.awebp&quot; alt=&quot;你的哪些SQL慢？看看MySQL慢查询日志吧&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在项目里面，多多少少都隐藏着一些执行比较慢的SQL, 不同的开发测试人员在平时使用的过程中多多少少都能够遇到，但是无法立马有时间去排查解决。那么如果有一个文件能够将这些使用过程中比较慢的SQL记录下来，定期去分析排查，那该多美好啊。这种情况MySQL也替我们想到了，它提供了SQL慢查询的日志，本文就分享下如何使用吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="mysql" scheme="http://localhost:4000/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？</title>
    <link href="http://localhost:4000/2023/04/01/mysql/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/"/>
    <id>http://localhost:4000/2023/04/01/mysql/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/</id>
    <published>2023-04-01T09:21:36.502Z</published>
    <updated>2023-04-16T13:06:15.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-默认隔离级别是RR，为什么阿里等大厂会改成RC？"><a href="#MySQL-默认隔离级别是RR，为什么阿里等大厂会改成RC？" class="headerlink" title="MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？"></a>MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？</h1><p><a href="https://www.51cto.com/database">数据库</a><a href="https://www.51cto.com/mysql">MySQL</a></p><p>本文介绍了一些 MySQL数据库的 RR 和 RC 两种事务隔离级别。他们主要在加锁机制、主从同步以及一致性读方面存在一些差异。</p><p><a href="https://s4.51cto.com/oss/202112/10/f60aed5572130a97f3bd19e4299af009.jpg"><img src="/media/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/f60aed5572130a97f3bd19e4299af009.jpg" alt="img"></a></p><p> 我之前写过一篇文章《为什么MySQL选择REPEATABLE READ作为默认隔离级别？》介绍过MySQL 的默认隔离级别是 Repeatable Reads以及背后的原因。</p><p>主要是因为MySQL在主从复制的过程是通过bin log 进行数据同步的，而MySQL早期只有statement这种bin log格式，这种格式下，bin log记录的是SQL语句的原文。</p><p>当出现事务乱序的时候，就会导致备库在 SQL 回放之后，结果和主库内容不一致。</p><p>为了解决这个问题，MySQL默认采用了Repetable Read这种隔离级别，因为在 RR 中，会在更新数据的时候增加记录锁的同时增加间隙锁。可以避免这种情况的发生。</p><p>关于MySQL的加锁方式及加锁原则，可以参考我写的另外一篇《求你了，别再说数据库锁的只是索引了！》，这里就不再赘述了。</p><p>在我知道MySQL 默认隔离级别是RR后，很长一段时间都以为应该不会有人去修改这个默认配置。</p><p>但是直到有一天，我们线上发生了一次死锁的问题，我在排查的过程中，才发现我们的数据库用的隔离级别没有使用默认的 RR，而是修改成了Read Committed 。（关于那次死锁排查过程，可以参考：一次数据库的死锁问题排查过程）</p><p>大家可以通过这个命令查看数据库当前的隔离级别： </p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation; </span><br><span class="line">1.</span><br></pre></td></tr></table></figure><p>那么，这里不禁就有疑问了，为啥阿里要把这个数据库隔离级别修改成 RC 呢，背后有什么思考吗？</p><span id="more"></span><h2 id="RR-和-RC-的区别"><a href="#RR-和-RC-的区别" class="headerlink" title="RR 和 RC 的区别"></a>RR 和 RC 的区别</h2><p>想要搞清楚这个问题，我们需要先弄清楚 RR 和 RC 的区别，分析下各自的优缺点。</p><h3 id="一致性读"><a href="#一致性读" class="headerlink" title="一致性读"></a>一致性读</h3><p>一致性读，又称为快照读。快照即当前行数据之前的历史版本。快照读就是使用快照信息显示基于某个时间点的查询结果，而不考虑与此同时运行的其他事务所执行的更改。</p><p>在MySQL 中，只有READ COMMITTED 和 REPEATABLE READ这两种事务隔离级别才会使用一致性读。</p><p>在 RC 中，每次读取都会重新生成一个快照，总是读取行的最新版本。</p><p>在 RR 中，快照会在事务中第一次SELECT语句执行时生成，只有在本事务中对数据进行更改才会更新快照。</p><p>在数据库的 RC 这种隔离级别中，还支持”半一致读” ，一条update语句，如果 where 条件匹配到的记录已经加锁，那么InnoDB会返回记录最近提交的版本，由MySQL上层判断此是否需要真的加锁。</p><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>数据库的锁，在不同的事务隔离级别下，是采用了不同的机制的。在 MySQL 中，有三种类型的锁，分别是Record Lock、Gap Lock和 Next-Key Lock。</p><p>Record Lock表示记录锁，锁的是索引记录。</p><p>Gap Lock是间隙锁，锁的是索引记录之间的间隙。</p><p>Next-Key Lock是Record Lock和Gap Lock的组合，同时锁索引记录和间隙。他的范围是左开右闭的。</p><p>在 RC 中，只会对索引增加Record Lock，不会添加Gap Lock和Next-Key Lock。</p><p>在 RR 中，为了解决幻读的问题，在支持Record Lock的同时，还支持Gap Lock和Next-Key Lock；</p><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p>在数据主从同步时，不同格式的 binlog 也对事务隔离级别有要求。</p><p>MySQL的binlog主要支持三种格式，分别是statement、row以及mixed，但是，RC 隔离级别只支持row格式的binlog。如果指定了mixed作为 binlog 格式，那么如果使用RC，服务器会自动使用基于row 格式的日志记录。</p><p>而 RR 的隔离级别同时支持statement、row以及mixed三种。</p><h2 id="为什么互联网公司选择使用-RC"><a href="#为什么互联网公司选择使用-RC" class="headerlink" title="为什么互联网公司选择使用 RC"></a>为什么互联网公司选择使用 RC</h2><h3 id="提升并发"><a href="#提升并发" class="headerlink" title="提升并发"></a>提升并发</h3><p>互联网公司和传统企业最大的区别是什么？</p><p><strong>高并发！</strong></p><p>没错，互联网业务的并发度比传统企业要高处很多。2020年双十一当天，订单创建峰值达到 58.3 万笔&#x2F;秒。</p><p>很多人问，要怎么做才能扛得住这么大的并发量。其实，这背后的优化多到几个小时都讲不完，因为要做的、可以做的事情实在是太多了。</p><p>而有一个和我们今天这篇文章有关的优化，那就是通过修改数据库的隔离级别来提升并发度。</p><p>为什么 RC 比 RR 的并发度要好呢？</p><p>首先，RC 在加锁的过程中，是不需要添加Gap Lock和 Next-Key Lock 的，只对要修改的记录添加行级锁就行了。</p><p>这就使得并发度要比 RR 高很多。</p><p>另外，因为 RC 还支持”半一致读”，可以大大的减少了更新语句时行锁的冲突；对于不满足更新条件的记录，可以提前释放锁，提升并发度。</p><h3 id="减少死锁"><a href="#减少死锁" class="headerlink" title="减少死锁"></a>减少死锁</h3><p>因为RR这种事务隔离级别会增加Gap Lock和 Next-Key Lock，这就使得锁的粒度变大，那么就会使得死锁的概率增大。</p><p> 死锁：一个事务锁住了表A，然后又访问表B；另一个事务锁住了表B，然后企图访问表A；这时就会互相等待对方释放锁，就导致了死锁。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了一些 MySQL数据库的 RR 和 RC 两种事务隔离级别。他们主要在加锁机制、主从同步以及一致性读方面存在一些差异。</p><p>而很多大厂，为了提升并发度和降低死锁发生的概率，会把数据库的隔离级别从默认的 RR 调整成 RC。</p><p>当然，这样做也不是完全没有问题，首先使用 RC 之后，就需要自己解决幻读的问题，这个其实还好，很多时候幻读问题其实是可以忽略的，或者可以用其他手段解决。</p><p>还有就是使用 RC 的时候，不能使用statement格式的 binlog，这种影响其实可以忽略不计了，因为MySQL是在5.1.5版本开始支持row的、在5.1.8版本中开始支持mixed，后面这两种可以代替 statement格式。 </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MySQL-默认隔离级别是RR，为什么阿里等大厂会改成RC？&quot;&gt;&lt;a href=&quot;#MySQL-默认隔离级别是RR，为什么阿里等大厂会改成RC？&quot; class=&quot;headerlink&quot; title=&quot;MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？&quot;&gt;&lt;/a&gt;MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.51cto.com/database&quot;&gt;数据库&lt;/a&gt;&lt;a href=&quot;https://www.51cto.com/mysql&quot;&gt;MySQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文介绍了一些 MySQL数据库的 RR 和 RC 两种事务隔离级别。他们主要在加锁机制、主从同步以及一致性读方面存在一些差异。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://s4.51cto.com/oss/202112/10/f60aed5572130a97f3bd19e4299af009.jpg&quot;&gt;&lt;img src=&quot;/media/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/f60aed5572130a97f3bd19e4299af009.jpg&quot; alt=&quot;img&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 我之前写过一篇文章《为什么MySQL选择REPEATABLE READ作为默认隔离级别？》介绍过MySQL 的默认隔离级别是 Repeatable Reads以及背后的原因。&lt;/p&gt;
&lt;p&gt;主要是因为MySQL在主从复制的过程是通过bin log 进行数据同步的，而MySQL早期只有statement这种bin log格式，这种格式下，bin log记录的是SQL语句的原文。&lt;/p&gt;
&lt;p&gt;当出现事务乱序的时候，就会导致备库在 SQL 回放之后，结果和主库内容不一致。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，MySQL默认采用了Repetable Read这种隔离级别，因为在 RR 中，会在更新数据的时候增加记录锁的同时增加间隙锁。可以避免这种情况的发生。&lt;/p&gt;
&lt;p&gt;关于MySQL的加锁方式及加锁原则，可以参考我写的另外一篇《求你了，别再说数据库锁的只是索引了！》，这里就不再赘述了。&lt;/p&gt;
&lt;p&gt;在我知道MySQL 默认隔离级别是RR后，很长一段时间都以为应该不会有人去修改这个默认配置。&lt;/p&gt;
&lt;p&gt;但是直到有一天，我们线上发生了一次死锁的问题，我在排查的过程中，才发现我们的数据库用的隔离级别没有使用默认的 RR，而是修改成了Read Committed 。（关于那次死锁排查过程，可以参考：一次数据库的死锁问题排查过程）&lt;/p&gt;
&lt;p&gt;大家可以通过这个命令查看数据库当前的隔离级别： &lt;/p&gt;
&lt;p&gt;复制&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select @@tx_isolation; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;那么，这里不禁就有疑问了，为啥阿里要把这个数据库隔离级别修改成 RC 呢，背后有什么思考吗？&lt;/p&gt;</summary>
    
    
    
    
    <category term="mysql" scheme="http://localhost:4000/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql 锁</title>
    <link href="http://localhost:4000/2023/04/01/mysql/mysql%20%E9%94%81/"/>
    <id>http://localhost:4000/2023/04/01/mysql/mysql%20%E9%94%81/</id>
    <published>2023-04-01T09:21:36.501Z</published>
    <updated>2023-04-16T13:05:40.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h1 id="1-什么是锁"><a href="#1-什么是锁" class="headerlink" title="1. 什么是锁"></a>1. 什么是锁</h1><p>​锁是数据库系统区别于文件系统的一个关键特性。<strong>锁机制用于管理对共享资源的并发访问。</strong>InnoDB存储引擎会在行级别上对表数据上锁，这固然不错。不过InnoDB存诸引擎也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如，操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保正一致性，必须有锁的介人。<strong>数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。</strong></p><span id="more"></span><h1 id="2-MySQL的锁分类"><a href="#2-MySQL的锁分类" class="headerlink" title="2. MySQL的锁分类"></a>2. MySQL的锁分类</h1><blockquote><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。</p></blockquote><p>MySQL大致可归纳为以下3种锁：</p><ul><li><strong>行级锁</strong>：<strong>共享锁（S Lock）、排他锁（X Lock）</strong><ul><li>开销大，加锁慢；</li><li>会出现死锁；</li><li>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li></ul></li><li><strong>表级锁</strong>：<strong>意向共享锁（IS Lock）、意向排他锁（IX Lock）</strong><ul><li>开销小，加锁快；</li><li>不会出现死锁；</li><li>锁定粒度大，发生锁冲突的概率最高，并发度最低。</li></ul></li><li>页面锁：<ul><li>开销和加锁时间界于表锁和行锁之间；</li><li>会出现死锁；</li><li>锁定粒度界于表锁和行锁之间，并发度一般</li></ul></li></ul><h2 id="表锁-VS-行锁"><a href="#表锁-VS-行锁" class="headerlink" title="表锁 VS 行锁"></a>表锁 VS 行锁</h2><blockquote><p>表锁和行锁的概念很容易理解<strong>一个是锁定整张表****一个是锁定一行记录</strong>，那么两者有什么区别呢。</p></blockquote><p><strong>锁的粒度</strong>：表锁 &gt; 行锁 – 这是因为表锁会锁定更多的记录以及资源因此粒度比较大</p><p><strong>加锁效率</strong>：表锁 &gt; 行锁 – 这是因为表锁直接锁定了整个表资源而不需要向行锁一样一行行锁</p><p><strong>冲突概论</strong>：表锁 &gt; 行锁 – 锁整张表数据所有写的操作都需要阻塞因此冲突更多</p><p><strong>并发性能</strong>：表锁 &lt; 行锁 – 行锁的冲突概率小自然并发高</p><h2 id="2-1-行级锁"><a href="#2-1-行级锁" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h2><p><strong>InnoDB存储引擎实现了如下两种标准的行级锁</strong></p><table><thead><tr><th>锁之间的兼容性</th><th>读锁S</th><th>写锁X</th></tr></thead><tbody><tr><td>共享锁（读锁、S Lock）</td><td><strong>兼容</strong></td><td>不兼容</td></tr><tr><td>排他锁（写锁、X Lock）</td><td>不兼容</td><td>不兼容</td></tr></tbody></table><blockquote><ul><li>可以发现<strong>X锁与任何的锁都不兼容</strong>，而<strong>S锁仅和S锁兼容</strong>。</li><li>需要特别注意的是，S和X锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。</li></ul></blockquote><h3 id="共享锁——S-Lock"><a href="#共享锁——S-Lock" class="headerlink" title="共享锁——S Lock"></a>共享锁——S Lock</h3><blockquote><p>允许事务<strong>读一行</strong>数据</p></blockquote><h3 id="排他锁——X-Lock"><a href="#排他锁——X-Lock" class="headerlink" title="排他锁——X Lock"></a>排他锁——X Lock</h3><blockquote><p>允许事务<strong>删除或者更新一行</strong>数据</p></blockquote><h2 id="2-2-表级锁"><a href="#2-2-表级锁" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h2><p>​InnoDB存储引擎支持多粒度（(granular〉锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。<strong>为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式</strong>，称之为**意向锁(Intention Lock)**。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度(fine granularity)上进行加锁，如下图所示：<img src="/.%5Cmedia%5C7.jpg" alt="image-20220601105306954"></p><ul><li>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是<strong>对最细粒度的对象进行上锁</strong></li><li>那么首先需要对粗粒度的对象上锁，如果需要对页上的记录r进行上X锁，那么分别需要对<strong>数据库A、表、页</strong>上，最后对<strong>记录r</strong>上。若<code>意向锁IX``X锁</code></li></ul><p><strong>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫意外的任何请求</strong></p><table><thead><tr><th>锁之间的兼容性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>IS</td><td></td><td>兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IX</td><td></td><td>兼容</td><td></td><td>兼容</td></tr><tr><td>S</td><td></td><td></td><td>兼容</td><td>兼容</td></tr><tr><td>X</td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；</li><li>反之，<strong>如果两者两者不兼容，该事务就要等待锁释放。</strong></li></ul><h3 id="意向共享锁——IS-Lock"><a href="#意向共享锁——IS-Lock" class="headerlink" title="意向共享锁——IS Lock"></a>意向共享锁——IS Lock</h3><blockquote><p>事务想要获得<strong>一张表中的某几行</strong>的共享锁</p></blockquote><h3 id="意向排他锁——IX-Lock"><a href="#意向排他锁——IX-Lock" class="headerlink" title="意向排他锁——IX Lock"></a>意向排他锁——IX Lock</h3><blockquote><p>事务想要获得<strong>一张表中某几行</strong>的排他锁</p></blockquote><h2 id="多版本并发控制——MVCC"><a href="#多版本并发控制——MVCC" class="headerlink" title="多版本并发控制——MVCC"></a>多版本并发控制——MVCC</h2><p>快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为<strong>多版本并发控制(Multi VersionConcurrency Control，MVCC)。</strong></p><p>文章可以看：<a href="https://link.juejin.cn/?target=https://blog.csdn.net/huyuyang6688/article/details/123028254">深入理解MySQL的MVCC原理</a></p><h2 id="2-3-一致性非锁定读"><a href="#2-3-一致性非锁定读" class="headerlink" title="2.3 一致性非锁定读"></a>2.3 一致性非锁定读</h2><p>​一致性的非锁定读(consistent nonlocking read）是指InnoDB存储引擎通过的方式来读取当前执行时间数据库中行的数据。<code>行多版本控制（multi versioning）</code></p><blockquote><p>​如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据。<strong>这样就不需要等待行上的X锁释放了，极大的提高了数据库的并发性</strong></p><p><img src="/.%5Cmedia%5C8.jpg" alt="image-20220601110046377"></p><p><strong>说明：快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</strong></p></blockquote><p><strong>注意：</strong></p><p>​在事务隔离级别和 (InnoDB存储引擎的默认事务隔离级别)下，InnoDB存储引擎使用非锁定的一致性读。然而，对于快照数据的<strong>定义却不相同</strong>。在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在<strong>REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</strong>来看下面的一个例：<code>READ COMMITTED``REPEATABLE READ</code></p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>一样是我们的tb_user表，可以看这篇<a href="https://juejin.cn/post/7103493390318190606#heading-13">Mysql高级——索引篇</a>的环境准备获取</p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td></td><td>begin;</td></tr><tr><td>2</td><td></td><td>select * from tb_user where id &#x3D; 1;（首次读-值1）</td></tr><tr><td>3</td><td>begin;</td><td></td></tr><tr><td>4</td><td>update tb_user set age&#x3D;50 where id &#x3D; 1;</td><td></td></tr><tr><td>5</td><td></td><td>select * from tb_user where id &#x3D; 1;（值1）</td></tr><tr><td>6</td><td>commit;</td><td></td></tr><tr><td>7</td><td></td><td>select * from tb_user where id &#x3D; 1;（值2）</td></tr><tr><td>8</td><td></td><td>commit;</td></tr></tbody></table><h4 id="测试——REPEATABLE-READ-可重复读事务隔离级别"><a href="#测试——REPEATABLE-READ-可重复读事务隔离级别" class="headerlink" title="测试——REPEATABLE READ(可重复读事务隔离级别)"></a>测试——REPEATABLE READ(可重复读事务隔离级别)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 由于mysql数据库的更新，在旧版本中tx_isolation是作为transaction_isolation的别名被应用的，新版本已经弃用了，所以输入会显示未知变量.</span><br><span class="line">-- 新版mysql查看事务隔离级别</span><br><span class="line">SELECT @@transaction_isolation</span><br><span class="line"></span><br><span class="line">-- 旧版mysql</span><br><span class="line">SELECT @@tx_isolation;</span><br><span class="line"></span><br><span class="line">-- 设置事务隔离级别</span><br><span class="line">set session transaction isolation level  REPEATABLE READ</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578cc416f7d042c4a1c966c44cd3acc4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601140935100"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/036a2a80b86e446b87464aec05a85247~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134237107"></p><blockquote><p>– 开启事务B，进行首次读取</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0690b0c4ab1747cf98b953844258308b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134457169"></p><blockquote><p>– 开启事务A，对该条数据进行修改，<strong>将age修改为50</strong></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf28e92e497a4a559e36eabc1b4a9ebe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134556694"></p><blockquote><p>– 此时，再回到事务B再次对该行数据进行读取，发现该行数据<strong>还是我们事务B首次读取到的数据</strong>，<strong>并没有因为事务A的更新操作而受到影响</strong></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa39b8c3db8c4952b24ffc7c762e015c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134724021"></p><blockquote><p>– 此时对<strong>事务A进行提交操作</strong>，再次对该行数据进行读取操作，还是一样的结果（如果此时是READ COMMITTED事务隔离级别，也是一样的结果，因为事务A提交事务后，只生成了一份数据快照，该<strong>快照的age值也是23</strong>，则此时事务B读取到的是最新的一份快照数据，也是一样的）</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1a52445dd464da9b9cc3f28711ab995~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134843841"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1d07ac80fbb4d39b3ef47535e5ab76d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601135000970"></p><blockquote><p>– <strong>提交事务B</strong>后再次进行读取操作，可以看到此时读到的age值已经改变了</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/107c6b302cb343da83d9d6c0adc0a8b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601135211255"></p><h4 id="测试——READ-COMMITTED"><a href="#测试——READ-COMMITTED" class="headerlink" title="测试——READ COMMITTED"></a>测试——READ COMMITTED</h4><blockquote><p>修改事务的隔离级别为——<code>read committed</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 修改事务的隔离级别为——read committed</span><br><span class="line">set session transaction isolation level read committed</span><br><span class="line">select @@transaction_isolation</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b71a19e8ddd4289938bf951f5810426~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601141324664"></p><blockquote><p>注意：此时对于id&#x3D;1这一行的数据，已经有一个数据快照了，是age&#x3D;23的数据快照</p></blockquote><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td></td><td>begin;</td></tr><tr><td>2</td><td></td><td>select * from tb_user where id &#x3D; 1;</td></tr><tr><td>3</td><td>begin;</td><td></td></tr><tr><td>4</td><td>update tb_user set age&#x3D;50 where id &#x3D; 1;</td><td></td></tr><tr><td>5</td><td></td><td>select * from tb_user where id &#x3D; 1;</td></tr><tr><td>6</td><td>commit;</td><td></td></tr><tr><td>7</td><td></td><td>select * from tb_user where id &#x3D; 1;</td></tr><tr><td>8</td><td></td><td>commit;</td></tr></tbody></table><blockquote><p>– 开启事务B，进行首次读取</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f28173bee0e148f69ba986c7979d3656~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601151924209"></p><blockquote><p>– <strong>开启事务A，进行一次更新操作，修改age为49</strong></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f293169dc2314c2a8f4e4d84f7821f21~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152046666"></p><blockquote><p>– 在<strong>事务B</strong>中读取一次数据，<strong>依旧是50</strong></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88b3cbb9170b4234acbea07b927b78a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152116193"></p><blockquote><p>– <strong>在事务A中提交事务后</strong>，此时数据快照多了一份是49的</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2917f27105bf46b1932c1926e972b886~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152316735"></p><blockquote><p>– 再次去到事务B中读取id&#x3D;1的该行数据，会发现读取的是最新的数据快照，<strong>此时事务B还没进行事务的提交，但是事务A进行事务的提交了</strong></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e416ea0ea5bf4ff89adf608fb225cd14~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152407088"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><blockquote><p><strong>可见</strong></p><ul><li>在<strong>REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</strong></li><li>在<strong>READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。</strong></li></ul></blockquote><h2 id="2-4-一致性锁定读"><a href="#2-4-一致性锁定读" class="headerlink" title="2.4 一致性锁定读"></a>2.4 一致性锁定读</h2><p>​在默认配置下，即事务的隔离级别为REPEATABLE READ模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。但是在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于SELECT的只读操作。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读操作：</p><ul><li><strong>共享锁（Ｓ）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE</strong></li><li><strong>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE</strong></li></ul><blockquote><ol><li>意向锁是InnoDB自动加的，不需用户干预。</li><li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及的数据集加排他锁Ｘ；</li><li>对于普通SELECT语句，InnoDB不会加任何锁；</li><li>事务可以通过上面的语句显示给记录集加共享锁或排他锁X。</li></ol><p>​    用SELECT .. IN SHARE MODE获得共享锁，主要用在需要数据依存关系时确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。</p><p>​    但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT … FOR UPDATE方式获取排他锁。</p></blockquote><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 事务隔离级别设置为默认的</span><br><span class="line">set session transaction isolation level  REPEATABLE READ</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="for-update测试"><a href="#for-update测试" class="headerlink" title="for update测试"></a>for update测试</h4><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td></td><td>begin;</td></tr><tr><td>2</td><td></td><td>select * from tb_user where id&#x3D;1 for update;</td></tr><tr><td>3</td><td>begin;</td><td></td></tr><tr><td>4</td><td>update tb_user set age&#x3D;40 where id &#x3D; 2;（被阻塞）</td><td></td></tr><tr><td>5</td><td></td><td>commit；（释放X锁）</td></tr><tr><td>6</td><td>update tb_user set age&#x3D;40 where id &#x3D; 2;（成功）</td><td></td></tr><tr><td>7</td><td>commit；</td><td></td></tr></tbody></table><blockquote><p>– 事务A开启事务后使用一致性的锁定读操作给id&#x3D;1的行上了X锁</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tb_user where id = 1 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/886e1cc7e5134e5980dbbe42b6f7d47e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601165621942"></p><blockquote><p>– 事务B此时开启事务，对id&#x3D;1的行进行更新操作，<strong>出现被阻塞情况</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update tb_user set age=40 where id = 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcf9cd9b682d42cdb72f3b273fa847e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601170306504"></p><blockquote><p>– 同样的使用for update操作对表上X锁（锁不兼容），<strong>一样会被阻塞</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_user where id = 1 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed32d91abb1144a39984572814eeede7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601170251538"></p><h4 id="lock-in-share-mode测试"><a href="#lock-in-share-mode测试" class="headerlink" title="lock in share mode测试"></a>lock in share mode测试</h4><blockquote><p>– <strong>事务A</strong>开启事务后使用一致性的锁定读操作给id&#x3D;1的行上了S锁</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin ;</span><br><span class="line">select * from tb_user where id=1 lock in share mode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02afdfff8c5b4c41b1f59c4f38e48acc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601170949968"></p><blockquote><p>– <strong>事务B</strong>开启事务后也请求对id&#x3D;1的行数据上S锁，因为S锁之间互相兼容，并<strong>没有出现阻塞</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tb_user where id=1 lock in share mode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88713e1a1516426d8d4f5b368aba2431~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601171112299"></p><blockquote><p>– 事务B也请求对id&#x3D;1的行数据上X锁，会<strong>出现阻塞的情况</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_user where id = 1 for update</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd8d49ae2ffa475baece156a2e4cce0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601171250234"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote><p><code>SELECT…FOR UPDATE</code>对读取的行记录<strong>加一个X锁</strong>，其他事务不能对已锁定的行加上任何锁。</p><p><code>SELECT…LOCK IN SHARE MODE</code>对读取的行记录<strong>加一个S锁</strong>，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。</p></blockquote><h2 id="非锁定读与锁定读注意点"><a href="#非锁定读与锁定读注意点" class="headerlink" title="非锁定读与锁定读注意点"></a>非锁定读与锁定读注意点</h2><blockquote><ol><li><strong>对于一致性非锁定读</strong>，即使读取的行已被执行了，也是可以进行读取的，这和之前讨论的情况一样。<code>SELECT…FOR UPDATE</code></li><li>此外，，必须在一个事务中，当事务提交了，锁也就释放了。<strong>因此在使用上述两句SELECT锁定语句时，务必加上BEGIN，START TRANSACTION或SETAUTOCOMMIT&#x3D;0。</strong><code>SELBCT…FOR UPDATE``SELECT…LOCK IN SHARE MODE</code></li></ol></blockquote><h2 id="2-5-自增长与锁——AUTO-INC-Locking"><a href="#2-5-自增长与锁——AUTO-INC-Locking" class="headerlink" title="2.5 自增长与锁——AUTO-INC Locking"></a>2.5 自增长与锁——AUTO-INC Locking</h2><p>自增长在数据库中是非常常见的一种属性，也是很多DBA或开发人员首选的主键方式。在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（ auto-increment counter)。当对含有自增长的计数器的表进行插人操作时，这个计数器会被初始化，<strong>插人操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式称做AUTO-INC Locking。**这种锁其实是**采用一种特殊的表锁机制**，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后</strong>立即释放**。</p><p><strong>注意点</strong>：</p><ul><li>在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第个列。</li><li>如果不是第一个列，则 MySQL数据库会抛出异常，而MyISAM存储引擎没有这个问题。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/222108cc4c214b7cade6f2a04aaa0369~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601201848034"></p><p><strong>存在的问题</strong>：</p><p>虽然AUTO-INC Locking 从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。</p><ol><li>首先，对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成)。</li><li>其次，对于 INSERT…SELECT 的大数据量的插人会影响插入的性能，因为另一个事务中的插入会被阻塞。</li></ol><h2 id="2-6-外键和锁"><a href="#2-6-外键和锁" class="headerlink" title="2.6 外键和锁"></a>2.6 外键和锁</h2><p>​    外键主要用于引用完整性的约束检查。<strong>在InnoDB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其加一个索引，因为这样可以避免表锁</strong>（这比Oracle数据库做得好，Oracle数据库不会自动添加索引，用户必须自己手动添加，这也导致了Oracle数据库中可能产生死锁。）</p><p><strong>注意点</strong>：</p><p>对于外键值的插入或更新，首先需要查询父表中的记录，即SELECT父表。但是<strong>对于父表的SELECT操作</strong>，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，<strong>因此这时使用的是SELECT…LOCK IN SHARE MODE方式</strong>，即<strong>主动对父表加一个S锁。</strong></p><p><strong>解释</strong>：</p><blockquote><p>设想如果这时父表上已经这样加X锁，子表上的操作会被阻塞，如下图：</p><p><strong>parent是父表，child是子表</strong></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7278f865339942888c2dafb5bce8f5e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601202657505"></p><blockquote><p>设想，如果访问父表时，使用的是一致性的非锁定读，这时的Session B会读到父表有id&#x3D;3的记录，可以进行插入操作。但是如果会话A对事务提交了，则父表中就不存在id为3的记录。数据在父、子表就会存在不一致的情况。若这时用户查询，会看到如下结果:<code>INNODB_LOCKS表</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ed84fb74ba64fe7b468a398c92e39f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601203302777"></p><p>参数说明：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25b7e071621e42d493e91291ba505ca2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601203339844"></p></blockquote><h1 id="3-锁的算法"><a href="#3-锁的算法" class="headerlink" title="3. 锁的算法"></a>3. 锁的算法</h1><h2 id="3-1-行锁的三种算法"><a href="#3-1-行锁的三种算法" class="headerlink" title="3.1 行锁的三种算法"></a>3.1 行锁的三种算法</h2><p>InnoDB存储引擎有三种行锁的算法：</p><ol><li><strong>Record Lock</strong>：单个行记录上的锁</li><li><strong>Gap Lock</strong>：间隙锁，锁定一个范围，但不包含记录本身</li><li><strong>Next-Key Lock</strong>：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li></ol><p><strong>锁类型锁定的大致范围：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8683dbabcf4b2ca98439e1459ace52~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><blockquote><p>Record Lock：10</p><p>Gap Lock：（-∞，10），（10，20），（20，+∞）</p><p>Next-Key Lock：（-∞，10]，（10，20]，（20，+∞）</p></blockquote><h3 id="1️⃣Record-Lock"><a href="#1️⃣Record-Lock" class="headerlink" title="1️⃣Record Lock"></a>1️⃣Record Lock</h3><p><strong>Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</strong></p><blockquote><p>行锁是加在索引上的，<strong>如果当你的查询语句不走索引的话，那么它就会升级到表锁</strong>，最终造成效率低下，所以在写SQL语句时需要特别注意。</p></blockquote><h3 id="2️⃣Gap-Lock"><a href="#2️⃣Gap-Lock" class="headerlink" title="2️⃣Gap Lock"></a>2️⃣Gap Lock</h3><p>当我们使用范围条件而不是相等条件去检索，并请求锁时，InnoDB就会给符合条件的记录的索引项加上锁；而对于键值在条件范围内但并不存在（参考上面所说的空闲块）的记录，就叫做间隙，InnoDB在此时也会对间隙加锁</p><blockquote><ul><li>间隙锁只有一个目的就是在RR、SERIALIZABLE隔离级别下为了防止其他事务插入数据。</li><li>假如一个索引有2、4、5、9、12 五个值，那该索引可能被间隙锁锁的范围为(-∞ , 2),(2 , 4),(4 , 5),(5 , 9),(9 , 12),(12 , +∞)。</li></ul></blockquote><h3 id="3️⃣Next-Key-Lock"><a href="#3️⃣Next-Key-Lock" class="headerlink" title="3️⃣Next-Key Lock"></a>3️⃣Next-Key Lock</h3><p><strong>Next-Key Lock是结合了Gap Lock和 Record Lock的一种锁定算法，在Next-KeyLock算法下，InnoDB对于行的查询都是采用这种锁定算法。</strong>其目的就是为了解决Phantom Problem（幻象问题）。</p><blockquote><ul><li>对【某一个行记录】和【这条记录与它前一条记录之间的范围&#x2F;间隙】都上锁，这里我们称它为邻键锁。</li><li>假如一个索引有2、4、5、9、12 五个值，那该索引可能被邻键锁锁的范围为(-∞ , 2],(2 , 4],(4 , 5],(5 , 9],(9 , 12],(12 , +∞)。在InnoDB中，加锁的基本单位是Next-Key Lock，只不过在某些特殊情况下会退化为 Record Lock 或者 Gap Lock。</li></ul></blockquote><blockquote><p><strong>特别说明：</strong></p><p>然而，<strong>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。</strong>（可在下面测试代码中看到）</p></blockquote><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建a作为主键（即唯一索引），b为辅助索引</span><br><span class="line">CREATE TABLE lock_test ( a INT,b INT,PRIMARY KEY(a),KEY(b));</span><br><span class="line">INSERT INTO lock_test SELECT 1,1;</span><br><span class="line">INSERT INTO lock_test SELECT 3,1;</span><br><span class="line">INSERT INTO lock_test SELECT 5,3;</span><br><span class="line">INSERT INTO lock_test SELECT 7,6;</span><br><span class="line">INSERT INTO lock_test SELECT 10,8;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63179baa8b8540d6994e222042b787e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601223051155"></p><h3 id="唯一索引的锁定示例"><a href="#唯一索引的锁定示例" class="headerlink" title="唯一索引的锁定示例"></a>唯一索引的锁定示例</h3><blockquote><p><strong>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。</strong></p></blockquote><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>begin；</td><td></td></tr><tr><td>2</td><td>select * from lock_test where a&#x3D;5 for update；</td><td></td></tr><tr><td>3</td><td></td><td>begin；</td></tr><tr><td>4</td><td></td><td><strong>insert into lock_test select 4,5;</strong></td></tr><tr><td>5</td><td></td><td>commit； #成功，不需要等待</td></tr><tr><td>6</td><td>commit；</td><td></td></tr></tbody></table><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d61e6c7c08841b88ec19f011f811d7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601223019835"></p><blockquote><p>– 事务A开启事务后，先给记录a&#x3D;5上一个X锁，但是因为此时a索引是主键即唯一索引，Next-Key Lock会降级为Record Lock，<strong>仅仅锁住了a&#x3D;5这一行的记录</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A先给记录a=5上一个X锁，但是因为此时a索引是主键即唯一索引，Next-Key Lock会降级为Record Lock</span><br><span class="line">begin;</span><br><span class="line">select * from lock_test where a=5 for update</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>– 事务B插入一条a&#x3D;4，b&#x3D;5的记录，<strong>因为事务A的X锁仅仅加在了a&#x3D;5这一行，所以事务B在执行插入操作时候可以正常获取X锁，并不会被阻塞</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 事务B插入一条a=4，b=5的记录，因为事务A的X锁仅仅加在了a=5这一行，所以事务B在执行插入操作时候可以正常获取X锁</span><br><span class="line">begin;</span><br><span class="line">insert into lock_test select 4,5;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/879b058e828c48e1b5be3e8b77d824df~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601223526341"></p><h3 id="辅助索引的锁定示例"><a href="#辅助索引的锁定示例" class="headerlink" title="辅助索引的锁定示例"></a>辅助索引的锁定示例</h3><blockquote><p><strong>对于辅助索引，其加上的是Next-Key Lock，锁定的是一个范围值（即Record Lock和Gap Lock的混合锁）</strong></p></blockquote><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>begin；</td><td></td></tr><tr><td>2</td><td>select * from lock_test where a&#x3D;5 for update；</td><td></td></tr><tr><td>3</td><td></td><td>begin；</td></tr><tr><td>4</td><td></td><td><strong>select * from lock_test where b&#x3D;3 for update</strong> #阻塞</td></tr></tbody></table><blockquote><p>在上个操作的事务B中进行一致性锁定读操作，请求对辅助索引b&#x3D;3加上一个X锁，<strong>会有阻塞的出现</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 在上个操作的事务B中进行一致性锁定读操作，请求对辅助索引b=3加上一个X锁</span><br><span class="line">select * from lock_test where b=3 for update</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edb40207d579499c87f603da34fe0698~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601224329511"></p><blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ee5e80e1b384568b324fe7a12e26bf5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601224653635"></p><p><strong>说明：</strong></p><p>这是因为，针对辅助索引，其上锁上的是Next-Key Lock，这个邻键锁会对辅助索引的上一个键值和下一个键值上一个范围锁，示例中<strong>加X锁的辅助索引是b&#x3D;3，其上一个键值是1，后一个键值是6</strong>，故Next-Key Lock锁定的范围是 <strong>(1, 3],(3,6)<strong>，</strong>这区间内的都被加上了X锁，其他事务无法获取，若获取会被阻塞</strong></p><p><strong>所以，此时，因为<code>select \* from lock_test where b=3 for update</code>无法获取a&#x3D;5这一行记录的X锁而导致了事务B发生了阻塞</strong></p></blockquote><p><strong>此时重新进行操作</strong></p><table><thead><tr><th>时间</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td></td></tr><tr><td>2</td><td>select * from lock_test where b&#x3D;3 for update</td><td></td></tr><tr><td>3</td><td></td><td>begin;</td></tr><tr><td>4</td><td></td><td>select * from lock_test where a&#x3D;5 lock in share mode; #阻塞</td></tr><tr><td>5</td><td></td><td>insert into lock_test select 4,2；#阻塞</td></tr><tr><td>6</td><td></td><td>insert into lock_test select 6,5;  #阻塞</td></tr><tr><td>7</td><td></td><td>insert into lock_test select 8,6;  #正常执行</td></tr></tbody></table><blockquote><p>– 事务A开启事务，对b&#x3D;3这条记录进行一致性锁读（X锁），<strong>此时被加锁的范围：(1, 3],(3,6)</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0ea27e922dc497db8b5ce755df39dac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601232131174"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A开启事务，对b=3这条记录上锁</span><br><span class="line">begin;</span><br><span class="line">select * from lock_test where b=3 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d0fe386b01f4e55818c4e85f992ace5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601230805400"></p><blockquote><p>– 开启事务B，对a&#x3D;5的记录上X锁，会出现阻塞</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务B，对a=5的记录上X锁，会出现阻塞</span><br><span class="line">begin;</span><br><span class="line">select * from lock_test where a=5 lock in share mode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0201fcd3da1d49439cd723a1bfcbd0ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601231731724"></p><blockquote><p>– 事务B插入一条a&#x3D;4，b&#x3D;2的数据（X锁）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into lock_test select 4,2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed4bc5359f014b2594a376cf332d51d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601233714262"></p><blockquote><p>– 事务B插入一条a&#x3D;6，b&#x3D;5的数据（X锁），会出现阻塞</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into lock_test select 6,5;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82bf1d4e1a0243f58ac89ae342ebef24~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601234025094"></p><blockquote><p>解释：</p><p><strong>第一个SQL语句不能执行</strong>，因为在会话A中执行的SQL语句已经对聚集索引中列a &#x3D;5的值加上X锁，因此执行会被阻塞。</p><p>第二个SQL语句，主键插入4，没有问题，但是插人的辅助索引值2在锁定的范围(1，3)中，因此执行同样会被阻塞。</p><p>第三个SQL语句，插入的主键6没有被锁定，5也不在范围(1，3)之间。但插入的值5在另一个锁定的范围(3，6)中，故同样需要等待。</p></blockquote><p>而<strong>下面的SQL语句，不会被阻塞</strong>，可以立即执行:</p><blockquote><p>– 事务B插入一条a&#x3D;8，b&#x3D;6的数据（X锁），不会出现阻塞</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 下面sql</span><br><span class="line">insert into lock_test select 8,6;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edecf561fe394c6f857dcdd83780f30b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220602005321000"></p><h2 id="3-2-深入分析MySQL行锁加锁规则"><a href="#3-2-深入分析MySQL行锁加锁规则" class="headerlink" title="3.2 深入分析MySQL行锁加锁规则"></a>3.2 深入分析MySQL行锁加锁规则</h2><p>具体详细的可以看——》<a href="https://link.juejin.cn/?target=https://huyuyang.blog.csdn.net/article/details/123508245?spm=1001.2014.3001.5502">深入分析MySQL行锁加锁规则</a></p><h2 id="3-3-幻象问题（幻读）"><a href="#3-3-幻象问题（幻读）" class="headerlink" title="3.3 幻象问题（幻读）"></a>3.3 幻象问题（幻读）</h2><blockquote><p>Phantom Problem是指在同一事务下，<strong>连续执行两次同样的SQL语句可能导致不同的结果</strong>，第二次的SQL语句可能会返回之前不存在的行。</p></blockquote><p>​**在默认的事务隔离级别下，即REPEATABLE READ 下，InnoDB存储引擎采用Next-Key Locking机制来避免Phantom Problem（幻像问题)**。（这点可能不同于与其他的数据库，如Oracle数据库，因为其可能需要在SERIALIZABLE的事务隔离级别下才能解决Phantom Problem。）</p><blockquote><p>此外，用户可以通过InnoDB存储引擎的Next-Key Locking机制在应用层面实现唯一性的检查。</p></blockquote><p>​如果用户通过索引查询一个值，并对该行加上一个SLock，那么即使查询的值不在，其锁定的也是一个范围，因此若没有返回任何行，那么新插人的值一定是唯一的。也许有读者会有疑问，如果在进行第一步SELECT…LOCK IN SHARE MODE操作时，有多个事务并发操作，那么这种唯一性检查机制是否存在问题。<strong>其实并不会，因为这时会导致死锁，只有一个事务的插人操作会成功，而其余的事务会抛出死锁的错误</strong>，如表6-14所示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d9f8301d124eb580f99113a870abca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220602010206860"></p><h1 id="4-锁问题"><a href="#4-锁问题" class="headerlink" title="4. 锁问题"></a>4. 锁问题</h1><h2 id="4-1-脏读"><a href="#4-1-脏读" class="headerlink" title="4.1 脏读"></a>4.1 脏读</h2><blockquote><p>脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186bf15a970b47b1aace2e5dc5138836~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601234330312"></p><p>事务的隔离级别进行了更换，由默认的 ——&gt;。<code>REPEATABLE READ``READ UNCOMMITTED</code></p><ul><li>可以看到，在会话A中，在事务并没有提交的前提下，会话B中的两次SELECT操作取得了不同的结果。</li><li>并且2这条记录是在会话A中并未提交的数据，即产生了脏读，违反了事务的隔离性。</li></ul><h2 id="4-2-不可重复读"><a href="#4-2-不可重复读" class="headerlink" title="4.2 不可重复读"></a>4.2 不可重复读</h2><blockquote><p>不可重复读是指在一个事务内多次读取同一数据集合。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea6a46d9c0144e888221781aa647d07~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601234514701"></p><ul><li>在事务开始前，会话A和会话B的事务隔离级别都调整为。<code>READ COMMITTED</code></li><li>在<strong>会话A</strong>中开始一个事务，第一次读取到的记录是1。</li><li>在另一个<strong>会话B</strong>中开始了另一个事务，插入一条为2的记录。</li><li>在没有提交之前，对<strong>会话A</strong>中的事务进行再次读取时，读到的记录还是1，没有发生脏读的现象。</li><li><strong>但会话B中的事务提交后</strong>，在对<strong>会话A</strong>中的事务进行读取时，这时<strong>读到是1和2两条记录</strong>。</li></ul><h2 id="4-3-丢失更新"><a href="#4-3-丢失更新" class="headerlink" title="4.3 丢失更新"></a>4.3 丢失更新</h2><blockquote><p>丢失更新是另一个锁导致的问题，简单来说其就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。</p></blockquote><h1 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5. 死锁"></a>5. 死锁</h1><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><blockquote><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。</p></blockquote><h2 id="5-2-死锁的检测"><a href="#5-2-死锁的检测" class="headerlink" title="5.2 死锁的检测"></a>5.2 死锁的检测</h2><p>死锁的检查方法：</p><ol><li>超时机制——<strong>被动</strong>检测死锁</li><li>wait-for group(等待图)——主动检测死锁</li></ol><h3 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h3><p>​解决死锁问题最简单的一种方法是超时，<strong>即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。</strong>在 InnoDB存储引擎中，参数innodb_lock_wait_timeout用来设置超时的时间。</p><blockquote><p><strong>注意：</strong>超时机制虽然简单，但是其仅通过超时后对事务进行回滚的方式来处理，或者说其是根据FIFO的顺序选择回滚对象。但若超时的事务所占权重比较大，如事务操作更新了很多行，占用了较多的undo log，这时采用FIFO的方式，就显得不合适了，因为回滚这个事务的时间相对另一个事务所占用的时间可能会很多。</p></blockquote><h3 id="wait-for-group-等待图"><a href="#wait-for-group-等待图" class="headerlink" title="wait-for group(等待图)"></a>wait-for group(等待图)</h3><p>wait-for graph要求数据库保存以下两种信息：</p><ol><li>锁的信息链表</li><li>事务等待链表</li></ol><p><strong>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。</strong></p><ul><li>在 wait-for graph 中，事务为图中的节点。</li><li>事务T1指向T2边的定义为：<ul><li>事务T1等待事务T2所占用的资源</li><li>事务T1最终等待T2所占用的资源，也就是事务之间在等待相同的资源，而事务T1发生在事务T2的后面</li></ul></li></ul><p><strong>根据下图</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/500228d94f854938b19a52968eb70808~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601214238586"></p><p><strong>解释：</strong></p><ul><li>在Transaction Wait Lists中可以看到共有4个事务t1、t2、t3、t4，故在wait-forgraph中应有4个节点。</li><li>而事务t2对row1占用x锁，事务t1对row2占用s锁。</li><li>事务t1需要等待事务t2中row1的资源，因此在wait-for graph中有条边从节点t1指向节点t2。</li><li>事务t2需要等待事务t1、t4所占用的row2对象，故而存在节点t2到节点t1、t4的边。</li><li>同样，存在节点t3到节点t1、t2、t4的边，因此最终的wait-for graph，如图6-6所示。</li></ul><p><strong>产生的wait-for group(等待图)</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2df0b5dfec904dc4821fce32e01fbb6f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601214259726"></p><blockquote><p><strong>通过图6-6可以发现存在回路(t1，t2)，因此存在死锁。</strong></p><p>通过上述的介绍，可以发现wait-for graph是一种较为主动的死锁检测机制，<strong>在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务。</strong></p></blockquote><h2 id="5-3-死锁的示例"><a href="#5-3-死锁的示例" class="headerlink" title="5.3 死锁的示例"></a>5.3 死锁的示例</h2><p><strong>表结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t (</span><br><span class="line">a INT PRIMARY KEY</span><br><span class="line">)ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">INSERT INTO t VALUES (1), (2), (4), (5);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>经典的AB-BA死锁</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b424e5c1442413cba047b6cc631feda~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601214725244"></p><blockquote><p><strong>解释</strong>：</p><p>在上述操作中，会话B中的事务抛出了1213这个错误提示，即表示事务发生了死锁。</p><p>死锁的原因是<strong>会话A和B的资源在互相等待</strong>。大多数的死锁InnoDB存储引擎本身可以侦测到，不需要人为进行干预。</p><p>但是在上面的例子中，在<strong>会话B</strong>中的事务抛出死锁异常后，<strong>会话A</strong>中马上得到了记录为2的这个资源，这其实是因为会话B中的事务发生了回滚，否则会话A中的事务是不可能得到该资源的。</p><p><strong>因为InnoDB存储引擎并不会回滚大部分的错误异常，但是死锁除外。发现死锁后，InnoDB存储引擎会马上回滚一个事务，这点是需要注意的。因此如果在应用程序中捕获了1213这个错误，其实并不需要对其进行回滚。</strong></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfea99ffcf234e94816198857400dab0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601215650438"></p><blockquote><p>可以看到，<strong>会话A</strong>中已经对持有了X锁，但是<strong>会话A</strong>中插人时会导致死锁发生。<code>记录4``记录3</code></p><p>这个问题的产生是由于<strong>会话B</strong>中请求的S锁而发生等待，但之前请求的锁对于主键值记录1、2都已经成功，若在事件点5能插入记录，那么<strong>会话B</strong>在获得持有的S锁后，还需要向后获得的记录，这样就显得有点不合理。<code>记录4``记录4``记录3</code></p><p>因此InnoDB存储引擎在这里主动选择了死锁，而回滚的是undo log记录大的事务，这与AB-BA死锁的处理方式又有所不同。</p></blockquote><blockquote><p>资料来源——&gt;《MySQL技术内幕》</p><p><a href="https://link.juejin.cn/?target=https://huyuyang.blog.csdn.net/article/details/123508245?spm=1001.2014.3001.5502">深入分析MySQL行锁加锁规则</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h1&gt;&lt;h1 id=&quot;1-什么是锁&quot;&gt;&lt;a href=&quot;#1-什么是锁&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是锁&quot;&gt;&lt;/a&gt;1. 什么是锁&lt;/h1&gt;&lt;p&gt;​	锁是数据库系统区别于文件系统的一个关键特性。&lt;strong&gt;锁机制用于管理对共享资源的并发访问。&lt;/strong&gt;InnoDB存储引擎会在行级别上对表数据上锁，这固然不错。不过InnoDB存诸引擎也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如，操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保正一致性，必须有锁的介人。&lt;strong&gt;数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="mysql" scheme="http://localhost:4000/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的可重复读级别能解决幻读吗</title>
    <link href="http://localhost:4000/2023/04/01/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%20/"/>
    <id>http://localhost:4000/2023/04/01/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%20/</id>
    <published>2023-04-01T09:21:05.921Z</published>
    <updated>2023-04-16T13:05:26.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的可重复读级别能解决幻读吗"><a href="#MySQL的可重复读级别能解决幻读吗" class="headerlink" title="MySQL的可重复读级别能解决幻读吗"></a>MySQL的可重复读级别能解决幻读吗</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>之前在深入了解数据库理论的时候，了解到事务的不同隔离级别可能存在的问题。为了更好的理解所以在MySQL数据库中测试复现这些问题。关于脏读和不可重复读在相应的隔离级别下都很容易的复现了。但是对于幻读，我发现在可重复读的隔离级别下没有出现，当时想到难道是MySQL对幻读做了什么处理？</p><span id="more"></span><p>测试：</p><p>创建一张测试用的表dept：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">12</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept(name) <span class="keyword">values</span>(&quot;后勤部&quot;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><table><thead><tr><th>事务 1</th><th>事务 2</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td>select * from dept</td><td></td></tr><tr><td>-</td><td>insert into dept(name) values(“研发部”)</td></tr><tr><td>-</td><td>commit</td></tr><tr><td>select * from dept</td><td></td></tr><tr><td>commit</td><td></td></tr></tbody></table><p>根据上面的流程执行，预期来说应该是事务1的第一条select查询出一条数据，第二个select查询出两条数据(包含事务2提交的数据)。</p><p>但是在实际测试中发现第二条select实际上也只查询处理一条数据。这是但是根据数据库理论的可重复读的实现(排他锁和共享锁)这是不应该的情况。</p><p>在了解实际原因前我们先复习下事务的相关理论。</p><h3 id="数据库原理理论"><a href="#数据库原理理论" class="headerlink" title="数据库原理理论"></a>数据库原理理论</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。在关系数据库中，一个事务可以是一组SQL语句或整个程序。</p><h4 id="为什么要有事务"><a href="#为什么要有事务" class="headerlink" title="为什么要有事务"></a>为什么要有事务</h4><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p><ol><li>为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库在异常状态下仍能保持一致性的方法。</li><li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，保证彼此的操作互相干扰。</li></ol><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p>事务具有4个特性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。</p><ul><li>原子性（atomicity）： 一个事务应该是一个不可分割的工作单位，事务中包括的操作要么都成功，要么都不成功。</li><li>一致性（consistency）： 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li><li>隔离性（isolation）： 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据在事务未提交前对并发的其他事务是隔离的，并发执行的各个事务之间不能互相影响。</li><li>持久性（durability）： 一个事务一旦成功提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li></ul><p>事务之间的几个特性并不是一组同等的概念：</p><p>如果在任何时刻都只有一个事务，那么其天然是具有隔离性的，这时只要保证原子性就能具有一致性。</p><p>如果存在并发的情况下，就需要保证原子性和隔离性才能保证一致性。</p><h4 id="数据库并发事务中存在的问题"><a href="#数据库并发事务中存在的问题" class="headerlink" title="数据库并发事务中存在的问题"></a>数据库并发事务中存在的问题</h4><p>如果不考虑事务的隔离性，会发生以下几种问题：</p><ul><li>脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</li><li>不可重复读：不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询返回不同的数据值(这里不同是指某一条或多条数据的内容前后不一致，但数据条数相同)，这是由于在查询间隔，该事务需要用到的数据被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了其他事务提交的数据。需要注意的是在某些情况下不可重复读并不是问题。</li><li>幻读：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中。</li></ul><h4 id="排他锁，共享锁"><a href="#排他锁，共享锁" class="headerlink" title="排他锁，共享锁"></a>排他锁，共享锁</h4><p>排它锁（Exclusive），又称为X 锁，写锁。</p><p>共享锁（Shared），又称为S 锁，读锁。</p><p>读写锁之间有以下的关系：</p><ul><li>一个事务对数据对象O加了 S 锁，可以对 O进行读取操作，但是不能进行更新操作。加锁期间其它事务能对O 加 S 锁，但是不能加 X 锁。</li><li>一个事务对数据对象 O 加了 X 锁，就可以对 O 进行读取和更新。加锁期间其它事务不能对 O 加任何锁。</li></ul><p>即读写锁之间的关系可以概括为：多读单写</p><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>在事务中存在以下几种隔离级别：</p><ul><li>读未提交(Read Uncommitted)：解决更新丢失问题。如果一个事务已经开始写操作，那么其他事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据不需要加 S 锁。</li><li>读已提交(Read Committed)：解决了脏读问题。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。这可以通过“瞬间共享读锁”和“排他写锁”实现， 即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事务结束。</li><li>可重复读取(Repeatable Read)：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事务结束后再释放。</li><li>串行化(Serializable)：解决了幻读的问题的。提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。</li></ul><h3 id="MySQL中的隔离级别的实现"><a href="#MySQL中的隔离级别的实现" class="headerlink" title="MySQL中的隔离级别的实现"></a>MySQL中的隔离级别的实现</h3><p>上面的内容解释了一些数据库理论的概念，但是在MySQL、ORACLE这样的数据库中，为了性能的考虑并不是完全按照上面介绍的理论来实现的。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>多版本并发控制(Multi-Version Concurrency Control, MVCC)是MySQL中基于乐观锁理论实现隔离级别的方式，用于实现读已提交和可重复读取隔离级别的实现。</p><h5 id="实现-隔离级别为可重复读"><a href="#实现-隔离级别为可重复读" class="headerlink" title="实现(隔离级别为可重复读)"></a>实现(隔离级别为可重复读)</h5><p>在说到如何实现前先引入两个概念：</p><blockquote><p>系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</p></blockquote><blockquote><p>事务版本号：事务开始时的系统版本号。</p></blockquote><p>在MySQL中，会在表中每一条数据后面添加两个字段：</p><p>创建版本号：创建一行数据时，将当前系统版本号作为创建版本号赋值</p><p>删除版本号：删除一行数据时，将当前系统版本号作为删除版本号赋值</p><h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><p>select时读取数据的规则为：创建版本号&lt;&#x3D;当前事务版本号，删除版本号为空或&gt;当前事务版本号。</p><p>创建版本号&lt;&#x3D;当前事务版本号保证取出的数据不会有后启动的事务中创建的数据。这也是为什么在开始的示例中我们不会查出后来添加的数据的原因</p><p>删除版本号为空或&gt;当前事务版本号保证了至少在该事务开启之前数据没有被删除，是应该被查出来的数据。</p><h5 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h5><p>insert时将当前的系统版本号赋值给创建版本号字段。</p><h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行，实际上这里的更新是通过delete和insert实现的。</p><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>删除时将当前的系统版本号赋值给删除版本号字段，标识该行数据在那一个事务中会被删除，即使实际上在位commit时该数据没有被删除。根据select的规则后开启懂数据也不会查询到该数据。</p><h4 id="MVCC真的解决了幻读？"><a href="#MVCC真的解决了幻读？" class="headerlink" title="MVCC真的解决了幻读？"></a>MVCC真的解决了幻读？</h4><p>从最开始我们的测试示例和上面的理论支持来看貌似在MySQL中通过MVCC就解决了幻读的问题，那既然这样串行化读貌似就没啥意义了，带着疑问继续测试。</p><p>测试前数据：</p><p><img src="/media/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/16993816f09c6135tplv-t2oaga2asx-zoom-in-crop-mark4536000-16803406085273.awebp" alt="测试前数据"></p><table><thead><tr><th>事务 1</th><th>事务 2</th></tr></thead><tbody><tr><td>begin</td><td>begin</td></tr><tr><td>select * from dept</td><td></td></tr><tr><td>-</td><td>insert into dept(name) values(“研发部”)</td></tr><tr><td>-</td><td>commit</td></tr><tr><td>update dept set name&#x3D;”财务部”(工作中如果不想被辞退一定要写where条件)</td><td></td></tr><tr><td>commit</td><td></td></tr></tbody></table><p>根据上面的结果我们期望的结果是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span>  name</span><br><span class="line">1   财务部</span><br><span class="line">2   研发部</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但是实际上我们的经过是：</p><p><img src="/media/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/16993816f0a588dctplv-t2oaga2asx-zoom-in-crop-mark4536000-16803406085274.awebp" alt="测试后数据"></p><p>本来我们希望得到的结果只是第一条数据的部门改为财务，但是结果确实两条数据都被修改了。这种结果告诉我们其实在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。</p><h4 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h4><p>出现了上面的情况我们需要知道为什么会出现这种情况。在查阅了一些资料后发现在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。</p><h5 id="select-快照读"><a href="#select-快照读" class="headerlink" title="select 快照读"></a>select 快照读</h5><p>当执行select操作是innodb默认会执行快照读，会记录下这次select后的结果，之后select 的时候就会返回这次快照的数据，即使其他事务提交了不会影响当前select的数据，这就实现了可重复读了。快照的生成当在第一次执行select的时候，也就是说假设当A开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有B添加的那条数据。之后无论再有其他事务commit都没有关系，因为快照已经生成了，后面的select都是根据快照来的。</p><h5 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h5><p>对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。也正是因为这样所以才导致上面我们测试的那种情况。</p><p>select的当前读需要手动的加锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="有个问题说明下"><a href="#有个问题说明下" class="headerlink" title="有个问题说明下"></a>有个问题说明下</h4><p>在测试过程中最开始我以为使用<code>begin</code>语句就是开始一个事务了，所以在上面第二次测试中因为先开始的事务1，结果在事务1中却查到了事务2新增的数据，当时认为这和前面MVCC中的select的规则不一致了，所以做了如下测试：</p><p><img src="/media/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/16993816f0b117ddtplv-t2oaga2asx-zoom-in-crop-mark4536000-16803406085275.awebp" alt="image"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX <span class="operator">/</span><span class="operator">/</span>用于查询当前正在执行中的事务</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到如果只是执行<code>begin</code>语句实际上并没有开启一个事务。</p><p>下面在<code>begin</code>后添加一条select语句：</p><p><img src="/media/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/16993816f090efbbtplv-t2oaga2asx-zoom-in-crop-mark4536000-16803406085276.awebp" alt="事务2"></p><p>所以要明白实际上是对数据进行了增删改查等操作后才开启了一个事务。</p><h4 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h4><p>很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：</p><ul><li>使用串行化读的隔离级别</li><li>MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)</li></ul><p>实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MySQL的可重复读级别能解决幻读吗&quot;&gt;&lt;a href=&quot;#MySQL的可重复读级别能解决幻读吗&quot; class=&quot;headerlink&quot; title=&quot;MySQL的可重复读级别能解决幻读吗&quot;&gt;&lt;/a&gt;MySQL的可重复读级别能解决幻读吗&lt;/h1&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;之前在深入了解数据库理论的时候，了解到事务的不同隔离级别可能存在的问题。为了更好的理解所以在MySQL数据库中测试复现这些问题。关于脏读和不可重复读在相应的隔离级别下都很容易的复现了。但是对于幻读，我发现在可重复读的隔离级别下没有出现，当时想到难道是MySQL对幻读做了什么处理？&lt;/p&gt;</summary>
    
    
    
    
    <category term="mysql" scheme="http://localhost:4000/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>记一次Quartz重复调度(任务重复执行)的问题排查</title>
    <link href="http://localhost:4000/2023/03/30/quartz/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://localhost:4000/2023/03/30/quartz/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2023-03-30T15:06:20.892Z</published>
    <updated>2023-03-30T14:45:51.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记一次Quartz重复调度-任务重复执行-的问题排查"><a href="#记一次Quartz重复调度-任务重复执行-的问题排查" class="headerlink" title="记一次Quartz重复调度(任务重复执行)的问题排查"></a>记一次Quartz重复调度(任务重复执行)的问题排查</h1><p> </p><h2 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h2><p>公司前期改用quartz做任务调度，一日的调度量均在两百万次以上。随着调度量的增加，突然开始出现job重复调度的情况，且没有规律可循。网上也没有说得较为清楚的解决办法，于是我们开始调试Quartz源码，并最终找到了问题所在。 如果没有耐性看完源码解析，可以直接拉到文章最末，有直接简单的解决办法。<br>注：本文中使用的quartz版本为2.3.0，且使用JDBC模式存储Job。</p><h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h2><p>首先，因为本文是代码级别的分析文章，因而需要提前了解Quartz的用途和用法，网上还是有很多不错的文章，可以提前自行了解。</p><p>其次，在用法之外，我们还需要了解一些Quartz框架的基础概念：</p><p>\1) Quartz把触发job，叫做<strong>fire</strong>。<strong>TRIGGER_STATE</strong>是当前trigger的状态，<strong>PREV_FIRE_TIME</strong>是上一次触发时间，<strong>NEXT_FIRE_TIME</strong>是下一次触发时间，<strong>misfire</strong>是指这个job在某一时刻要触发，却因为某些原因没有触发的情况。</p><p>\2) Quartz在运行时，会起两类线程（不止两类），一类用于调度job的调度线程（单线程），一类是用于执行job具体业务的工作池。</p><p>\3) Quartz自带的表里面，本文主要涉及以下3张表：</p><ul><li>triggers表。triggers表里记录了，某个trigger的PREV_FIRE_TIME（上次触发时间），NEXT_FIRE_TIME（下一次触发时间），TRIGGER_STATE（当前状态）。虽未尽述，但是本文用到的只有这些。</li><li>locks表。Quartz支持分布式，也就是会存在多个线程同时抢占相同资源的情况，而Quartz正是依赖这张表，处理这种状况，至于如何做到，参见3.1。</li><li>fired_triggers表，记录正在触发的triggers信息。</li></ul><p>\4) TRIGGER_STATE，也就是trigger的状态，主要有以下几类：<br><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdx7u.png" alt="图片描述"></p><p>图2-1 trigger状态变化图</p><p>trigger的初始状态是<strong>WAITING</strong>，处于<strong>WAITING</strong>状态的trigger等待被触发。调度线程会不停地扫triggers表，根据NEXT_FIRE_TIME提前拉取即将触发的trigger，如果这个trigger被该调度线程拉取到，它的状态就会变为<strong>ACQUIRED</strong>。因为是提前拉取trigger，并未到达trigger真正的触发时刻，所以调度线程会等到真正触发的时刻，再将trigger状态由<strong>ACQUIRED</strong>改为<strong>EXECUTING</strong>。如果这个trigger不再执行，就将状态改为<strong>COMPLETE</strong>,否则为<strong>WAITING</strong>，开始新的周期。如果这个周期中的任何环节抛出异常，trigger的状态会变成<strong>ERROR</strong>。如果手动暂停这个trigger，状态会变成<strong>PAUSED</strong>。</p><h2 id="3-开始排查"><a href="#3-开始排查" class="headerlink" title="3. 开始排查"></a>3. 开始排查</h2><h3 id="3-1分布式状态下的数据访问"><a href="#3-1分布式状态下的数据访问" class="headerlink" title="3.1分布式状态下的数据访问"></a>3.1分布式状态下的数据访问</h3><p>前文提到，trigger的状态储存在数据库，Quartz支持分布式，所以如果起了多个quartz服务，会有多个调度线程来抢夺触发同一个trigger。mysql在默认情况下执行select 语句，是不上锁的，那么如果同时有1个以上的调度线程抢到同一个trigger，是否会导致这个trigger重复调度呢？我们来看看，Quartz是如何解决这个问题的。</p><p>首先，我们先来看下<code>JobStoreSupport</code>类的<code>executeInNonManagedTXLock()</code>方法：</p><p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdaoM.png" alt="图片描述"></p><p>图3-1 executeInNonManagedTXLock方法的具体实现</p><p>这个方法的官方介绍：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line">*Execute <span class="keyword">the</span> <span class="keyword">given</span> callback having acquired <span class="keyword">the</span> <span class="keyword">given</span> lock.</span><br><span class="line"></span><br><span class="line">*Depending <span class="keyword">on</span> <span class="keyword">the</span> JobStore,<span class="keyword">the</span> surrounding <span class="keyword">transaction</span> maybe</span><br><span class="line"></span><br><span class="line">*assumed <span class="keyword">to</span> be already present(managed).</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">*@param lockName The <span class="built_in">name</span> <span class="keyword">of</span> <span class="keyword">the</span> lock <span class="keyword">to</span> acquire,<span class="keyword">for</span> example</span><br><span class="line"></span><br><span class="line">*<span class="string">&quot;TRIGGER_ACCESS&quot;</span>.If null, <span class="keyword">then</span> no lock <span class="keyword">is</span> acquired ,<span class="keyword">but</span> <span class="keyword">the</span></span><br><span class="line"></span><br><span class="line">*lockCallback <span class="keyword">is</span> still executed <span class="keyword">in</span> a <span class="keyword">transaction</span>.</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>也就是说，传入的callback方法在执行的过程中是携带了指定的锁，并开启了事务，注释也提到，lockName就是指定的锁的名字，如果lockName是空的，那么callback方法的执行不在锁的保护下，但依然在事务中。</p><p>这意味着，我们使用这个方法，不仅可以保证事务，还可以选择保证，callback方法的线程安全。</p><p>接下来，我们来看一下<code>executeInNonManagedTXLock（…）</code>中的<code>obtainLock(conn,lockName)</code>方法，即抢锁的过程。这个方法是在<code>Semaphore</code>接口中定义的，<code>Semaphore</code>接口通过锁住线程或者资源，来保护资源不被其他线程修改，由于我们的调度信息是存在数据库的，所以现在查看<code>DBSemaphore.java</code>中<code>obtainLock</code>方法的具体实现：</p><p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdaoW.png" alt="图片描述"></p><p>图3-2 obtainLock方法具体实现</p><p>我们通过调试查看<code>expandedSQL</code>和<code>expandedInsertSQL</code>这两个变量：</p><p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdaoZ.png" alt="图片描述"></p><p>图3-3 expandedSQL和expandedInsertSQL的具体内容</p><p>图3-3可以看出，<code>obtainLock</code>方法通过locks表的一个行锁（lockName确定）来保证callback方法的事务和线程安全。拿到锁后，<code>obtainLock</code>方法将<code>lockName</code>写入<code>threadlocal</code>。当然在<code>releaseLock</code>的时候，会将<code>lockName</code>从<code>threadlocal</code>中删除。</p><p>总而言之，<code>executeInNonManagedTXLock()</code>方法，保证了在分布式的情况，同一时刻，只有一个线程可以执行这个方法。</p><h3 id="3-2-quartz的调度过程"><a href="#3-2-quartz的调度过程" class="headerlink" title="3.2 quartz的调度过程"></a>3.2 quartz的调度过程</h3><p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdao5.png" alt="图片描述"></p><p>图3-4 Quartz的调度时序图</p><p><code>QuartzSchedulerThread</code>是调度线程的具体实现，图3-4 是这个线程<code>run()</code>方法的主要内容，图中只提到了正常的情况下，也就是流程中没有出现异常的情况下的处理过程。由图可以看出，调度流程主要分为以下三步：</p><h4 id="1）拉取待触发trigger"><a href="#1）拉取待触发trigger" class="headerlink" title="1）拉取待触发trigger:"></a>1）拉取待触发trigger:</h4><p>调度线程会一次性拉取距离现在，一定时间窗口内的，一定数量内的，即将触发的trigger信息。那么，时间窗口和数量信息如何确定呢，我们先来看一下，以下几个参数：</p><ul><li><code>idleWaitTime</code>： 默认30s，可通过配置属性<code>org.quartz.scheduler.idleWaitTime</code>设置。</li><li><code>availThreadCount</code>：获取可用（空闲）的工作线程数量，总会大于1，因为该方法会一直阻塞，直到有工作线程空闲下来。</li><li><code>maxBatchSize</code>：一次拉取trigger的最大数量，默认是1，可通过<code>org.quartz.scheduler.batchTriggerAcquisitionMaxCount</code>改写</li><li><code>batchTimeWindow</code>：时间窗口调节参数，默认是0，可通过<code>org.quartz.scheduler.batchTriggerAcquisitionFireAheadTimeWindow</code>改写</li><li><code>misfireThreshold</code>： 超过这个时间还未触发的trigger,被认为发生了misfire,默认60s，可通过<code>org.quartz.jobStore.misfireThreshold</code>设置。</li></ul><p>调度线程一次会拉取<strong>NEXT_FIRE_TIME</strong>小于（<code>now + idleWaitTime +batchTimeWindow</code>）,大于（<code>now - misfireThreshold</code>）的，<code>min(availThreadCount,maxBatchSize)</code>个triggers，默认情况下，会拉取未来30s，过去60s之间还未fire的1个trigger。随后将这些triggers的状态由<strong>WAITING</strong>改为<strong>ACQUIRED</strong>，并插入fired_triggers表。</p><h4 id="2）触发trigger："><a href="#2）触发trigger：" class="headerlink" title="2）触发trigger："></a>2）触发trigger：</h4><p>首先，我们会检查每个trigger的状态是不是<strong>ACQUIRED</strong>，如果是，则将状态改为<strong>EXECUTING</strong>，然后更新trigger的<strong>NEXT_FIRE_TIME</strong>，如果这个trigger的<strong>NEXT_FIRE_TIME</strong>为空，也就是未来不再触发，就将其状态改为<strong>COMPLETE</strong>。如果trigger不允许并发执行（即Job的实现类标注了<code>@DisallowConcurrentExecution</code>），则将状态变为<strong>BLOCKED</strong>，否则就将状态改为<strong>WAITING</strong>。</p><h4 id="3）包装trigger，丢给工作线程池："><a href="#3）包装trigger，丢给工作线程池：" class="headerlink" title="3）包装trigger，丢给工作线程池："></a>3）包装trigger，丢给工作线程池：</h4><p>遍历triggers，如果其中某个trigger在第二步出错，即返回值里面有exception或者为null，就会做一些triggers表，fired_triggers表的内容修正，跳过这个trigger，继续检查下一个。否则，则根据trigger信息实例化<code>JobRunShell</code>（实现了Thread接口），同时依据<code>JOB_CLASS_NAME</code>实例化<code>Job</code>，随后我们将<code>JobRunShell</code>实例丢入工作线。</p><p>在<code>JobRunShell</code>的<code>run()</code>方法，Quartz会在执行<code>job.execute()</code>的前后通知之前绑定的监听器，如果<code>job.execute()</code>执行的过程中有异常抛出，则执行结果<code>jobExEx</code>会保存异常信息，反之如果没有异常抛出，则<code>jobExEx</code>为null。然后根据<code>jobExEx</code>的不同，得到不同的执行指令<code>instCode</code>。</p><p><code>JobRunShell</code>将trigger信息，job信息和执行指令传给<code>triggeredJobComplete()</code>方法来完成最后的数据表更新操作。例如如果job执行过程有异常抛出，就将这个trigger状态变为<strong>ERROR</strong>，如果是<strong>BLOCKED</strong>状态，就将其变为<strong>WAITING</strong>等等，最后从fired_triggers表中删除这个已经执行完成的trigger。注意，这些是在工作线程池异步完成。</p><h3 id="3-3-排查问题"><a href="#3-3-排查问题" class="headerlink" title="3.3 排查问题"></a>3.3 排查问题</h3><p>在前文，我们可以看到，Quartz的调度过程中有3次（可选的）上锁行为，为什么称为可选？因为这三个步骤虽然在<code>executeInNonManagedTXLock</code>方法的保护下，但<code>executeInNonManagedTXLock</code>方法可以通过设置传入参数lockName为空，取消上锁。在翻阅代码时，我们看到第一步拉取待触发的trigger时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;OperableTrigger&gt; <span class="title function_">acquireNextTriggers</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> noLaterThan, <span class="keyword">final</span> <span class="type">int</span> maxCount, <span class="keyword">final</span> <span class="type">long</span> timeWindow)</span> JobPersistenceException &#123;</span><br><span class="line">    String lockName;</span><br><span class="line">    <span class="comment">//判断是否需要上锁</span></span><br><span class="line">    <span class="keyword">if</span> (isAcquireTriggersWithinLock() || maxCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        lockName = LOCK_TRIGGER_ACCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lockName = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executeInNonManagedTXLock(lockName, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">TransactionCallback</span>&lt;List&lt;OperableTrigger&gt;&gt;()&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;OperableTrigger&gt; <span class="title function_">execute</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> JobPersistenceException &#123;</span><br><span class="line">            <span class="keyword">return</span> acquireNextTrigger(conn, noLaterThan, maxCount, timeWindow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> <span class="title class_">TransactionValidator</span>&lt;List&lt;OperableTrigger&gt;&gt;() &#123;</span><br><span class="line">         <span class="comment">//省略</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在加锁之前对lockName做了一次判断，而非像其他加锁方法一样，默认传入的就是<strong>LOCK_TRIGGER_ACCESS</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TriggerFiredResult&gt; <span class="title function_">triggersFired</span><span class="params">(<span class="keyword">final</span> List&lt;OperableTrigger&gt; triggers)</span> <span class="keyword">throws</span> JobPersistenceException &#123;</span><br><span class="line">    <span class="comment">//默认上锁</span></span><br><span class="line">    <span class="keyword">return</span> executeInNonManagedTXLock(LOCK_TRIGGER_ACCESS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TransactionCallback</span>&lt;List&lt;TriggerFiredResult&gt;&gt;() &#123;</span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">        &#125;,<span class="keyword">new</span> <span class="title class_">TransactionValidator</span>&lt;List&lt;TriggerFiredResult&gt;&gt;() &#123;</span><br><span class="line">            <span class="comment">//省略</span></span><br><span class="line">           &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调试发现<code>isAcquireTriggersWithinLock()</code>的值是<code>false</code>，因而导致传入的lockName是null。我在代码中加入日志，可以更清楚的看到这个过程。<br><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdapa.png" alt="图片描述"><br>图3-5 调度日志</p><p>由图3-5可以清楚看到，在拉取待触发的trigger时，默认是不上锁。如果这种默认配置有问题，岂不是会频繁发生重复调度的问题？而事实上并没有，原因在于Quartz默认采取乐观锁，也就是允许多个线程同时拉取同一个trigger。我们看一下Quartz在调度流程的第二步fire trigger的时候做了什么，注意此时是上锁状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TriggerFiredBundle <span class="title function_">triggerFired</span><span class="params">(Connection conn, OperableTrigger trigger)</span></span><br><span class="line">    <span class="keyword">throws</span> JobPersistenceException &#123;</span><br><span class="line">    JobDetail job;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Make sure trigger wasn&#x27;t deleted, paused, or completed...</span></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// if trigger was deleted, state will be STATE_DELETED</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> getDelegate().selectTriggerState(conn,trigger.getKey());</span><br><span class="line">         <span class="keyword">if</span> (!state.equals(STATE_ACQUIRED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JobPersistenceException</span>(<span class="string">&quot;Couldn&#x27;t select trigger state: &quot;</span></span><br><span class="line">                    + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调度线程如果发现当前trigger的状态不是<strong>ACQUIRED</strong>，也就是说，这个trigger被其他线程fire了，就会返回null。在3.2，我们提到，在调度流程的第三步，如果发现某个trigger第二步的返回值是null，就会跳过第三步，取消fire。在通常的情况下，乐观锁能保证不发生重复调度，但是难免发生ABA问题，我们看一下这是发生重复调度时的日志：</p><p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdapd.png" alt="图片描述"></p><p>图3-5 重复调度的日志</p><p>在第一步时，也就是quartz在拉取到符合条件的triggers 到将他们的状态由<strong>WAITING</strong>改为<strong>ACQUIRED</strong>之间停顿了有超过9ms的时间，而另一台服务器正是趁着这9ms的空档完成了<strong>WAITING–&gt;ACQUIRED–&gt;EXECUTING–&gt;WAITING</strong>（也就是一个完整的状态变化周期）的全部过程，图示参见图3-6。</p><p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdapg.png" alt="图片描述"></p><p>图3-6 重复调度原因示意图</p><h3 id="3-4-解决办法"><a href="#3-4-解决办法" class="headerlink" title="3.4 解决办法"></a>3.4 解决办法</h3><p>如何去解决这个问题呢？在配置文件加上<code>org.quartz.jobStore.acquireTriggersWithinLock=true</code>，这样，在调度流程的第一步，也就是拉取待即将触发的triggers时，是上锁的状态，即不会同时存在多个线程拉取到相同的trigger的情况，也就避免的重复调度的危险。</p><h3 id="3-5-心得"><a href="#3-5-心得" class="headerlink" title="3.5 心得"></a>3.5 心得</h3><p>此次排查过程并非一帆风顺，走过一些坑，也有一些非技术相关的体会：</p><p>1）学习是一个需要不断打磨，修正的能力。就我个人而言，为了学Quartz，刚开始去翻一个2.4MB大小的源码是毫无头绪，并且效率低下的，所以立刻转换方向，先了解这个框架的运行模式，在做什么，有哪些模块，是怎么做的，再找主线，翻相关的源码。之后在一次次使用中，碰到问题再翻之前没看的源码，就越来越顺利。</p><p>之前也听过其他同事的学习方法，感觉并不完全适合自己，可能每个人状态经验不同，学习方法也稍有不同。在平时的学习中，需要去感受自己的学习效率，参考建议，尝试，感受效果，改进，会越来越清晰自己适合什么。这里很感谢我的师父，用简短的话先帮我捋顺了调度流程，这样我再看源码就不那么吃力了。</p><p>2）要质疑“经验”和“理所应当”，惯性思维会蒙住你的双眼。在大规模的代码中很容易被习惯迷惑，一开始，我们看到上锁的那个方法的时候，认为这个上锁技巧很棒，这个方法就是为了解决并发的问题，“应该”都上锁了，上锁了就不会有并发的问题了，怎么可能几次与数据库的交互都上锁，突然某一次不上锁呢？直到看到拉取待触发的trigger方法时，觉得有丝丝不对劲，打下日志，才发现实际上是没上锁的。</p><p>3）日志很重要。虽然我们可以调试，但是没有日志，我们是无法发现并证明，程序发生了ABA问题。</p><p>4）最重要的是，不要害怕问题，即使是Quartz这样大型的框架，解决问题也不一定需要把2.4MB的源码通通读懂。只要有时间，问题都能解决，只是好的技巧能缩短这个时间，而我们需要在一次次实战中磨练技巧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记一次Quartz重复调度-任务重复执行-的问题排查&quot;&gt;&lt;a href=&quot;#记一次Quartz重复调度-任务重复执行-的问题排查&quot; class=&quot;headerlink&quot; title=&quot;记一次Quartz重复调度(任务重复执行)的问题排查&quot;&gt;&lt;/a&gt;记一次Quart</summary>
      
    
    
    
    
    <category term="Quartz" scheme="http://localhost:4000/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>misfire执行策略</title>
    <link href="http://localhost:4000/2023/03/30/quartz/quarz%20misfire%E7%AD%96%E7%95%A5/"/>
    <id>http://localhost:4000/2023/03/30/quartz/quarz%20misfire%E7%AD%96%E7%95%A5/</id>
    <published>2023-03-30T15:06:20.887Z</published>
    <updated>2023-03-30T14:37:45.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="misfire执行策略"><a href="#misfire执行策略" class="headerlink" title="misfire执行策略"></a>misfire执行策略</h1><p>默认策略为：<strong>MISFIRE_INSTRUCTION_SMART_POLICY</strong> &#x3D; 0</p><p><strong>repeatCount</strong>: 根据定时任务类型判断出的重复次数</p><ol start="0"><li><p><strong>MISFIRE_INSTRUCTION_SMART_POLICY</strong><br>智能根据trigger属性选择策略：<br>repeatCount为0，则策略同<strong>MISFIRE_INSTRUCTION_FIRE_NOW</strong><br>repeatCount为<strong>REPEAT_INDEFINITELY</strong>(无限期重复)，则策略同<strong>MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT</strong><br>否则策略同<strong>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT</strong></p></li><li><p><strong>MISFIRE_INSTRUCTION_FIRE_NOW</strong></p><p>以当前时间为触发频率立即触发执行</p></li><li><p><strong>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT</strong></p></li></ol><p>​以当前时间为触发频率立即触发执行，以总次数-已执行次数作为剩余周期次数，重新计算FinalTime<br>​调整后的FinalTime会略大于根据starttime计算的到的FinalTime值</p><ol start="3"><li><p><strong>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT</strong></p><p>不触发立即执行<br>等待下次触发频率周期时刻，执行至FinalTime的剩余周期次数<br>保持FinalTime不变，重新计算剩余周期次数(相当于错过的当做已执行)</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;misfire执行策略&quot;&gt;&lt;a href=&quot;#misfire执行策略&quot; class=&quot;headerlink&quot; title=&quot;misfire执行策略&quot;&gt;&lt;/a&gt;misfire执行策略&lt;/h1&gt;&lt;p&gt;默认策略为：&lt;strong&gt;MISFIRE_INSTRUCTION_</summary>
      
    
    
    
    
    <category term="Quartz" scheme="http://localhost:4000/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>Quartz应用与集群原理分析</title>
    <link href="http://localhost:4000/2023/03/30/quartz/quartz%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://localhost:4000/2023/03/30/quartz/quartz%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2023-03-30T15:06:20.886Z</published>
    <updated>2023-04-16T13:08:47.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartz应用与集群原理分析"><a href="#Quartz应用与集群原理分析" class="headerlink" title="Quartz应用与集群原理分析"></a>Quartz应用与集群原理分析</h1><h1 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h1><p>Quartz集群同步机制：每当要进行与某种业务相关的数据库操作时，先去QRTZ_LOCKS表中查询操作相关的业务对象所需要的锁，在select语句之后加for update来实现。例如，TRIGGER_ACCESS表示对任务触发器相关的信息进行修改、删除操作时所需要获得的锁。这时，执行查询这个表数据的SQL形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from QRTZ_LOCKS t where t.lock_name=&#x27;TRIGGER_ACCESS&#x27; for update</span><br></pre></td></tr></table></figure><p>当一个线程使用上述的SQL对表中的数据执行查询操作时，若查询结果中包含相关的行，数据库就对该行进行ROW LOCK；若此时，另外一个线程使用相同的SQL对表的数据进行查询，由于查询出的数据行已经被数据库锁住了，此时这个线程就只能等待，直到拥有该行锁的线程完成了相关的业务操作，执行了commit动作后，数据库才会释放了相关行的锁，这个线程才能继续执行。</p><h2 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h2><p>美团CRM系统中每天有大量的后台任务需要调度执行，如构建索引、统计报表、周期同步数据等等，要求任务调度系统具备高可用性、负载均衡特性，可以管理并监控任务的执行流程，以保证任务的正确执行。</p><h2 id="二、历史方案"><a href="#二、历史方案" class="headerlink" title="二、历史方案"></a>二、历史方案</h2><p>美团CRM系统的任务调度模块经历了以下历史方案。</p><p><strong>1. Crontab+SQL</strong></p><p>每天晚上运行定时任务，通过SQL脚本+crontab方式执行，例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#crm</span><br><span class="line">0 2 * * * /xxx/mtcrm/shell/mtcrm_daily_stat.sql    //每天凌晨2:00执行统计</span><br><span class="line">30 7 * * * /xxx/mtcrm/shell/mtcrm_data_fix.sql     //每天早上7:30执行数据修复</span><br></pre></td></tr></table></figure><p>该方案存在以下问题：</p><ul><li>直接访问数据库，各系统业务接口没有重用。</li><li>完成复杂业务需求时，会引入过多中间表。</li><li>业务逻辑计算完全依赖SQL，增大数据库压力。</li><li>任务失败无法自动恢复。</li></ul><p><strong>2. Python+SQL</strong></p><p>采用python脚本(多数据源)+SQL方式执行，例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def connectCRM():</span><br><span class="line"> return MySQLdb.Connection(&quot;host1&quot;, &quot;uname&quot;, &quot;xxx&quot;, &quot;crm&quot;, 3306, charset=&quot;utf8&quot;)</span><br><span class="line"></span><br><span class="line">def connectTemp():</span><br><span class="line"> return MySQLdb.Connection(&quot;host1&quot;, &quot;uname&quot;, &quot;xxx&quot;, &quot;temp&quot;, 3306, charset=&quot;utf8&quot;)</span><br></pre></td></tr></table></figure><p>该方案存在问题：</p><ul><li>直接访问数据，需要理解各系统的数据结构，无法满足动态任务问题，各系统业务接口没有重用。</li><li>无负载均衡。</li><li>任务失败无法恢复。</li><li>在JAVA语言开发中出现异构，且很难统一到自动部署系统中。</li></ul><p><strong>3. Spring+JDK Timer</strong></p><p>该方案使用spring+JDK Timer方式，调用接口完成定时任务，在分布式部署环境下，防止多个节点同时运行任务，需要写死host，控制在一台服务器上执行task。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;accountStatusTaskScanner&quot;  class=&quot;xxx.crm.service.impl.AccountStatusTaskScanner&quot; /&gt;</span><br><span class="line">    &lt;task:scheduler id=&quot;taskScheduler&quot; pool-size=&quot;5&quot; /&gt;</span><br><span class="line">    &lt;task:scheduled-tasks scheduler=&quot;taskScheduler&quot;&gt;</span><br><span class="line">    &lt;task:scheduled ref=&quot;accountStatusTaskScanner&quot; method=&quot;execute&quot; cron=&quot;0 0 1 * * ?&quot; /&gt;</span><br><span class="line">&lt;/task:scheduled-tasks&gt;</span><br></pre></td></tr></table></figure><p>该方案较方案1，2有很大改进，但仍存在以下问题：</p><ul><li>步骤复杂、分散，任务量增大的情况下，很难扩展</li><li>使用写死服务器Host的方式执行task，存在单点风险，负载均衡手动完成。</li><li>应用重启，任务无法自动恢复。</li></ul><p>CRM系统定时任务走过了很多弯路：定时任务多种实现方式，使配置和代码分散在多处，难以维护和监控；任务执行过程没有保证，没有错误恢复；任务执行异常没有反馈(邮件)；没有集群支持、负载均衡。CRM系统需要分布式的任务调度框架，统一解决问题，Java可以使用的任务调度框架有Quartz，Jcrontab，cron4j，我们选择了Quartz。</p><h2 id="三、为什么选择Quartz"><a href="#三、为什么选择Quartz" class="headerlink" title="三、为什么选择Quartz"></a>三、为什么选择Quartz</h2><p>Quartz是Java领域最著名的开源任务调度工具。Quartz提供了极为广泛的特性如持久化任务，集群和分布式任务等，其特点如下：</p><ul><li>完全由Java写成，方便集成(Spring)</li><li>伸缩性</li><li>负载均衡</li><li>高可用性</li></ul><h2 id="四、Quartz集群部署实践"><a href="#四、Quartz集群部署实践" class="headerlink" title="四、Quartz集群部署实践"></a>四、Quartz集群部署实践</h2><p>CRM中Quartz与Spring结合使用，Spring通过提供org.springframework.scheduling.quartz下的封装类对Quartz支持。</p><p><strong>Quartz集群部署：</strong></p><p><img src="/media/quartz%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/c45f767d.png" alt="Quartz集群部署"></p><p>Quartz集群部署</p><p>Quartz集群中的每个节点是一个独立的Quartz应用，它又管理着其他的节点。该集群需要分别对每个节点分别启动或停止，不像应用服务器的集群，独立的Quartz节点并不与另一个节点或是管理节点通信。Quartz应用是通过数据库表来感知到另一应用。只有使用持久的JobStore才能完成Quqrtz集群。</p><p><strong>基于Spring的集群配置：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 调度工厂 --&gt;</span><br><span class="line">&lt;bean id=&quot;quartzScheduler&quot;</span><br><span class="line">    class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;quartzProperties&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;org.quartz.scheduler.instanceName&quot;&gt;CRMscheduler&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;org.quartz.scheduler.instanceId&quot;&gt;AUTO&lt;/prop&gt;</span><br><span class="line">            &lt;!-- 线程池配置 --&gt;</span><br><span class="line">            &lt;prop key=&quot;org.quartz.threadPool.class&quot;&gt;org.quartz.simpl.SimpleThreadPool&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;org.quartz.threadPool.threadCount&quot;&gt;20&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;org.quartz.threadPool.threadPriority&quot;&gt;5&lt;/prop&gt;</span><br><span class="line">            &lt;!-- JobStore 配置 --&gt;</span><br><span class="line">            &lt;prop key=&quot;org.quartz.jobStore.class&quot;&gt;org.quartz.impl.jdbcjobstore.JobStoreTX&lt;/prop&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- 集群配置 --&gt;</span><br><span class="line">            &lt;prop key=&quot;org.quartz.jobStore.isClustered&quot;&gt;true&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;org.quartz.jobStore.clusterCheckinInterval&quot;&gt;15000&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;org.quartz.jobStore.maxMisfiresToHandleAtATime&quot;&gt;1&lt;/prop&gt;</span><br><span class="line"></span><br><span class="line">            &lt;prop key=&quot;org.quartz.jobStore.misfireThreshold&quot;&gt;120000&lt;/prop&gt;</span><br><span class="line"></span><br><span class="line">            &lt;prop key=&quot;org.quartz.jobStore.tablePrefix&quot;&gt;QRTZ_&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;schedulerName&quot; value=&quot;CRMscheduler&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--必须的，QuartzScheduler 延时启动，应用启动完后 QuartzScheduler 再启动 --&gt;</span><br><span class="line">    &lt;property name=&quot;startupDelay&quot; value=&quot;30&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContextKey&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--可选，QuartzScheduler 启动时更新己存在的Job，这样就不用每次修改targetObject后删除qrtz_job_details表对应记录了 --&gt;</span><br><span class="line">    &lt;property name=&quot;overwriteExistingJobs&quot; value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 设置自动启动 --&gt;</span><br><span class="line">    &lt;property name=&quot;autoStartup&quot; value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 注册触发器 --&gt;</span><br><span class="line">    &lt;property name=&quot;triggers&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;ref bean=&quot;userSyncScannerTrigger&quot; /&gt;</span><br><span class="line">                     ......</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 注册jobDetail --&gt;</span><br><span class="line">    &lt;property name=&quot;jobDetails&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;schedulerListeners&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;ref bean=&quot;quartzExceptionSchedulerListener&quot; /&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.class属性为JobStoreTX，将任务持久化到数据中。因为集群中节点依赖于数据库来传播Scheduler实例的状态，你只能在使用JDBC JobStore时应用Quartz集群。</span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.isClustered属性为true，通知Scheduler实例要它参与到一个集群当中。</span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.clusterCheckinInterval属性定义了Scheduler实例检入到数据库中的频率(单位：毫秒)。Scheduler检查是否其他的实例到了它们应当检入的时候未检入；这能指出一个失败的Scheduler实例，且当前 Scheduler会以此来接管任何执行失败并可恢复的Job。通过检入操作，Scheduler 也会更新自身的状态记录。clusterChedkinInterval越小，Scheduler节点检查失败的Scheduler实例就越频繁。默认值是 15000 (即15 秒)。</span><br><span class="line"></span><br><span class="line">其余参数在后文将会详细介绍。</span><br></pre></td></tr></table></figure><p><strong>Quartz监控</strong></p><p>CRM后台目前可以做到对Quartz实例的监控、操作以及动态部署Trigger.</p><p><em>Triggers监控：</em></p><p><img src="/media/quartz%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/50ece8f3.png" alt="Quartz Triggers"></p><p>Quartz Triggers</p><p><em>JobDetails监控：</em></p><p><img src="/media/quartz%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/45e70bf3.png" alt="Quartz Jobs"></p><p>Quartz Jobs</p><h2 id="五、Quartz集群原理分析"><a href="#五、Quartz集群原理分析" class="headerlink" title="五、Quartz集群原理分析"></a>五、Quartz集群原理分析</h2><p><strong>1. Quartz集群数据库表</strong></p><p>Quartz的集群部署方案在架构上是分布式的，没有负责集中管理的节点，而是利用数据库锁的方式来实现集群环境下进行并发控制。BTW，分布式部署时需要保证各个节点的系统时间一致。</p><p>Quartz数据库核心表如下：</p><table><thead><tr><th align="left">Table Name</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">QRTZ_CALENDARS</td><td align="left">存储Quartz的Calendar信息</td></tr><tr><td align="left">QRTZ_CRON_TRIGGERS</td><td align="left">存储CronTrigger，包括Cron表达式和时区信息</td></tr><tr><td align="left">QRTZ_FIRED_TRIGGERS</td><td align="left">存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息</td></tr><tr><td align="left">QRTZ_PAUSED_TRIGGER_GRPS</td><td align="left">存储已暂停的Trigger组的信息</td></tr><tr><td align="left">QRTZ_SCHEDULER_STATE</td><td align="left">存储少量的有关Scheduler的状态信息，和别的Scheduler实例</td></tr><tr><td align="left"><strong>QRTZ_LOCKS</strong></td><td align="left"><strong>存储程序的悲观锁的信息</strong></td></tr><tr><td align="left">QRTZ_JOB_DETAILS</td><td align="left">存储每一个已配置的Job的详细信息</td></tr><tr><td align="left">QRTZ_JOB_LISTENERS</td><td align="left">存储有关已配置的JobListener的信息</td></tr><tr><td align="left">QRTZ_SIMPLE_TRIGGERS</td><td align="left">存储简单的Trigger，包括重复次数、间隔、以及已触的次数</td></tr><tr><td align="left">QRTZ_BLOG_TRIGGERS</td><td align="left">Trigger作为Blob类型存储</td></tr><tr><td align="left">QRTZ_TRIGGER_LISTENERS</td><td align="left">存储已配置的TriggerListener的信息</td></tr><tr><td align="left">QRTZ_TRIGGERS</td><td align="left">存储已配置的Trigger的信息</td></tr></tbody></table><p>其中，QRTZ_LOCKS就是Quartz集群实现同步机制的行锁表，其表结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--QRTZ_LOCKS表结构</span><br><span class="line">CREATE TABLE `QRTZ_LOCKS` (</span><br><span class="line">  `LOCK_NAME` varchar(40) NOT NULL,</span><br><span class="line">   PRIMARY KEY (`LOCK_NAME`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">--QRTZ_LOCKS记录</span><br><span class="line">+-----------------+ </span><br><span class="line">| LOCK_NAME       |</span><br><span class="line">+-----------------+ </span><br><span class="line">| CALENDAR_ACCESS |</span><br><span class="line">| JOB_ACCESS      |</span><br><span class="line">| MISFIRE_ACCESS  |</span><br><span class="line">| STATE_ACCESS    |</span><br><span class="line">| TRIGGER_ACCESS  |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><p>可以看出QRTZ_LOCKS中有5条记录，代表5把锁，分别用于实现多个Quartz Node对Job、Trigger、Calendar访问的同步控制。</p><p><strong>2. Quartz线程模型</strong></p><p>在Quartz中有两类线程：Scheduler调度线程和任务执行线程。<em>任务执行线程</em>：Quartz不会在主线程(QuartzSchedulerThread)中处理用户的Job。Quartz把线程管理的职责委托给ThreadPool，一般的设置使用SimpleThreadPool。SimpleThreadPool创建了一定数量的WorkerThread实例来使得Job能够在线程中进行处理。WorkerThread是定义在SimpleThreadPool类中的内部类，它实质上就是一个线程。例如，CRM中配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 线程池配置 --&gt;</span><br><span class="line">&lt;prop key=&quot;org.quartz.threadPool.class&quot;&gt;org.quartz.simpl.SimpleThreadPool&lt;/prop&gt;</span><br><span class="line">&lt;prop key=&quot;org.quartz.threadPool.threadCount&quot;&gt;20&lt;/prop&gt;</span><br><span class="line">&lt;prop key=&quot;org.quartz.threadPool.threadPriority&quot;&gt;5&lt;/prop&gt;</span><br></pre></td></tr></table></figure><p><em>QuartzSchedulerThread调度主线程</em>：QuartzScheduler被创建时创建一个QuartzSchedulerThread实例。</p><p><strong>3. 集群源码分析</strong></p><p>Quartz究竟是如何保证集群情况下trgger处理的信息同步？</p><p>下面跟着源码一步一步分析，QuartzSchedulerThread包含有决定何时下一个Job将被触发的处理循环，主要逻辑在其run()方法中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">   boolean lastAcquireFailed = false;</span><br><span class="line">   while (!halted.get()) &#123;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     int availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();</span><br><span class="line">     if(availThreadCount &gt; 0) &#123; </span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     //调度器在trigger队列中寻找30秒内一定数目的trigger(需要保证集群节点的系统时间一致)</span><br><span class="line">     triggers = qsRsrcs.getJobStore().acquireNextTriggers(</span><br><span class="line">                            now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     //触发trigger</span><br><span class="line">     List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);</span><br><span class="line"></span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">     //释放trigger</span><br><span class="line">     for (int i = 0; i &lt; triggers.size(); i++) &#123;</span><br><span class="line">         qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，QuartzScheduler调度线程不断获取trigger，触发trigger，释放trigger。下面分析trigger的获取过程，qsRsrcs.getJobStore()返回对象是JobStore，集群环境配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- JobStore 配置 --&gt;</span><br><span class="line">&lt;prop key=&quot;org.quartz.jobStore.class&quot;&gt;org.quartz.impl.jdbcjobstore.JobStoreTX&lt;/prop&gt;</span><br></pre></td></tr></table></figure><p>JobStoreTX继承自JobStoreSupport，而JobStoreSupport的acquireNextTriggers、triggersFired、releaseAcquiredTrigger方法负责具体trigger相关操作，都必须获得TRIGGER_ACCESS锁。核心逻辑在executeInNonManagedTXLock方法中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; T executeInNonManagedTXLock(</span><br><span class="line">        String lockName, </span><br><span class="line">        TransactionCallback&lt;T&gt; txCallback, final TransactionValidator&lt;T&gt; txValidator) throws JobPersistenceException &#123;</span><br><span class="line">    boolean transOwner = false;</span><br><span class="line">    Connection conn = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (lockName != null) &#123;</span><br><span class="line">            if (getLockHandler().requiresConnection()) &#123;</span><br><span class="line">                conn = getNonManagedTXConnection();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //获取锁</span><br><span class="line">            transOwner = getLockHandler().obtainLock(conn, lockName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (conn == null) &#123;</span><br><span class="line">            conn = getNonManagedTXConnection();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final T result = txCallback.execute(conn);</span><br><span class="line">        try &#123;</span><br><span class="line">            commitConnection(conn);</span><br><span class="line">        &#125; catch (JobPersistenceException e) &#123;</span><br><span class="line">            rollbackConnection(conn);</span><br><span class="line">            if (txValidator == null || !retryExecuteInNonManagedTXLock(lockName, new TransactionCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Boolean execute(Connection conn) throws JobPersistenceException &#123;</span><br><span class="line">                    return txValidator.validate(conn, result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)) &#123;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long sigTime = clearAndGetSignalSchedulingChangeOnTxCompletion();</span><br><span class="line">        if(sigTime != null &amp;&amp; sigTime &gt;= 0) &#123;</span><br><span class="line">            signalSchedulingChangeImmediately(sigTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (JobPersistenceException e) &#123;</span><br><span class="line">        rollbackConnection(conn);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        rollbackConnection(conn);</span><br><span class="line">        throw new JobPersistenceException(&quot;Unexpected runtime exception: &quot;</span><br><span class="line">                + e.getMessage(), e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            releaseLock(lockName, transOwner);      //释放锁</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            cleanupConnection(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上代码可知Quartz集群基于数据库锁的同步操作流程如下图所示：</p><p><img src="/media/quartz%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/05dac2dd.png" alt="Quartz集群基于锁的同步方案"></p><p>Quartz集群基于锁的同步方案</p><p>一个调度器实例在执行涉及到分布式问题的数据库操作前，首先要获取QUARTZ_LOCKS表中对应的行级锁，获取锁后即可执行其他表中的数据库操作，随着操作事务的提交，行级锁被释放，供其他调度实例获取。集群中的每一个调度器实例都遵循这样一种严格的操作规程。</p><p>getLockHandler()方法返回的对象类型是Semaphore，获取锁和释放锁的具体逻辑由该对象维护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Semaphore &#123;</span><br><span class="line"></span><br><span class="line">     boolean obtainLock(Connection conn, String lockName) throws LockException;</span><br><span class="line"></span><br><span class="line">     void releaseLock(String lockName) throws LockException;</span><br><span class="line"></span><br><span class="line">     boolean requiresConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口的实现类完成具体操作锁的逻辑，在JobStoreSupport的初始化方法中注入的Semaphore具体类型是StdRowLockSemaphore</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setLockHandler(new StdRowLockSemaphore(getTablePrefix(), getInstanceName(), getSelectWithLockSQL()));</span><br></pre></td></tr></table></figure><p>StdRowLockSemaphore的源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class StdRowLockSemaphore extends DBSemaphore &#123;</span><br><span class="line">//锁定SQL语句</span><br><span class="line">public static final String SELECT_FOR_LOCK = &quot;SELECT * FROM &quot;</span><br><span class="line">        + TABLE_PREFIX_SUBST + TABLE_LOCKS + &quot; WHERE &quot; + COL_LOCK_NAME</span><br><span class="line">        + &quot; = ? FOR UPDATE&quot;;</span><br><span class="line"></span><br><span class="line">public static final String INSERT_LOCK = &quot;INSERT INTO &quot; + TABLE_PREFIX_SUBST </span><br><span class="line">        + TABLE_LOCKS + &quot;(&quot; + COL_SCHEDULER_NAME + &quot;, &quot; </span><br><span class="line">        + COL_LOCK_NAME + &quot;) VALUES (&quot; + SCHED_NAME_SUBST + &quot;, ?)&quot;; </span><br><span class="line"></span><br><span class="line">//指定锁定SQL</span><br><span class="line">protected void executeSQL(Connection conn, String lockName, String expandedSQL) throws LockException &#123;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ps = conn.prepareStatement(expandedSQL);</span><br><span class="line">        ps.setString(1, lockName);</span><br><span class="line">        ......</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        if (!rs.next()) &#123;</span><br><span class="line">            throw new SQLException(Util.rtp(</span><br><span class="line">                &quot;No row exists in table &quot; + TABLE_PREFIX_SUBST +</span><br><span class="line">                TABLE_LOCKS + &quot; for lock named: &quot; + lockName, getTablePrefix()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (SQLException sqle) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ...... //release resources</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取QRTZ_LOCKS行级锁</span><br><span class="line">public boolean obtainLock(Connection conn, String lockName) throws LockException &#123;</span><br><span class="line">    lockName = lockName.intern();</span><br><span class="line"></span><br><span class="line">    if (!isLockOwner(conn, lockName)) &#123;</span><br><span class="line">        executeSQL(conn, lockName, expandedSQL);</span><br><span class="line"></span><br><span class="line">        getThreadLocks().add(lockName);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//释放QRTZ_LOCKS行级锁</span><br><span class="line">public void releaseLock(Connection conn, String lockName) &#123;</span><br><span class="line">    lockName = lockName.intern();</span><br><span class="line"></span><br><span class="line">    if (isLockOwner(conn, lockName)) &#123;</span><br><span class="line">        getThreadLocks().remove(lockName);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，总结一下Quartz集群同步机制：每当要进行与某种业务相关的数据库操作时，先去QRTZ_LOCKS表中查询操作相关的业务对象所需要的锁，在select语句之后加for update来实现。例如，TRIGGER_ACCESS表示对任务触发器相关的信息进行修改、删除操作时所需要获得的锁。这时，执行查询这个表数据的SQL形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from QRTZ_LOCKS t where t.lock_name=&#x27;TRIGGER_ACCESS&#x27; for update</span><br></pre></td></tr></table></figure><p>当一个线程使用上述的SQL对表中的数据执行查询操作时，若查询结果中包含相关的行，数据库就对该行进行ROW LOCK；若此时，另外一个线程使用相同的SQL对表的数据进行查询，由于查询出的数据行已经被数据库锁住了，此时这个线程就只能等待，直到拥有该行锁的线程完成了相关的业务操作，执行了commit动作后，数据库才会释放了相关行的锁，这个线程才能继续执行。</p><p>通过这样的机制，在集群环境下，结合悲观锁的机制就可以防止一个线程对数据库数据的操作的结果被另外一个线程所覆盖，从而可以避免一些难以觉察的错误发生。当然，达到这种效果的前提是需要把Connection设置为手动提交，即autoCommit为false。</p><h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><ul><li><a href="http://quartz-scheduler.org/documentation">http://quartz-scheduler.org/documentation</a> Quartz Documentation</li><li><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-quartz">http://www.ibm.com/developerworks/cn/opensource/os-cn-quartz</a> 基于Quartz开发企业级任务调度应用</li></ul><p><a href="https://tech.meituan.com/tags/quartz.html">Quartz</a>, <a href="https://tech.meituan.com/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.html">任务调度</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Quartz应用与集群原理分析&quot;&gt;&lt;a href=&quot;#Quartz应用与集群原理分析&quot; class=&quot;headerlink&quot; title=&quot;Quartz应用与集群原理分析&quot;&gt;&lt;/a&gt;Quartz应用与集群原理分析&lt;/h1&gt;&lt;h1 id=&quot;结论：&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="Quartz" scheme="http://localhost:4000/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>Quartz 现场问题分析</title>
    <link href="http://localhost:4000/2023/03/30/quartz/quartz%20%E7%8E%B0%E5%9C%BA%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://localhost:4000/2023/03/30/quartz/quartz%20%E7%8E%B0%E5%9C%BA%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2023-03-30T15:06:20.884Z</published>
    <updated>2023-03-30T14:45:18.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Quartz-现场问题分析"><a href="#Quartz-现场问题分析" class="headerlink" title="Quartz 现场问题分析"></a>Quartz 现场问题分析</h1><h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>李宁项目使用了quartz集群，支持高可用服务。</p><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>artemis系统在出库单同步接口请求了多次iwms，导致iwms系统报错，日志表现为一个定时任务本应该一分钟执行一次，但是存在一秒内执行了2次的现象，由于两个服务是交替执行所以也存在每个服务执行一次的情况。</p><p><img src="/.%5Cf%5Cmedia%5C%E7%8E%B0%E5%9C%BA%E6%97%A5%E5%BF%97.png" alt="img"></p><h1 id="问题定位："><a href="#问题定位：" class="headerlink" title="问题定位："></a>问题定位：</h1><ol><li><p>一开始怀疑是数据库不一致导致，两个服务一起执行定时任务，最后排除了数据库不一致的问题</p><p><img src="/.%5Cf%5Cmedia%5C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5.png" alt="img"></p></li><li><p>在偶然翻看定时任务时发现了问题，存在两条trigger_name一样的定时任务</p><p><img src="/.%5Cf%5Cmedia%5C%E5%AD%98%E5%9C%A8%E4%B8%A4%E6%9D%A1%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png" alt="image-20220708162904441"></p></li><li><p>在本地采用此配置成功复现了此问题</p><p><img src="/.%5Cf%5Cmedia%5C%E9%97%AE%E9%A2%98%E5%A4%8D%E7%8E%B0.png" alt="img"></p></li></ol><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><ol><li><p>artemis采用trigger_name作为triggerCode</p><img src="f\media\Artemis赋值triggercode.png" alt="image-20220708164509385" style="zoom:50%;" /></li><li><p>线程池中先获取到需要触发的trigger</p></li></ol><p><img src="/.%5Cf%5Cmedia%5C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%89%E5%8F%96trigger.png" alt="image-20220708160842046"></p><ol start="2"><li><p>等待2ms，直到到达触发时间</p><p>![image-20220708161049886](.\f\media\trigger job触发前等待.png)</p><ol start="3"><li><p>触发执行job</p><p><img src="/.%5Cf%5Cmedia%5C%E6%89%A7%E8%A1%8C.png" alt="image-20220708161120719"></p></li></ol></li></ol><h1 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h1><ol><li>quartz是通过timerConfigTask定时执行，刷新数据库中定时任务的状态配置，corn （0 0&#x2F;1 * * * ?）</li></ol><p><img src="/.%5Cf%5Cmedia%5C%E5%88%B7%E6%96%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.png" alt="image-20220708163741488"></p><ol start="2"><li>在指定出库定时任务为10 0&#x2F;1 * * * ?时，现象消失</li></ol><p><img src="/.%5Cf%5Cmedia%5C%E7%8E%B0%E8%B1%A1%E6%B6%88%E5%A4%B1.png" alt="image-20220708164020634"></p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>日志可见，删除前的任务第一次执行，删除后立马执行第二次</p><p><img src="/.%5Cf%5Cmedia%5C%E4%B8%A4%E6%AC%A1%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97.png" alt="image-20220708172158549"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>​quartz执行定时任务原理是通过quartz是通过调度线程QuartzSchedulerThread不断的扫描数据库中的数据来获取到那些已经到点要触发的任务，然后调度执行。</p><p>​数据库配置两条一样的trigger_name时，会导致qrtz_cron_triggers表这条定时任务不停的删除，新增。当出库单定时任务在一分钟执行时，已经生成jobBean放到线程池中执行，与此同时，timerConfigTask也执行，将此条定时任务删除并新增，且这条新的数据，会被调度线程再次拉取出来，生成jobBean丢到线程池中执行，导致一个定时任务出现两次。</p><p>负责任务调度的几个线程：<br> （1）任务执行线程：通常使用一个线程池(SimpleThreadPool)维护一组线程，负责实际每个job的执行。<br> （2）Scheduler调度线程QuartzSchedulerThread ：轮询存储的所有 trigger，如果有需要触发的 trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该 trigger 关联的任务。<br> （3）处理misfire job的线程MisfireHandler：轮训所有misfire的trigger，原理就是从数据库中查询所有下次触发时间小于当前时间的trigger，按照每个trigger设定的misfire策略处理这些trigger。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>删除多余配置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Quartz-现场问题分析&quot;&gt;&lt;a href=&quot;#Quartz-现场问题分析&quot; class=&quot;headerlink&quot; title=&quot;Quartz 现场问题分析&quot;&gt;&lt;/a&gt;Quartz 现场问题分析&lt;/h1&gt;&lt;h1 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; c</summary>
      
    
    
    
    
    <category term="Quartz" scheme="http://localhost:4000/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>Nginx分流(一条请求复制成多条请求)</title>
    <link href="http://localhost:4000/2023/03/29/nginx/mirror-%E4%BD%BF%E7%94%A8/"/>
    <id>http://localhost:4000/2023/03/29/nginx/mirror-%E4%BD%BF%E7%94%A8/</id>
    <published>2023-03-29T14:10:14.606Z</published>
    <updated>2023-03-30T14:30:48.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由<span class="selector-tag">A</span>服务器发送一条请求(POST)，复制成两条请求以不同的<span class="selector-tag">URL</span>同时转发给<span class="selector-tag">B</span>服务器和<span class="selector-tag">C</span>服务器。</span><br><span class="line">例子：<span class="selector-tag">A</span>发送 <span class="selector-tag">http</span>:<span class="comment">//a.com/a 经过Nginx分别向B发送 http://b.com/b 和C发送 http://c.com/c</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="谈下试错过程"><a href="#谈下试错过程" class="headerlink" title="谈下试错过程"></a>谈下试错过程</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 使用反向代理，无法复制请求</span><br><span class="line"><span class="bullet">2.</span> 使用重定向，post内容不支持，同时无法复制请求</span><br><span class="line"><span class="bullet">3.</span> 使用upstream来复制访问请求，同时给自己多个不同端口来拦截，拦截后反向代理，并没有被拦截到，这种方式属于负载均衡一类的，无法做到同时发送</span><br></pre></td></tr></table></figure><h1 id="最后方案"><a href="#最后方案" class="headerlink" title="最后方案"></a>最后方案</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用nginx提供的 mirror模块，其实这种需求有个专业的叫法：<span class="strong">**引流测试**</span>。你搜下这个就会有很多相关的文章了。</span><br></pre></td></tr></table></figure><h1 id="配置实现"><a href="#配置实现" class="headerlink" title="配置实现"></a>配置实现</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终配置也很简单，在正常的反向代理部分写上 mirror /mirror  <span class="comment">#复制子请求的拦截部分，再在下面定义另个location /mirror 即可。</span></span><br></pre></td></tr></table></figure><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">include       mime.types<span class="comment">;</span></span><br><span class="line">default_type  application/octet-stream<span class="comment">;</span></span><br><span class="line">sendfile        on<span class="comment">;</span></span><br><span class="line">keepalive_timeout  65<span class="comment">;</span></span><br><span class="line">upstream self&#123;</span><br><span class="line"><span class="comment"># 如果需要使用ip的可以反向代理时候使用这部分内容</span></span><br><span class="line">        server 192.168.0.74:8080<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       8888<span class="comment">;</span></span><br><span class="line">    server_name  a.com<span class="comment">;</span></span><br><span class="line">location /a &#123;</span><br><span class="line">                mirror /mirror<span class="comment">;</span></span><br><span class="line">                <span class="comment"># 需要放大流量 再加一个 mirror /mirror;</span></span><br><span class="line">                proxy_pass http://b.com/b<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">location</span> = /mirror &#123;</span><br><span class="line">internal<span class="comment">;</span></span><br><span class="line">proxy_pass http://c.com/c<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><ul><li>Nginx官方mirror介绍：<a href="https://nginx.org/en/docs/http/ngx_http_mirror_module.html">https://nginx.org/en/docs/http/ngx_http_mirror_module.html</a></li><li>性能工具之常见流量复制工具：<a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000039982660">https://segmentfault.com/a/1190000039982660</a></li><li>Nginx的upstream详解：<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/8671c40a5be8">www.jianshu.com/p/8671c40a5…</a></li><li>Nginx在线配置生成工具：<a href="https://link.juejin.cn/?target=https://www.nginxedit.cn/">www.nginxedit.cn/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    
    <category term="Nginx" scheme="http://localhost:4000/tags/Nginx/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Shoushi`s Notes" type="application/atom+xml" />






<meta name="description" content="只是做些力所能及的事罢了">
<meta property="og:type" content="website">
<meta property="og:title" content="Shoushi&#96;s Notes">
<meta property="og:url" content="http://localhost:4000/index.html">
<meta property="og:site_name" content="Shoushi&#96;s Notes">
<meta property="og:description" content="只是做些力所能及的事罢了">
<meta property="og:locale">
<meta property="article:author" content="liqun.guan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://localhost:4000/"/>





  <title>Shoushi`s Notes</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shoushi`s Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/me" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/16/java/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/16/java/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-16T20:20:50+08:00">
                2023-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="title-记一次Drool使用不当导致的OOM异常tag-项目实战"><a href="#title-记一次Drool使用不当导致的OOM异常tag-项目实战" class="headerlink" title="title:记一次Drool使用不当导致的OOM异常tag:项目实战"></a>title:记一次Drool使用不当导致的OOM异常<br>tag:项目实战</h2><h1 id="记一次Drool使用不当导致的OOM异常"><a href="#记一次Drool使用不当导致的OOM异常" class="headerlink" title="记一次Drool使用不当导致的OOM异常"></a>记一次Drool使用不当导致的OOM异常</h1><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>​		李宁项目属于两个服务进行集群部署，在25号时候，66，67两个ip都出现tomcat假死现象，组件日志均有打印，接口无法访问，定时任务不跑。</p>
<h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><h5 id="分析一："><a href="#分析一：" class="headerlink" title="分析一："></a>分析一：</h5><p>​		当时认为假死是程序中有死锁或者死循环之类的问题导致，但是无依据，遂让实施拉取25号的66ip的dump文件，（67的为了线上继续运行，先重启解决）。</p>
<p>​		拉取到dump文件后，先使用jdk自带的<strong>jvisualvm</strong>进行分析，看到发生了oom，报错信息如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;ARTEMIS_TASK_CLUSTER_SCHEDULER_Worker-15&quot;</span> prio=<span class="number">5</span> tid=<span class="number">100</span> RUNNABLE</span><br><span class="line">    at java.lang.OutOfMemoryError.&lt;init&gt;(OutOfMemoryError.java:<span class="number">48</span>)</span><br><span class="line">    at java.util.Arrays.copyOf(Arrays.java:<span class="number">3332</span>)</span><br><span class="line">       Local Variable: <span class="type">char</span>[]#<span class="number">1570195</span></span><br><span class="line">    at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="number">124</span>)</span><br><span class="line">    at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="number">448</span>)</span><br><span class="line">       Local Variable: java.lang.String#<span class="number">1563273</span></span><br><span class="line">    at java.lang.StringBuffer.append(StringBuffer.java:<span class="number">270</span>)</span><br><span class="line">    at java.text.MessageFormat.subformat(MessageFormat.java:<span class="number">1335</span>)</span><br><span class="line">       Local Variable: java.lang.StringBuffer#<span class="number">4</span></span><br><span class="line">       Local Variable: java.text.MessageFormat#<span class="number">3</span></span><br><span class="line">    at java.text.MessageFormat.format(MessageFormat.java:<span class="number">865</span>)</span><br><span class="line">    at java.text.Format.format(Format.java:<span class="number">157</span>)</span><br><span class="line">    at java.text.MessageFormat.format(MessageFormat.java:<span class="number">841</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.Util.rtp(Util.java:<span class="number">68</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.StdJDBCDelegate.rtp(StdJDBCDelegate.java:<span class="number">3029</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.StdJDBCDelegate.updateTriggerStatesForJobFromOtherState(StdJDBCDelegate.java:<span class="number">1513</span>)</span><br><span class="line">       Local Variable: java.lang.String#<span class="number">616911</span></span><br><span class="line">       Local Variable: org.quartz.JobKey#<span class="number">2</span></span><br><span class="line">       Local Variable: java.lang.String#<span class="number">622049</span></span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport.triggeredJobComplete(JobStoreSupport.java:<span class="number">3103</span>)</span><br><span class="line">       Local Variable: org.quartz.impl.triggers.CronTriggerImpl#<span class="number">3</span></span><br><span class="line">       Local Variable: org.quartz.impl.JobDetailImpl#<span class="number">2</span></span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport$<span class="number">45.</span>executeVoid(JobStoreSupport.java:<span class="number">3055</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport$VoidTransactionCallback.execute(JobStoreSupport.java:<span class="number">3715</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport$VoidTransactionCallback.execute(JobStoreSupport.java:<span class="number">3713</span>)</span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport.executeInNonManagedTXLock(JobStoreSupport.java:<span class="number">3799</span>)</span><br><span class="line">       Local Variable: com.sun.proxy.$Proxy1251#<span class="number">1</span></span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport.retryExecuteInNonManagedTXLock(JobStoreSupport.java:<span class="number">3754</span>)</span><br><span class="line">       Local Variable: java.lang.String#<span class="number">621730</span></span><br><span class="line">       Local Variable: org.springframework.scheduling.quartz.LocalDataSourceJobStore#<span class="number">1</span></span><br><span class="line">       Local Variable: org.quartz.impl.jdbcjobstore.JobStoreSupport$<span class="number">45</span>#<span class="number">1</span></span><br><span class="line">    at org.quartz.impl.jdbcjobstore.JobStoreSupport.triggeredJobComplete(JobStoreSupport.java:<span class="number">3051</span>)</span><br><span class="line">    at org.quartz.core.QuartzScheduler.notifyJobStoreJobComplete(QuartzScheduler.java:<span class="number">1804</span>)</span><br><span class="line">    at org.quartz.core.JobRunShell.run(JobRunShell.java:<span class="number">269</span>)</span><br><span class="line">       Local Variable: org.quartz.core.JobRunShell#<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>经过查看代码分析，此处就是一个简单的quartz集群的查询字符串，不可能过大导致内存溢出，排除。</p>
<h5 id="分析二："><a href="#分析二：" class="headerlink" title="分析二："></a>分析二：</h5><p>​		经过jvisualvm查看，确实存在较大的内存占用，但是不直观，具体不明，查资料得知一个很强大👍的工具<strong>MAT</strong>。</p>
<p>​		MAT依赖于jdk11，此外需要修改MemoryAnalyzer.ini文件，指定jdk路径以及加大内存。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-startup</span><br><span class="line">plugins/org.eclipse.equinox.launcher_1.6.400.v20210924-0641.jar</span><br><span class="line">-vm</span><br><span class="line">C:\Program Files\Java\jdk-11\bin\javaw.exe</span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.2.400.v20211117-0650</span><br><span class="line">-vmargs</span><br><span class="line">-Xmx4g</span><br></pre></td></tr></table></figure>

<p>​		1.将dump文件导入MAT，分析得到饼状图，看到有一个占据这3.1GB的大对象存活</p>
<img src="media/解决drools使用不当导致的oom/image-20230307132550052.png" alt="image-20230307132550052" style="zoom: 50%;" />

<p>​		2. 点击查看Dominator Tree，查看大对象<img src="/media/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/image-20230307132715519.png" alt="image-20230307132715519"></p>
<ol start="3">
<li><p>查看定位到大对象是和drools相关的statefulSeesions,属于kieBaseMap内置的一个HashSet.</p>
<p><img src="/media/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/image-20230307133023685.png" alt="image-20230307133023685"></p>
</li>
<li><p>大对象定位到后进行代码分析</p>
<p>drools有状态会话时，必须调用dispose()方法，以确保没有内存泄漏。代码中相关dispose的调用在执行规则后调用，当kieSession.fireAllRules();出错时，即规则代码出错时，会抛异常跳出当前方法而导致跳过dispose（）方法的调用，发生内存泄露。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">helperList</span><span class="params">(String key, List&lt;Object&gt; gList)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">KieSession</span> <span class="variable">kieSession</span> <span class="operator">=</span> getSession(key);</span><br><span class="line">        kieSession.setGlobal(GLOB_LIST, gList);</span><br><span class="line">        kieSessionSetGlobalServiceList(key,kieSession);</span><br><span class="line">        kieSession.fireAllRules();</span><br><span class="line">        kieSession.dispose();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证，若出现大量的异常，则会在外层被catch住进行日志输出。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title function_">droolsHelperListByKey</span><span class="params">(String key, Object... objects)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; gList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        gList.addAll(Arrays.asList(objects));</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isEmpty(key) || CollectionUtil.isEmpty(kieBaseMap) || CollectionUtil.isEmpty(ruleMap)) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;droolsHelperListByKey drools getRule is empty key:[&#123;&#125;]&quot;</span>, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                helperList(key, gList);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;droolsHelperListByKey error :&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>日志搜索：</p>
<p><img src="/media/%E8%A7%A3%E5%86%B3drools%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84oom/image-20230307133559960.png" alt="image-20230307133559960"></p>
<p>至此，分析结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于资源类的数据，务必要保证资源的释放操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/16/java/volitile%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/16/java/volitile%E8%AF%A6%E8%A7%A3/" itemprop="url">Volatile 详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-16T20:19:06+08:00">
                2023-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java中Volatile关键字详解"><a href="#Java中Volatile关键字详解" class="headerlink" title="Java中Volatile关键字详解"></a>Java中Volatile关键字详解</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a><strong>一、基本概念</strong></h2><hr>
<h3 id="先补充一下概念：Java-内存模型中的可见性、原子性和有序性。"><a href="#先补充一下概念：Java-内存模型中的可见性、原子性和有序性。" class="headerlink" title="先补充一下概念：Java 内存模型中的可见性、原子性和有序性。"></a><strong>先补充一下概念：Java 内存模型中的可见性、原子性和有序性。</strong></h3><p><strong>可见性：</strong></p>
<p>　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p>
<p>　　<strong>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</strong>也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a &#x3D; 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p>
<p>　　在 Java 中 volatile、synchronized 和 final 实现可见性。</p>
<p><strong>原子性：</strong></p>
<p>　　<strong>原子是世界上的最小单位，具有不可分割性。</strong>比如 a&#x3D;0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a &#x3D; a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p>
<p>　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p>
<p><strong>有序性：</strong></p>
<p>　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>
<p><strong>下面内容摘录自《Java Concurrency in Practice》：</strong></p>
<p>　　下面一段代码在多线程环境下，将存在问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 1 /**</span><br><span class="line"> 2  * @author zhengbinMac</span><br><span class="line"> 3  */</span><br><span class="line"> 4 public class NoVisibility &#123;</span><br><span class="line"> 5     private static boolean ready;</span><br><span class="line"> 6     private static int number;</span><br><span class="line"> 7     private static class ReaderThread extends Thread &#123;</span><br><span class="line"> 8         @Override</span><br><span class="line"> 9         public void run() &#123;</span><br><span class="line">10             while(!ready) &#123;</span><br><span class="line">11                 Thread.yield();</span><br><span class="line">12             &#125;</span><br><span class="line">13             System.out.println(number);</span><br><span class="line">14         &#125;</span><br><span class="line">15     &#125;</span><br><span class="line">16     public static void main(String[] args) &#123;</span><br><span class="line">17         new ReaderThread().start();</span><br><span class="line">18         number = 42;</span><br><span class="line">19         ready = true;</span><br><span class="line">20     &#125;</span><br><span class="line">21 &#125;</span><br></pre></td></tr></table></figure>

<p>　　NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p>
<p>　　在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行春旭进行判断，无法得到正确的结论。</p>
<p>　　这个看上去像是一个失败的设计，但却能使JVM充分地利用现代多核处理器的强大性能。例如，在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并将数值缓存在处理器特定的缓存中。</p>
<h2 id="二、Volatile原理"><a href="#二、Volatile原理" class="headerlink" title="二、Volatile原理"></a>二、Volatile原理</h2><hr>
<p>　　Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p>
<p>　　在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p>
<p><img src="/media/volitile%E8%AF%A6%E8%A7%A3/731716-20160708224602686-2141387366.png" alt="img"></p>
<p>　　当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p>
<p>　　而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p>
<h3 id="当一个变量定义为-volatile-之后，将具备两种特性："><a href="#当一个变量定义为-volatile-之后，将具备两种特性：" class="headerlink" title="当一个变量定义为 volatile 之后，将具备两种特性："></a>当一个变量定义为 volatile 之后，将具备两种特性：</h3><p>　　1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhengbin/p/6407137.html">Java内存模型</a>）来完成。</p>
<p>　　2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个<strong>内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</p>
<h3 id="volatile-性能："><a href="#volatile-性能：" class="headerlink" title="volatile 性能："></a>volatile 性能：</h3><p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/12/java/G1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/12/java/G1/" itemprop="url">G1详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-12T21:31:29+08:00">
                2023-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>Garbage First(G1)是垃圾收集领域的最新成果，同时也是HotSpot在JVM上力推的垃圾收集器，并赋予取代CMS的使命。如果使用Java 8&#x2F;9，那么有很大可能希望对G1收集器进行评估。本文详细首先对JVM其他的垃圾收集器进行总结，并与G1进行了简单的对比；然后通过G1的内存模型、G1的活动周期，对G1的工作机制进行了介绍；同时还在介绍过程中，描述了可能需要引起注意的优化点。笔者希望通过本文，让有一定JVM基础的读者能尽快掌握G1的知识点。<strong>另，本文较长，建议收藏阅读。</strong></p>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a><strong>第一章 概述</strong></h2><p>G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。G1最大的特点是引入分区的思路，弱化了分代的概念，合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。</p>
<h2 id="第二章-JVM-GC收集器的回顾与比较"><a href="#第二章-JVM-GC收集器的回顾与比较" class="headerlink" title="第二章 JVM GC收集器的回顾与比较"></a><strong>第二章 JVM GC收集器的回顾与比较</strong></h2><p><img src="/media/G1/1620.jpeg" alt="img"></p>
<p>从JDK3(1.3)开始，HotSpot团队一直努力朝着高效收集、减少停顿(STW: Stop The World)的方向努力，也贡献了从串行到CMS乃至最新的G1在内的一系列优秀的垃圾收集器。上图展示了JDK的垃圾回收大家庭，以及相互之间的组合关系，下面就几种典型的组合应用进行简单的介绍。</p>
<h3 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a><strong>串行收集器</strong></h3><p><img src="/media/G1/1620-16620838632904.jpeg" alt="img"></p>
<p>串行收集器组合 Serial + Serial Old</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启选项：-<span class="attr">XX</span>:+<span class="title class_">SerialGC</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>串行收集器是最基本、发展时间最长、久经考验的垃圾收集器，也是client模式下的默认收集器配置。  串行收集器采用单线程stop-the-world的方式进行收集。当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点(Safepoint)时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存。单线程也意味着复杂度更低、占用内存更少，但同时也意味着不能有效利用多核优势。事实上，串行收集器特别适合堆内存不高、单核甚至双核CPU的场合。</p>
<h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a><strong>并行收集器</strong></h3><p><img src="/media/G1/1620-16620838632905.jpeg" alt="img"></p>
<p>并行收集器组合 Parallel Scavenge + Parallel Old</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启选项：-<span class="attr">XX</span>:+<span class="title class_">UseParallelGC</span>或-<span class="attr">XX</span>:+<span class="title class_">UseParallelOldGC</span>(可互相激活)</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>并行收集器是以关注吞吐量为目标的垃圾收集器，也是server模式下的默认收集器配置，对吞吐量的关注主要体现在年轻代Parallel Scavenge收集器上。</p>
<p>并行收集器与串行收集器工作模式相似，都是stop-the-world方式，只是暂停时并行地进行垃圾收集。年轻代采用复制算法，老年代采用标记-整理，在回收的同时还会对内存进行压缩。关注吞吐量主要指年轻代的Parallel Scavenge收集器，通过两个目标参数-XX:MaxGCPauseMills和-XX:GCTimeRatio，调整新生代空间大小，来降低GC触发的频率。并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</p>
<h3 id="并发标记清除收集器"><a href="#并发标记清除收集器" class="headerlink" title="并发标记清除收集器"></a><strong>并发标记清除收集器</strong></h3><p><img src="/media/G1/1620-16620838632906.jpeg" alt="img"></p>
<p>并发标记清除收集器组合 ParNew + CMS + Serial Old</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启选项：-<span class="attr">XX</span>:+<span class="title class_">UseConcMarkSweepGC</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>并发标记清除(CMS)是以关注延迟为目标、十分优秀的垃圾回收算法，开启后，年轻代使用STW式的并行收集，老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现在老年代CMS上。</p>
<p>年轻代ParNew与并行收集器类似，而老年代CMS每个收集周期都要经历：初始标记、并发标记、重新标记、并发清除。其中，初始标记以STW的方式标记所有的根对象；并发标记则同应用线程一起并行，标记出根对象的可达路径；在进行垃圾回收前，CMS再以一个STW进行重新标记，标记那些由mutator线程(指引起数据变化的线程，即应用线程)修改而可能错过的可达对象；最后得到的不可达对象将在并发清除阶段进行回收。值得注意的是，初始标记和重新标记都已优化为多线程执行。CMS非常适合堆内存大、CPU核数多的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>端应用，也是G1出现之前大型应用的首选收集器。</p>
<p>但是CMS并不完美，它有以下缺点：</p>
<ol>
<li>由于并发进行，CMS在收集与应用线程会同时会增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间；</li>
<li>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，进行一次压缩的Full GC。</li>
</ol>
<h3 id="Garbage-First"><a href="#Garbage-First" class="headerlink" title="Garbage First"></a><strong>Garbage First</strong></h3><p><img src="/media/G1/1620-16620838632917.jpeg" alt="img"></p>
<p>Garbage First (G1)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启选项：-<span class="attr">XX</span>:+<span class="title class_">UseG1GC</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>之前介绍的几组垃圾收集器组合，都有几个共同点：</p>
<ul>
<li>年轻代、老年代是独立且连续的内存块；</li>
<li>年轻代收集使用单eden、双survivor进行复制算法；</li>
<li>老年代收集必须扫描整个老年代区域；</li>
<li>都是以尽可能少而块地执行GC为设计原则。</li>
</ul>
<p>G1垃圾收集器也是以关注延迟为目标、服务器端应用的垃圾收集器，被HotSpot团队寄予取代CMS的使命，也是一个非常具有调优潜力的垃圾收集器。虽然G1也有类似CMS的收集动作：初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。事实上，G1收集与以上三组收集器有很大不同：</p>
<ol>
<li>G1的设计原则是”首先收集尽可能多的垃圾(Garbage First)”。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；</li>
<li>G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；</li>
<li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；</li>
<li>G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</li>
</ol>
<h2 id="第三章-G1的内存模型"><a href="#第三章-G1的内存模型" class="headerlink" title="第三章 G1的内存模型"></a><strong>第三章 G1的内存模型</strong></h2><h3 id="分区概念"><a href="#分区概念" class="headerlink" title="分区概念"></a><strong>分区概念</strong></h3><p><img src="/media/G1/1620-16620838632918.jpeg" alt="img"></p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a><strong>分区</strong></h4><p>分区 Region</p>
<p>G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize&#x3D;n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p>
<h4 id="卡片"><a href="#卡片" class="headerlink" title="卡片"></a><strong>卡片</strong></h4><p>卡片 Card</p>
<p>在每个分区内部又被分成了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h4><p>堆 Heap</p>
<p>G1同样可以通过-Xms&#x2F;-Xmx来指定堆空间大小。当发生年轻代收集或混合收集时，通过计算GC与应用的耗费时间比，自动调整堆空间大小。如果GC频率太高，则通过增加堆尺寸，来减少GC频率，相应地GC占用的时间也随之降低；目标参数-XX:GCTimeRatio即为GC与应用的耗费时间比，G1默认为9，而CMS默认为99，因为CMS的设计原则是耗费在GC上的时间尽可能的少。另外，当空间不足，如对象空间分配或转移失败时，G1会首先尝试增加堆空间，如果扩容失败，则发起担保的Full GC。Full GC后，堆尺寸计算结果也会调整堆空间。</p>
<h3 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a><strong>分代模型</strong></h3><h4 id="分代"><a href="#分代" class="headerlink" title="分代"></a><strong>分代</strong></h4><p><img src="/media/G1/1620-16620838632919.jpeg" alt="img"></p>
<p>分代 Generation</p>
<p>分代垃圾收集可以将关注点集中在最近被分配的对象上，而无需整堆扫描，避免长命对象的拷贝，同时独立收集有助于降低响应时间。虽然分区使得内存分配不再要求紧凑的内存空间，但G1依然使用了分代的思想。与其他垃圾收集器类似，G1将内存在逻辑上划分为年轻代和老年代，其中年轻代又划分为Eden空间和Survivor空间。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间。</p>
<p>整个年轻代内存会在初始空间-XX:G1NewSizePercent(默认整堆5%)与最大空间-XX:G1MaxNewSizePercent(默认60%)之间动态变化，且由参数目标暂停时间-XX:MaxGCPauseMillis(默认200ms)、需要扩缩容的大小以及分区的已记忆集合(RSet)计算得到。当然，G1依然可以设置固定的年轻代大小(参数-XX:NewRatio、-Xmn)，但同时暂停目标将失去意义。</p>
<h4 id="本地分配缓冲"><a href="#本地分配缓冲" class="headerlink" title="本地分配缓冲"></a><strong>本地分配缓冲</strong></h4><p>本地分配缓冲 Local allocation buffer (Lab)</p>
<p>值得注意的是，由于分区的思想，每个线程均可以”认领”某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和GC线程都会独立的使用分区，进而减少同步时间，提升GC效率，这个分区称为本地分配缓冲区(Lab)。</p>
<p>其中，应用线程可以独占一个本地缓冲区(TLAB)来创建的对象，而大部分都会落入Eden区域(巨型对象或分配失败除外)，因此TLAB的分区属于Eden空间；而每次垃圾收集时，每个GC线程同样可以独占一个本地缓冲区(GCLAB)用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；对于从Eden&#x2F;Survivor空间晋升(Promotion)到Survivor&#x2F;老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(PLAB)。</p>
<h4 id="分区模型"><a href="#分区模型" class="headerlink" title="分区模型"></a><strong>分区模型</strong></h4><p>G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。</p>
<p><img src="/media/G1/1620-166208386329110.jpeg" alt="img"></p>
<h4 id="巨型对象"><a href="#巨型对象" class="headerlink" title="巨型对象"></a><strong>巨型对象</strong></h4><p>巨型对象 Humongous Region</p>
<p>一个大小达到甚至超过分区大小一半的对象称为巨型对象(Humongous Object)。当线程为巨型分配空间时，不能简单在TLAB进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(Humongous Region)。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。</p>
<p>巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为开始巨型(StartsHumongous)，相邻连续分区被标记为连续巨型(ContinuesHumongous)。由于无法享受Lab带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象。</p>
<h4 id="已记忆集合"><a href="#已记忆集合" class="headerlink" title="已记忆集合"></a><strong>已记忆集合</strong></h4><p>已记忆集合 Remember Set (RSet)</p>
<p>在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p>
<p>事实上，并非所有的引用都需要记录在RSet中，如果一个分区确定需要扫描，那么无需RSet也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入RSet中；同时，G1 GC每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在RSet中记录。最后只有老年代的分区可能会有RSet记录，这些分区称为拥有RSet分区(an RSet’s owning region)。</p>
<h4 id="Per-Region-Table"><a href="#Per-Region-Table" class="headerlink" title="Per Region Table"></a><strong>Per Region Table</strong></h4><p>Per Region Table (PRT)</p>
<p>RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常”受欢迎”，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：</p>
<p>稀少：直接记录引用对象的卡片索引 细粒度：记录引用对象的分区索引 粗粒度：只记录引用情况，每个分区对应一个比特位 由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的。</p>
<p>收集集合 (CSet)</p>
<p><img src="/media/G1/1620-166208386329111.jpeg" alt="img"></p>
<p>收集集合 CSet</p>
<p>收集集合(CSet)代表每次GC暂停时回收的一系列目标分区。在任意一次收集暂停中，CSet所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。</p>
<p>候选老年代分区的CSet准入条件，可以通过活跃度阈值-XX:G1MixedGCLiveThresholdPercent(默认85%)进行设置，从而拦截那些回收开销巨大的对象；同时，每次混合收集可以包含候选老年代分区，可根据CSet对堆的总大小占比-XX:G1OldCSetRegionThresholdPercent(默认10%)设置数量上限。</p>
<p>由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。</p>
<h3 id="年轻代收集集合"><a href="#年轻代收集集合" class="headerlink" title="年轻代收集集合"></a><strong>年轻代收集集合</strong></h3><p>年轻代收集集合 CSet of Young Collection</p>
<p>应用线程不断活动后，年轻代空间会被逐渐填满。<strong>当JVM分配对象到Eden区域失败(Eden区已满)时</strong>，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。</p>
<p>同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、Survivor尺寸、Survivor填充容量-XX:TargetSurvivorRatio(默认50%)、最大任期阈值-XX:MaxTenuringThreshold(默认15)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p>
<h4 id="混合收集集合"><a href="#混合收集集合" class="headerlink" title="混合收集集合"></a><strong>混合收集集合</strong></h4><p>混合收集集合 CSet of Mixed Collection</p>
<p>年轻代收集不断活动后，老年代的空间也会被逐渐填充。<strong>当老年代占用空间超过整堆比IHOP阈值-XX:InitiatingHeapOccupancyPercent(默认45%)时</strong>，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似。</p>
<p>为了确定包含到年轻代收集集合CSet的老年代分区，JVM通过参数混合周期的最大总次数-XX:G1MixedGCCountTarget(默认8)、堆废物百分比-XX:G1HeapWastePercent(默认5%)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。</p>
<h2 id="第四章-G1的活动周期"><a href="#第四章-G1的活动周期" class="headerlink" title="第四章 G1的活动周期"></a><strong>第四章 G1的活动周期</strong></h2><h3 id="G1垃圾收集活动汇总"><a href="#G1垃圾收集活动汇总" class="headerlink" title="G1垃圾收集活动汇总"></a><strong>G1垃圾收集活动汇总</strong></h3><p><img src="/media/G1/1620-166208386329112.jpeg" alt="img"></p>
<h3 id="RSet的维护"><a href="#RSet的维护" class="headerlink" title="RSet的维护"></a><strong>RSet的维护</strong></h3><p>由于不能整堆扫描，又需要计算分区确切的活跃度，因此，G1需要一个增量式的完全标记并发算法，通过维护RSet，得到准确的分区引用信息。在G1中，RSet的维护主要来源两个方面：写栅栏(Write Barrier)和并发优化线程(Concurrence Refinement Threads)</p>
<h4 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a><strong>栅栏</strong></h4><p><img src="/media/G1/1620-166208386329113.jpeg" alt="img"></p>
<h4 id="栅栏-Barrier"><a href="#栅栏-Barrier" class="headerlink" title="栅栏 Barrier"></a><strong>栅栏 Barrier</strong></h4><p>我们首先介绍一下栅栏(Barrier)的概念。栅栏是指在原生代码片段中，当某些语句被执行时，栅栏代码也会被执行。而G1主要在赋值语句中，使用写前栅栏(Pre-Write Barrrier)和写后栅栏(Post-Write Barrrier)。事实上，写栅栏的指令序列开销非常昂贵，应用吞吐量也会根据栅栏复杂度而降低。</p>
<h4 id="写前栅栏-Pre-Write-Barrrier"><a href="#写前栅栏-Pre-Write-Barrrier" class="headerlink" title="写前栅栏 Pre-Write Barrrier"></a><strong>写前栅栏 Pre-Write Barrrier</strong></h4><p>即将执行一段赋值语句时，等式左侧对象将修改引用到另一个对象，那么等式左侧对象原先引用的对象所在分区将因此丧失一个引用，那么JVM就需要在赋值语句生效之前，记录丧失引用的对象。JVM并不会立即维护RSet，而是通过批量处理，在将来RSet更新(见SATB)。</p>
<h4 id="写后栅栏-Post-Write-Barrrier"><a href="#写后栅栏-Post-Write-Barrrier" class="headerlink" title="写后栅栏 Post-Write Barrrier"></a><strong>写后栅栏 Post-Write Barrrier</strong></h4><p>当执行一段赋值语句后，等式右侧对象获取了左侧对象的引用，那么等式右侧对象所在分区的RSet也应该得到更新。同样为了降低开销，写后栅栏发生后，RSet也不会立即更新，同样只是记录此次更新日志，在将来批量处理(见Concurrence Refinement Threads)。</p>
<h3 id="起始快照算法"><a href="#起始快照算法" class="headerlink" title="起始快照算法"></a><strong>起始快照算法</strong></h3><p>起始快照算法 Snapshot at the beginning (SATB)</p>
<p>Taiichi Tuasa贡献的增量式完全并发标记算法起始快照算法(SATB)，主要针对标记-清除垃圾收集器的并发标记阶段，非常适合G1的分区块的堆结构，同时解决了CMS的主要烦恼：重新标记暂停时间长带来的潜在风险。</p>
<p>SATB会创建一个对象图，相当于堆的逻辑快照，从而确保并发标记阶段所有的垃圾对象都能通过快照被鉴别出来。当赋值语句发生时，应用将会改变了它的对象图，那么JVM需要记录被覆盖的对象。因此写前栅栏会在引用变更前，将值记录在SATB日志或缓冲区中。每个线程都会独占一个SATB缓冲区，初始有256条记录空间。当空间用尽时，线程会分配新的SATB缓冲区继续使用，而原有的缓冲去则加入全局列表中。最终在并发标记阶段，并发标记线程(Concurrent Marking Threads)在标记的同时，还会定期检查和处理全局缓冲区列表的记录，然后根据标记位图分片的标记位，扫描引用字段来更新RSet。此过程又称为并发标记&#x2F;SATB写前栅栏。</p>
<h3 id="并发优化线程"><a href="#并发优化线程" class="headerlink" title="并发优化线程"></a><strong>并发优化线程</strong></h3><p>并发优化线程 Concurrence Refinement Threads</p>
<p>G1中使用基于Urs Hölzle的快速写栅栏，将栅栏开销缩减到2个额外的指令。栅栏将会更新一个card table type的结构来跟踪代间引用。</p>
<p>当赋值语句发生后，写后栅栏会先通过G1的过滤技术判断是否是跨分区的引用更新，并将跨分区更新对象的卡片加入缓冲区序列，即更新日志缓冲区或脏卡片队列。与SATB类似，一旦日志缓冲区用尽，则分配一个新的日志缓冲区，并将原来的缓冲区加入全局列表中。</p>
<p>并发优化线程(Concurrence Refinement Threads)，只专注扫描日志缓冲区记录的卡片来维护更新RSet，线程最大数目可通过-XX:G1ConcRefinementThreads(默认等于-XX:ParellelGCThreads)设置。并发优化线程永远是活跃的，一旦发现全局列表有记录存在，就开始并发处理。如果记录增长很快或者来不及处理，那么通过阈值-X:G1ConcRefinementGreenZone&#x2F;-XX:G1ConcRefinementYellowZone&#x2F;-XX:G1ConcRefinementRedZone，G1会用分层的方式调度，使更多的线程处理全局列表。如果并发优化线程也不能跟上缓冲区数量，则Mutator线程(Java应用线程)会挂起应用并被加进来帮助处理，直到全部处理完。因此，必须避免此类场景出现。</p>
<h3 id="并发标记周期"><a href="#并发标记周期" class="headerlink" title="并发标记周期"></a><strong>并发标记周期</strong></h3><p>并发标记周期 Concurrent Marking Cycle</p>
<p>并发标记周期是G1中非常重要的阶段，这个阶段将会为混合收集周期识别垃圾最多的老年代分区。整个周期完成根标记、识别所有(可能)存活对象，并计算每个分区的活跃度，从而确定GC效率等级。</p>
<p>当达到IHOP阈值-XX:InitiatingHeapOccupancyPercent(老年代占整堆比，默认45%)时，便会触发并发标记周期。整个并发标记周期将由初始标记(Initial Mark)、根分区扫描(Root Region Scanning)、并发标记(Concurrent Marking)、重新标记(Remark)、清除(Cleanup)几个阶段组成。其中，初始标记(随年轻代收集一起活动)、重新标记、清除是STW的，而并发标记如果来不及标记存活对象，则可能在并发标记过程中，G1又触发了几次年轻代收集。</p>
<h3 id="并发标记线程"><a href="#并发标记线程" class="headerlink" title="并发标记线程"></a><strong>并发标记线程</strong></h3><p>并发标记线程 Concurrent Marking Threads</p>
<p><img src="/media/G1/1620-166208386329114.jpeg" alt="img"></p>
<p>要标记存活的对象，每个分区都需要创建位图(Bitmap)信息来存储标记数据，来确定标记周期内被分配的对象。G1采用了两个位图Previous Bitmap、Next Bitmap，来存储标记数据，Previous位图存储上次的标记数据，Next位图在标记周期内不断变化更新，同时Previous位图的标记数据也越来越过时，当标记周期结束后Next位图便替换Previous位图，成为上次标记的位图。同时，每个分区通过顶部开始标记(TAMS)，来记录已标记过的内存范围。同样的，G1使用了两个顶部开始标记Previous TAMS(PTAMS)、Next TAMS(NTAMS)，记录已标记的范围。</p>
<p>在并发标记阶段，G1会根据参数-XX:ConcGCThreads(默认GC线程数的1&#x2F;4，即-XX:ParallelGCThreads&#x2F;4)，分配并发标记线程(Concurrent Marking Threads)，进行标记活动。每个并发线程一次只扫描一个分区，并通过”手指”指针的方式优化获取分区。并发标记线程是爆发式的，在给定的时间段拼命干活，然后休息一段时间，再拼命干活。</p>
<p>每个并发标记周期，在初始标记STW的最后，G1会分配一个空的Next位图和一个指向分区顶部(Top)的NTAMS标记。Previous位图记录的上次标记数据，上次的标记位置，即PTAMS，在PTAMS与分区底部(Bottom)的范围内，所有的存活对象都已被标记。那么，在PTAMS与Top之间的对象都将是隐式存活(Implicitly Live)对象。在并发标记阶段，Next位图吸收了Previous位图的标记数据，同时每个分区都会有新的对象分配，则Top与NTAMS分离，前往更高的地址空间。在并发标记的一次标记中，并发标记线程将找出NTAMS与PTAMS之间的所有存活对象，将标记<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdcs?from=10680">数据存储</a>在Next位图中。同时，在NTAMS与Top之间的对象即成为已标记对象。如此不断地更新Next位图信息，并在清除阶段与Previous位图交换角色。</p>
<h4 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a><strong>初始标记</strong></h4><p>初始标记 Initial Mark</p>
<p>初始标记(Initial Mark)负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要将Mutator线程(Java应用线程)暂停掉，也就是需要一个STW的时间段。事实上，当达到IHOP阈值时，G1并不会立即发起并发标记周期，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为借道(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，初始标记是并发执行，直到所有的分区处理完。</p>
<h4 id="根分区扫描"><a href="#根分区扫描" class="headerlink" title="根分区扫描"></a><strong>根分区扫描</strong></h4><p>根分区扫描 Root Region Scanning</p>
<p>在初始标记暂停结束后，年轻代收集也完成的对象复制到Survivor的工作，应用线程开始活跃起来。此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描(Root Region Scanning)，同时扫描的Suvivor分区也被称为根分区(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</p>
<h4 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a><strong>并发标记</strong></h4><p>并发标记 Concurrent Marking</p>
<p>和应用线程并发执行，并发标记线程在并发标记阶段启动，由参数-XX:ConcGCThreads(默认GC线程数的1&#x2F;4，即-XX:ParallelGCThreads&#x2F;4)控制启动数量，每个线程每次只扫描一个分区，从而标记出存活对象图。在这一阶段会处理Previous&#x2F;Next标记位图，扫描标记对象的引用字段。同时，并发标记线程还会定期检查和处理STAB全局缓冲区列表的记录，更新对象引用信息。参数-XX:+ClassUnloadingWithConcurrentMark会开启一个优化，如果一个类不可达(不是对象不可达)，则在重新标记阶段，这个类就会被直接卸载。所有的标记任务必须在堆满前就完成扫描，如果并发标记耗时很长，那么有可能在并发标记过程中，又经历了几次年轻代收集。如果堆满前没有完成标记任务，则会触发担保机制，经历一次长时间的串行Full GC。</p>
<h4 id="存活数据计算"><a href="#存活数据计算" class="headerlink" title="存活数据计算"></a><strong>存活数据计算</strong></h4><p>存活数据计算 Live Data Accounting</p>
<p>存活数据计算(Live Data Accounting)是标记操作的附加产物，只要一个对象被标记，同时会被计算字节数，并计入分区空间。只有NTAMS以下的对象会被标记和计算，在标记周期的最后，Next位图将被清空，等待下次标记周期。</p>
<h4 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a><strong>重新标记</strong></h4><p>重新标记 Remark</p>
<p>重新标记(Remark)是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。这个阶段也是并行执行的，通过参数-XX:ParallelGCThread可设置GC暂停时可用的GC线程数。同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</p>
<h4 id="清除"><a href="#清除" class="headerlink" title="清除"></a><strong>清除</strong></h4><p>清除 Cleanup</p>
<p>紧挨着重新标记阶段的清除(Clean)阶段也是STW的。Previous&#x2F;Next标记位图、以及PTAMS&#x2F;NTAMS，都会在清除阶段交换角色。清除阶段主要执行以下操作：</p>
<p>RSet梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数-XX:+PrintAdaptiveSizePolicy可以开启打印启发式算法决策细节； 整理堆分区，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合； 识别所有空闲分区，即发现无存活对象的分区。该分区可在清除阶段直接回收，无需等待下次收集周期。</p>
<h3 id="年轻代收集-x2F-混合收集周期"><a href="#年轻代收集-x2F-混合收集周期" class="headerlink" title="年轻代收集&#x2F;混合收集周期"></a><strong>年轻代收集&#x2F;混合收集周期</strong></h3><p>年轻代收集和混合收集周期，是G1回收空间的主要活动。当应用运行开始时，堆内存可用空间还比较大，只会在年轻代满时，触发年轻代收集；随着老年代内存增长，当到达IHOP阈值-XX:InitiatingHeapOccupancyPercent(老年代占整堆比，默认45%)时，G1开始着手准备收集老年代空间。首先经历并发标记周期，识别出高收益的老年代分区，前文已述。但随后G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集。在这次STW中，G1将保准整理混合收集周期。接着再次让应用线程运行，当接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集，这些连续多次的混合收集称为混合收集周期(Mixed Collection Cycle)。</p>
<h4 id="GC工作线程数"><a href="#GC工作线程数" class="headerlink" title="GC工作线程数"></a><strong>GC工作线程数</strong></h4><p>GC工作线程数 -XX:ParallelGCThreads</p>
<p>JVM可以通过参数-XX:ParallelGCThreads进行指定GC工作的线程数量。参数-XX:ParallelGCThreads默认值并不是固定的，而是根据当前的CPU资源进行计算。如果用户没有指定，且CPU小于等于8，则默认与CPU核数相等；若CPU大于8，则默认JVM会经过计算得到一个小于CPU核数的线程数；当然也可以人工指定与CPU核数相等。</p>
<h4 id="年轻代收集"><a href="#年轻代收集" class="headerlink" title="年轻代收集"></a><strong>年轻代收集</strong></h4><p>年轻代收集 Young Collection</p>
<p>每次收集过程中，既有并行执行的活动，也有串行执行的活动，但都可以是多线程的。在并行执行的任务中，如果某个任务过重，会导致其他线程在等待某项任务的处理，需要对这些地方进行优化。</p>
<h4 id="并行活动"><a href="#并行活动" class="headerlink" title="并行活动"></a><strong>并行活动</strong></h4><p>外部根分区扫描 Ext Root Scanning：此活动对堆外的根(JVM系统目录、VM数据结构、JNI线程句柄、硬件寄存器、全局变量、线程对栈根)进行扫描，发现那些没有加入到暂停收集集合CSet中的对象。如果系统目录(单根)拥有大量加载的类，最终可能其他并行活动结束后，该活动依然没有结束而带来的等待时间。</p>
<p>更新已记忆集合 Update RS：并发优化线程会对脏卡片的分区进行扫描更新日志缓冲区来更新RSet，但只会处理全局缓冲列表。作为补充，所有被记录但是还没有被优化线程处理的剩余缓冲区，会在该阶段处理，变成已处理缓冲区(Processed Buffers)。为了限制花在更新RSet的时间，可以设置暂停占用百分比-XX:G1RSetUpdatingPauseTimePercent(默认10%，即-XX:MaxGCPauseMills&#x2F;10)。值得注意的是，如果更新日志缓冲区更新的任务不降低，单纯地减少RSet的更新时间，会导致暂停中被处理的缓冲区减少，将日志缓冲区更新工作推到并发优化线程上，从而增加对Java应用线程资源的争夺。</p>
<p>RSet扫描 Scan RS：在收集当前CSet之前，考虑到分区外的引用，必须扫描CSet分区的RSet。如果RSet发生粗化，则会增加RSet的扫描时间。开启诊断模式-XX:UnlockDiagnosticVMOptions后，通过参数-XX:+G1SummarizeRSetStats可以确定并发优化线程是否能够及时处理更新日志缓冲区，并提供更多的信息，来帮助为RSet粗化总数提供窗口。参数-XX：G1SummarizeRSetStatsPeriod&#x3D;n可设置RSet的统计周期，即经历多少此GC后进行一次统计</p>
<p>代码根扫描 Code Root Scanning：对代码根集合进行扫描，扫描JVM编译后代码Native Method的引用信息(nmethod扫描)，进行RSet扫描。事实上，只有CSet分区中的RSet有强代码根时，才会做nmethod扫描，查找对CSet的引用。</p>
<p>转移和回收 Object Copy：通过选定的CSet以及CSet分区完整的引用集，将执行暂停时间的主要部分：CSet分区存活对象的转移、CSet分区空间的回收。通过工作窃取机制来<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>地选定复制对象的线程，并且复制和扫描对象被转移的存活对象将拷贝到每个GC线程分配缓冲区GCLAB。G1会通过计算，预测分区复制所花费的时间，从而调整年轻代的尺寸。</p>
<p>终止 Termination：完成上述任务后，如果任务队列已空，则工作线程会发起终止要求。如果还有其他线程继续工作，空闲的线程会通过工作窃取机制尝试帮助其他线程处理。而单独执行根分区扫描的线程，如果任务过重，最终会晚于终止。</p>
<p>GC外部的并行活动 GC Worker Other：该部分并非GC的活动，而是JVM的活动导致占用了GC暂停时间(例如JNI编译)。</p>
<h4 id="串行活动"><a href="#串行活动" class="headerlink" title="串行活动"></a><strong>串行活动</strong></h4><p>代码根更新 Code Root Fixup：根据转移对象更新代码根。</p>
<p>代码根清理 Code Root Purge：清理代码根集合表。</p>
<p>清除全局卡片标记 Clear CT：在任意收集周期会扫描CSet与RSet记录的PRT，扫描时会在全局卡片表中进行标记，防止重复扫描。在收集周期的最后将会清除全局卡片表中的已扫描标志。</p>
<p>选择下次收集集合 Choose CSet：该部分主要用于并发标记周期后的年轻代收集、以及混合收集中，在这些收集过程中，由于有老年代候选分区的加入，往往需要对下次收集的范围做出界定；但单纯的年轻代收集中，所有收集的分区都会被收集，不存在选择。</p>
<p>引用处理 Ref Proc：主要针对软引用、弱引用、虚引用、final引用、JNI引用。当Ref Proc占用时间过多时，可选择使用参数-XX:ParallelRefProcEnabled激活多线程引用处理。G1希望应用能小心使用软引用，因为软引用会一直占据内存空间直到空间耗尽时被Full GC回收掉；即使未发生Full GC，软引用对内存的占用，也会导致GC次数的增加。</p>
<p>引用排队 Ref Enq：此项活动可能会导致RSet的更新，此时会通过记录日志，将关联的卡片标记为脏卡片。</p>
<p>卡片重新脏化 Redirty Cards：重新脏化卡片。</p>
<p>回收空闲巨型分区 Humongous Reclaim：G1做了一个优化：通过查看所有根对象以及年轻代分区的RSet，如果确定RSet中巨型对象没有任何引用，则说明G1发现了一个不可达的巨型对象，该对象分区会被回收。</p>
<p>释放分区 Free CSet：回收CSet分区的所有空间，并加入到空闲分区中。</p>
<p>其他活动 Other：GC中可能还会经历其他耗时很小的活动，如修复JNI句柄等。</p>
<h4 id="并发标记周期后的年轻代收集"><a href="#并发标记周期后的年轻代收集" class="headerlink" title="并发标记周期后的年轻代收集"></a><strong>并发标记周期后的年轻代收集</strong></h4><p>并发标记周期后的年轻代收集 Young Collection Following Concurrent Marking Cycle</p>
<p>当G1发起并发标记周期之后，并不会马上开始混合收集。G1会先等待下一次年轻代收集，然后在该收集阶段中，确定下次混合收集的CSet(Choose CSet)。</p>
<h4 id="混合收集周期"><a href="#混合收集周期" class="headerlink" title="混合收集周期"></a><strong>混合收集周期</strong></h4><p>混合收集周期 Mixed Collection Cycle</p>
<p>单次的混合收集与年轻代收集并无二致。根据暂停目标，老年代的分区可能不能一次暂停收集中被处理完，G1会发起连续多次的混合收集，称为混合收集周期(Mixed Collection Cycle)。G1会计算每次加入到CSet中的分区数量、混合收集进行次数，并且在上次的年轻代收集、以及接下来的混合收集中，G1会确定下次加入CSet的分区集(Choose CSet)，并且确定是否结束混合收集周期。</p>
<h3 id="转移失败的担保机制-Full-GC"><a href="#转移失败的担保机制-Full-GC" class="headerlink" title="转移失败的担保机制 Full GC"></a><strong>转移失败的担保机制 Full GC</strong></h3><p>转移失败的担保机制 Full GC</p>
<p>转移失败(Evacuation Failure)是指当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的Full GC。Full GC会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。参数-XX:G1ReservePercent(默认10%)可以保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。</p>
<p><strong>G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</strong></p>
<p><strong>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区 从老年代分区转移存活对象时，无法找到可用的空闲分区 分配巨型对象时在老年代无法找到足够的连续分区 由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。</strong></p>
<h2 id="第五章-总结"><a href="#第五章-总结" class="headerlink" title="第五章 总结"></a><strong>第五章 总结</strong></h2><p>G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能；同时，我们也看到G1对内存空间的浪费较高，但通过**首先收集尽可能多的垃圾(Garbage First)**的设计原则，可以及时发现过期对象，从而让内存占用处于合理的水平。</p>
<p>本文转载自博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/coderlius/article/details/79272773">https://blog.csdn.net/coderlius/article/details/79272773</a></p>
<p><strong>作者：coderlius</strong></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>参考资料</strong></p>
<p>[1] Charlie H, Monica B, Poonam P, Bengt R. Java Performance Companion [2] 周志明. 深入理解JVM虚拟机</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/%E9%94%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/%E9%94%81%E8%AF%A6%E8%A7%A3/" itemprop="url">MySQL——锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL——锁（全面总结）"><a href="#MySQL——锁（全面总结）" class="headerlink" title="MySQL——锁（全面总结）"></a>MySQL——锁（全面总结）</h1><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁机制用于管理对共享资源的并发访问。</p>
<h2 id="lock和latch"><a href="#lock和latch" class="headerlink" title="lock和latch"></a>lock和latch</h2><p>在<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>中，lock和Latch都称为锁，但是两者意义不同。</p>
<p>latch称为闩锁（shuang suo），其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又分为mutex互斥锁 和 rwLock读写锁。其目的是为了保证并发线程操作临界资源的正确性。通常没有死锁的检测机制。</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620.jpeg" alt="img"></p>
<p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或者rollback后进行释放。有死锁检测机制。</p>
<p>通过<code>show engine innodb mutex</code>可以查看InnoDB存储引擎的中latch，具体字段详情如下表：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842881.jpeg" alt="img"></p>
<h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>有几个索引，需要分别向索引加锁。</p>
<h3 id="共享锁、排他锁"><a href="#共享锁、排他锁" class="headerlink" title="共享锁、排他锁"></a>共享锁、排他锁</h3><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p>
<p><strong>共享锁（S Lock）</strong>：允许事务读一行数据</p>
<p><strong>排他锁（X Lock）</strong>：允许事务删除 或 更新一行数据</p>
<p>如果一个事务T1已经获取了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁。因为读取并不会改变行的数据，所以可以多个事务同时获取共享锁，称这种情况为<strong>锁兼容</strong>。但若有其他的事务T3想获得行R的排他锁，则其必须等待事务T1、T2释放行r上面的共享锁，称这种情况为<strong>锁不兼容</strong>。下面显示了共享锁和排他锁的兼容性：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842892.jpeg" alt="img"></p>
<p>从表6-3可以看出X锁与任何锁都不兼容，而S锁仅和S锁兼容。S锁和X锁都是行锁，兼容是指对同一行记录锁的兼容情况。</p>
<p><strong>普通 select 语句默认不加锁，而CUD操作默认加排他锁。</strong></p>
<h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>Record Lock，<strong>仅锁定一行记录</strong>（如共享锁、排他锁）</p>
<ul>
<li>记录锁总是会去锁定索引记录，如果表在建立的时候，没有设置任何一个索引，那么InnoDB会使用隐式的主键来进行锁定。</li>
<li>查询条件的列是唯一索引的情况下，临键锁退化为记录锁</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>Gap Lock，<strong>锁定一个范围，但不包含记录本身。</strong></p>
<p>关闭间隙锁的2种方式：</p>
<p>（1）将事务隔离级别变为read committed</p>
<p>（2）将参数innodb_locks_unsafe_for_binlog设置为1</p>
<p>在上述配置下，除了外键和唯一性检查依然需要间隙锁，其余情况仅适用行锁进行锁定。</p>
<h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><p>Next-Key Lock，等于记录锁 + 间隙锁，<strong>锁定一个范围，并且锁定记录本身</strong>。主要是阻止多个事务将记录插入到同一个范围内，从而避免幻读。</p>
<p>假如一个索引有10、11、13、20这四个值，那么该索引可能被锁定的区间为：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842893.jpeg" alt="img"></p>
<p>若事务T1已经通过临键锁锁定了如下范围： </p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842894.jpeg" alt="img"></p>
<p>当插入新的记录12时，则锁定的范围变成：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842895.jpeg" alt="img"></p>
<p><strong>当查询的索引是唯一索引的时候，InnoDB会将临键锁优化成记录锁，从而提高并发</strong>。这时候，将不再由间隙锁避免幻读的问题。</p>
<p>在可重复读的情况下，MVCC的SELECT操作只会查找行版本号小于当前事务版本号的记录，其他事务（事务开启时间比当前事务晚）新插入的记录版本号不满足条件，就不会查出来。</p>
<p>对于辅助索引，当执行类似<code>select * from z where b = 3 for update;</code>加锁语句时，会加上临键锁，并且下一个键值的范围也会加上间隙锁。（这里参考《<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a>技术内幕》，里面有具体例子）</p>
<p>值得注意的是，对于唯一键值的锁定，由临键锁优化为记录锁，仅存在于<strong>查询所有的唯一索引</strong>。若唯一索引由多列组成，而查询仅是查找多个唯一索引中的一个，那么查询其实是range类型查询，而不是point类型查询，故InnoDB存储引擎还是继续使用临键锁。</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842906.jpeg" alt="img"></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842907.jpeg" alt="img"></p>
<p>在InnoDB存储引擎中，通过使用临键锁来避免不可重复读的问题（即幻读）。在使用临键锁的情况下，对于索引的扫描，不仅仅锁住扫描的到索引，而且还锁住这些索引覆盖的范围。因此，在这些范围内插入都是不允许的。这样子就避免了其他事务在这些范围内插入数据导致不可重复读的问题。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>概念：<strong>事务可能要加共享&#x2F;排它锁了，先提前声明一个意向</strong></p>
<p>意向锁有这样一些特点：</p>
<p>（1）意向锁是表级别的锁</p>
<p>（2）意向锁分为：</p>
<ul>
<li><strong>意向共享锁</strong>(intention shared lock, IS)，它预示着，事务有意向对表中的<strong>某些行</strong>加共享S锁 </li>
<li><strong>意向排它锁</strong>(intention exclusive lock, IX)，它预示着，事务有意向对表中的<strong>某些行</strong>加排它X锁</li>
</ul>
<p>（3）意向锁协议：</p>
<ul>
<li><strong>事务要获得某些行的共享锁，必须先获得表的意向共享锁IS</strong></li>
<li><strong>事务要获取某些行的排他锁，必须先获得表的意向排他锁IX</strong></li>
</ul>
<p>（4）由于意向锁仅仅表明意向，它其实是比较弱的锁，<strong>意向锁之间并不相互互斥，而是可以并行</strong>，其<strong>兼容互斥表</strong>如下：</p>
<p>​          IS          IX</p>
<p>IS      兼容      兼容</p>
<p>IX      兼容      兼容</p>
<p>（5）既然意向锁之间都相互兼容，<strong>那其意义在哪里呢</strong>？它会与共享锁&#x2F;排它锁互斥，其<strong>兼容互斥表</strong>如下：</p>
<p>​          S          X</p>
<p>IS      兼容      互斥</p>
<p>IX      互斥      互斥</p>
<p>（排它锁是很强的锁，不与其他类型的锁兼容。这也很好理解，修改和删除某一行的时候，必须获得强锁，禁止这一行上的其他并发，以保障数据的一致性。）</p>
<p>InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。<strong>为了支持不同粒度上进行加锁操作</strong>，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更粗的粒度上进行加锁。如图6-3所示：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842908.jpeg" alt="img"></p>
<p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象上锁，那么首先需要对粗粒度的对象进行上锁。如上图，如果需要对页上的记录上X锁，那么需要分别对数据库A、表、页 上意向锁IX，最后对记录r上排他锁X。</p>
<p>若其中任何一部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，事务T1在对记录r加X锁之前，已有事务T2对表1进行了S表锁，那么表1上面已经存在S锁，之后事务T1试图在表1上加IX锁（获取记录r的X锁必须先获取表1的IX锁），由于不兼容，所以事务T1需要等待事务T2释放表锁。</p>
<h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>对已有数据行的<strong>修改与删除</strong>，必须排他锁，那对于<strong>数据的插入</strong>，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。</p>
<p><strong>插入意向锁</strong>，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），<strong>它是专门针对insert操作的</strong>。</p>
<p>它的用处是：<strong>多个事务，在同一个索引上插入记录时，如果插入的位置不冲突，不会阻塞彼此。</strong></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">在<span class="title class_">MySQL</span>，<span class="title class_">InnoDB</span>，<span class="variable constant_">RR</span>下：</span><br><span class="line"></span><br><span class="line"><span class="title function_">t</span>(id unique <span class="variable constant_">PK</span>, name);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">数据表中有数据：</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>, shenjian</span><br><span class="line"></span><br><span class="line"><span class="number">20</span>, zhangsan</span><br><span class="line"></span><br><span class="line"><span class="number">30</span>, lisi</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">事务A先执行，在<span class="number">10</span>与<span class="number">20</span>两条记录中插入了一行，还未提交：</span><br><span class="line"></span><br><span class="line">insert into t <span class="title function_">values</span>(<span class="number">11</span>, xxx);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">事务B后执行，也在<span class="number">10</span>与<span class="number">20</span>两条记录中插入了一行：</span><br><span class="line"></span><br><span class="line">insert into t <span class="title function_">values</span>(<span class="number">12</span>, ooo);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)会使用什么锁？</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)事务B会不会被阻塞呢？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">回答：虽然事务隔离级别是<span class="variable constant_">RR</span>，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：</span><br><span class="line"></span><br><span class="line">使用的是插入意向锁</span><br><span class="line"></span><br><span class="line">并不会阻塞事务B</span><br></pre></td></tr></table></figure>

<p>复制</p>
<h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><p>自增锁是MySQL一种特殊的锁，如果<strong>表中存在自增字段，MySQL便会自动维护一个自增锁。</strong></p>
<p>在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长计数器的表进行插入操作时，这个计数器会被初始化，执行如下操作来得到计数器的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(auto_inc_col) from t for </span><br></pre></td></tr></table></figure>

<p>插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式成为<strong>Auto-Inc Locking</strong>。这种锁其实是采用一种表锁的机制，为了提高插入的性能，<strong>自增长锁不是在一个事务完成以后才释放，而是在完成自增长值插入的SQL后立即释放。</strong></p>
<p>虽然<strong>Auto-Inc Locking</strong>从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成）。</p>
<p>从MySQL5.12版本开始，InnoDB存储引擎提供了一种轻量级互斥量的自增长实现方式。这种方式大大提高了自增长值插入的性能。并且从该版本开始，InnoDB存储引起提供了一个参数innodb_innodb_autoinc_lock_mode来控制自增长模式，该参数的默认值为1。首先看下<strong>自增长的插入分类</strong>，如下图：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842909.jpeg" alt="img"></p>
<p>下图展示了innodb_innodb_autoinc_lock_mode的不同值对自增的影响：（<strong>值为1、2的时候，看不懂。。</strong>）</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429110.jpeg" alt="img"></p>
<p>InnoDB存储引擎中自增长的实现和MyISAM不同。<strong>MyISAM存储引擎是表锁设计，自增长不用考虑并发插入的问题</strong>。<strong>在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列</strong>，如果不是第一个列，则MySQL会抛出异常。MyISAM存储引擎没有这个问题。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://blog.itpub.net/15498/viewspace-2141640/">http://blog.itpub.net/15498/viewspace-2141640/</a></p>
<h3 id="外键与锁"><a href="#外键与锁" class="headerlink" title="外键与锁"></a>外键与锁</h3><p><strong>如果没有为外键显式添加索引，InnoDB自动为外键创建索引，这样子避免表锁。</strong></p>
<p>对于外键值的插入或更新，首先需要查询父表中的记录，即select父表。但不使用一致性非锁定读，因为这样子会发生数据不一致的问题。因此这时使用的是select…lock in share mode，即主动对父表加一个共享锁（这也解释了为了外键一定要索引，如果没有索引，就只能使用表锁了）。如果这时父表已经加了X锁，子表上面的操作将会被阻塞，如下图：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429111.jpeg" alt="img"></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429212.jpeg" alt="img"></p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MVCC数据多版本又称为<strong>一致性非锁定读</strong>。指<strong>InnoDB通过行多版本控制的方式来读取当前数据库中行的数据</strong>。如果读取的行正在执行delete或者update操作，这时读操作不会因此去等待行上锁的释放。相反的，InnoDB存储引擎会去读取行的一个快照数据。</p>
<p>在默认配置下，即事务的隔离界别为<strong>REPEATABLE READ（可重复读）</strong>模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。</p>
<p>快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>非锁定度机制极大的提高了数据库的并发性。这是InnoDB默认的读取方式，即读取不会占用表上的锁。但是在不同事务隔离界别下，读取的方式不同，并不是在每个事务隔离界别下都是采用非锁定的一致性读。此外，即使都是使用非锁定的一致性读，但是对于快照数据的定义也是各不相同。</p>
<p>快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。<strong>一个行记录可能有不止一个快照数据</strong>，一般称这种技术为<strong>行多版本技术</strong>，由此带来的并发控制，称之为<strong>多版本并发控制</strong> MVCC。</p>
<p>在<strong>事务隔离界别read committed 和 repeatable read</strong>（InnoDB默认的事务隔离界别）下，InnoDB使用非锁定一致性读。然而，对于快照数据的定义却不相同。</p>
<ul>
<li>在read committed隔离级别下，非一致性读总是读取被锁定行的最新一份快照数据（如果没有被锁定，则读取行的最新数据；如果行锁定了，则读取该行的最新一个快照）。</li>
<li>在repeatable read事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的快照。</li>
</ul>
<h3 id="MVCC的优缺点"><a href="#MVCC的优缺点" class="headerlink" title="MVCC的优缺点"></a>MVCC的优缺点</h3><p>MVCC在大多数情况下代替了行锁，<strong>实现了对读的非阻塞，读不加锁，读写不冲突</strong>，极大的提高了读效率。</p>
<p>缺点是每行记录都需要<strong>额外的存储空间</strong>，需要做更多的行维护和检查工作。</p>
<p>注意<strong>写写不能并行</strong>。一个事务的写操作是会加排他锁的，其他事务如果对该记录进行修改，必须等待之前的事务释放锁。</p>
<h3 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h3><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>undo log是为回滚而用，具体内容就是复制事务开始前的<strong>行</strong>到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。在Innodb中，undo log被划分为多个段，具体某行的undo log就保存在某个段中，称为回滚段。<strong>可以认为undo log和回滚段是同一意思</strong>。</p>
<p>为了便于理解MVCC的实现原理，这里简单介绍一下undo log的工作过程</p>
<p>在不考虑redo log 的情况下利用undo log工作的简化过程为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">序号	动作</span><br><span class="line"><span class="number">1</span>	   开始事务</span><br><span class="line"><span class="number">2</span>		 记录数据行数据备份到undo log</span><br><span class="line"><span class="number">3</span>		 更新数据</span><br><span class="line"><span class="number">4</span>		 将undo log写到磁盘</span><br><span class="line"><span class="number">5</span>		 提交事务</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>（1）undo log的持久化必须在在数据持久化之前，这样才能保证系统崩溃时，可以用undo log来回滚事务</p>
<p>（2）Innodb通过undo log保存了已更改行的旧版本的快照。</p>
<p>（3）提交事务做的事情有：写redo log和binlog，并且把数据持久化到磁盘（可以通过参数控制）</p>
<h4 id="InnoDB中的隐藏列"><a href="#InnoDB中的隐藏列" class="headerlink" title="InnoDB中的隐藏列"></a>InnoDB中的隐藏列</h4><p>InnoDB的内部实现中为每一行数据增加了三个隐藏列用于实现MVCC。</p>
<table>
<thead>
<tr>
<th align="left">列名</th>
<th align="left">长度(字节)</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DB_TRX_ID</td>
<td align="left">6</td>
<td align="left">插入或更新行的最后一个事务的事务ID。（删除视为更新，将其标记为已删除）</td>
</tr>
<tr>
<td align="left">DB_ROLL_PTR</td>
<td align="left">7</td>
<td align="left">写入回滚段的撤消日志记录（若行已更新，则撤消日志记录包含在更新行之前重建行内容所需的信息）</td>
</tr>
<tr>
<td align="left">DB_ROW_ID</td>
<td align="left">6</td>
<td align="left">行ID（隐藏单调自增id）</td>
</tr>
</tbody></table>
<p>一行记录的结构如下：</p>
<table>
<thead>
<tr>
<th align="left">数据列</th>
<th align="left">…</th>
<th align="left">DB_ROW_ID</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="MVCC的SQL规则"><a href="#MVCC的SQL规则" class="headerlink" title="MVCC的SQL规则"></a>MVCC的SQL规则</h4><p>MVCC只在READ COMMITED 和 REPEATABLE READ 两个隔离级别下工作。READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE 则会对所有读取的行都加锁。另外事务的版本号是递增的。</p>
<p><strong>SELECT</strong></p>
<p>InnoDB只查找 行的事务ID 小于当前事务ID 的数据行（避免幻读）</p>
<p><strong>INSERT</strong></p>
<p>新插入的每一行保存当前事务ID作为行的事务ID</p>
<p><strong>DELETE</strong></p>
<p>删除的每一行保存当前事务ID作为行的事务ID</p>
<p><strong>UPDATE</strong></p>
<p>实际上是删除旧行，插入新行。</p>
<p>保存当前的事务ID作为新行的事务ID，同时保存当前事务ID到旧行的事务ID。</p>
<h4 id="MVCC插入示例"><a href="#MVCC插入示例" class="headerlink" title="MVCC插入示例"></a>MVCC插入示例</h4><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429213.jpeg" alt="img"></p>
<p>F1F6是字段名称，16是对应的数据。后面3个隐藏字段分别对应行ID、事务ID、回滚指针。</p>
<p><strong>初始状态</strong></p>
<p>假如有一条初始的数据，可以认为行ID为1，其他两个字段为空。</p>
<p><strong>事务1更改该行的值</strong></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429314.jpeg" alt="img"></p>
<p>当事务1更改该行的值时，会进行如下操作：</p>
<ul>
<li>用排他锁锁定该行</li>
<li><strong>把该行修改前的值复制到undo log</strong>，即上图中下面的行</li>
<li>使回滚指针指向undo log中的行</li>
<li>修改当前的行的值，填写事务编号</li>
<li>释放锁</li>
</ul>
<p><strong>事务2更改该行的值</strong></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429315.jpeg" alt="img"></p>
<p>与事务1相同，此时undo log中有2条记录，并且通过回滚指针连在一起。</p>
<p>因此，如果undo log一直不删除，则可以通过当前记录的回滚指针回溯到该行创建时的初始内容，所幸的是在<strong>InnoDB中存在清理线程，它会查询比现在最老的事务还早的undo log，并删除它们，从而保证undo log文件不会无限增长</strong>。</p>
<h4 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h4><p>主要用来判断当前版本数据的可见性。</p>
<p>在InnoDB中，创建一个新事务的时候，InnoDB会将当前系统中的活跃事务列表（trx_sys-&gt;trx_list）创建一个副本（read view），副本中保存的是系统当前不应该被本事务看到的其他事务id列表。当用户在这个事务中要读取该行记录的时候，innodb会将该行当前的版本号与该read view进行比较。 具体的算法如下:</p>
<ol>
<li>设该行的当前事务id为trx_id_0，read view中最早的事务id为trx_id_1, 最迟的事务id为trx_id_2。</li>
<li>如果trx_id_0&lt; trx_id_1的话，那么表明该行记录所在的事务已经在本次新事务创建之前就提交了，所以该行记录的当前值是可见的。跳到步骤6.</li>
<li>如果trx_id_0&gt;trx_id_2的话，那么表明该行记录所在的事务在本次新事务创建之后才开启，所以该行记录的当前值不可见.跳到步骤5。</li>
<li>如果trx_id_1&lt;&#x3D;trx_id_0&lt;&#x3D;trx_id_2, 那么表明该行记录所在事务在本次新事务创建的时候处于活动状态，从trx_id_1到trx_id_2进行遍历，如果trx_id_0等于他们之中的某个事务id的话，那么不可见。跳到步骤5.</li>
<li>从该行记录的DB_ROLL_PTR指针所指向的回滚段中取出最新的undo-log的版本号，将它赋值该trx_id_0，然后跳到步骤2.</li>
<li>将该可见行的值返回。</li>
</ol>
<p>需要注意的是，新建事务(当前事务)与正在内存中commit 的事务不在活跃事务链表中。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>读操作远远大于写操作的场景，因此适用于绝大多数互联网场景。</p>
<h2 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h2><p>在默认的配置下，即事务的隔离级别为可重复度，InnoDB存储引擎的select操作使用一致性非锁定读（即MVCC）。但是在某些情况下，用户需要显示的对数据库读取操作进行加锁，以保证数据逻辑的一致性。而这要求数据库支持加锁语句，InnoDB存储引擎对select支持两种一致性的锁定读操作：</p>
<ul>
<li>select …  for update</li>
<li>select … lock in share mode;</li>
</ul>
<p><strong>select…for update对读取的行记录加一个X锁</strong>，其他事务不能对已锁定的行加上任何锁。</p>
<p><strong>select…lock in share mode对读取的行记录加一个S锁</strong>，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。</p>
<p>对于一致性非锁定读，即时读取的行已经被执行了select…for update，也是可以进行读取的。</p>
<p>select…for update或者select…lock in share mode必须在事务中，因为当事务提交了，锁也就释放了。从而避免锁没有释放，可能导致死锁的情况。</p>
<p><strong>如果不加筛选条件（或者筛选条件不走索引），会升级为表锁</strong></p>
<p><strong>索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012099869/article/details/52778728">https://blog.csdn.net/u012099869/article/details/52778728</a> </p>
<h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>脏数据</strong>：指的是<strong>事务对缓冲池中行记录的修改，并且还没有提交</strong>。即事务未提交的数据。</p>
<p><strong>脏读</strong>：指当前事务可以读到其他事务的未提交的数据。如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，显然违反了事务的隔离性。</p>
<p><strong>脏读的条件</strong>：需要事务的隔离级别为<strong>读未提交</strong>。</p>
<p><strong>示例</strong>：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429316.jpeg" alt="img"></p>
<p><strong>解决</strong>：设置事务的隔离级别为“读已提交”或者更高的隔离界别。</p>
<p>​    那<strong>为什么“读已提交”能解决脏读的问题？</strong>  我的理解是，在“读已提交”的情况下，读取的是快照的最新版本的数据，那么既然读取的是快照数据了，那么这些数据肯定是之前的事务提交过了的。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>不可重复读</strong>：指在在一个事务内多次读取同一个数据集合，在这个事务还没有结束时，另外一个事务也访问了同一个数据集合，并且做了一些修改或新增操作。因此，在第一个事务的两次读数据之间，由于第二个事务的修改，第一个事务两次读取到的数据可能是不一样的（具体看隔离级别）。这种称为<strong>不可重复读</strong>。</p>
<p><strong>示例</strong>：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429317.jpeg" alt="img"></p>
<p><strong>幻读：同一事务下，连续执行2次相同的sql，可能返回不同的结果，第二次的sql可能返回之前不存在的行。</strong></p>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p><strong>丢失更新</strong>：指一个事务的更新操作被另外一个事务的更新操作所覆盖，从而导致数据的不一致。</p>
<p><strong>丢失更新的实例</strong>：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429318.jpeg" alt="img"></p>
<p><strong>解决办法</strong>：对用户读取的记录加上一个排他锁，这样子其他事务就必须等待前一个事务的完成。从而避免并发问题。</p>
<p><strong>解决办法的示例</strong>：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429419.jpeg" alt="img"></p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><strong>阻塞</strong>：事务因为等待其他事务释放锁而等待</p>
<p><strong>超时</strong>：等待其他事务释放锁，超过超时时间，就认为是超时。</p>
<p><strong>innodb_lock_wait_timeout</strong>：用来控制超时时间，默认是50秒。可以在MYSQL运行时进行设置。</p>
<p><strong>innodb_rollback_on_timeout</strong>：用来设定是否在等待超时时对进行中的事务进行回滚操作。默认是OFF，不回滚。不可以在MySQL启动时进行修改。用户在超时的情况下，必须判断是是否需要commit或者rollback，之后再进行下一步的操作。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>概念</strong>：死锁是指两个或者两个以上的事务，因争夺资源而造成的一种互相等待的现象。若无外力作用，所有事务都将无法推进下去。</p>
<h3 id="FIFO处理死锁"><a href="#FIFO处理死锁" class="headerlink" title="FIFO处理死锁"></a>FIFO处理死锁</h3><p><strong>解决数据库死锁最简单的方法</strong>：设置超时时间。即当两个事务互相等待时，当一个等待时间超过设置的阈值时，其中一个事务进行回滚，另外一个等待的事务就能继续执行。</p>
<p>超时机制虽然简单，但是其使用FIFO的方式来选择超时回滚的事务，假如第一个超时的事务 更新了很多行，远比第二个事务多，因此占用了更多的undo log，这时FIFO的方式，就显得不适用了，因为第一个事务回滚时间明显比第二个事务回滚时间长很多。</p>
<h3 id="等待图"><a href="#等待图" class="headerlink" title="等待图"></a>等待图</h3><p>因为FIFO处理死锁可能不适用，所以数据库普遍采用了wait-for graph（等待图）的方式来进行死锁检测。和超时机制比较，这是一种更为主动的死锁检测方式，InnoDB也采用了这种方式。</p>
<p>等待图要求数据库保存以下两种信息：</p>
<p>（1）锁的信息链表（见图6-5 右）</p>
<p>（2）事务等待链表（见图6-5 左）</p>
<p>通过上述链表可以构造出一张图，而在这个<strong>图中存在回路，则代表存在死锁</strong>。在等待图中，事务为图中的节点。在图中，事务T1指向事务T2边的定义为：</p>
<p>（1）事务T1等待事务T2所占用的资源</p>
<p>（2）事务之间在等待相同的资源，而事务T1在事务T2之后</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429420.jpeg" alt="img"></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429421.jpeg" alt="img"></p>
<p>发现死锁后，InnoDB会马上回滚一个undo量最小的事务。 </p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p><strong>概念</strong>：<strong>将当前锁的粒度降低，比如说把行锁升级为表锁，那样子会导致并发性能降低。</strong></p>
<p>InnoDB不是根据每个记录来产生行锁的，而是根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式，因此不管一个事务锁住页中一条还是多条记录，都是用一个锁，其开销通常是一致的。</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429422.jpeg" alt="img"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>快照读、当前读指的是什么，有什么区别？</strong></p>
<p>快照读:</p>
<ul>
<li>读取数据的备份，不用加锁，这个数据可能是旧数据.</li>
<li>比如说普通的select语句。</li>
</ul>
<p>当前读:</p>
<ul>
<li>读取的数据最新版本 </li>
<li>读数据的时候会加上锁，保证其他事务不会并发修改这条记录。 </li>
<li>如select … lock in share mode select … for update 	insert 	update 	delete</li>
</ul>
<p>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2/" itemprop="url">MySQL慢查询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="你的哪些SQL慢？看看MySQL慢查询日志吧"><a href="#你的哪些SQL慢？看看MySQL慢查询日志吧" class="headerlink" title="你的哪些SQL慢？看看MySQL慢查询日志吧"></a>你的哪些SQL慢？看看MySQL慢查询日志吧</h1><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/c54e191f715b46f790314f91ee307dd9tplv-k3u1fbpfcp-zoom-crop-mark3024302430241702.awebp" alt="你的哪些SQL慢？看看MySQL慢查询日志吧"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在项目里面，多多少少都隐藏着一些执行比较慢的SQL, 不同的开发测试人员在平时使用的过程中多多少少都能够遇到，但是无法立马有时间去排查解决。那么如果有一个文件能够将这些使用过程中比较慢的SQL记录下来，定期去分析排查，那该多美好啊。这种情况MySQL也替我们想到了，它提供了SQL慢查询的日志，本文就分享下如何使用吧。</p>
<h2 id="什么是慢查询日志？"><a href="#什么是慢查询日志？" class="headerlink" title="什么是慢查询日志？"></a>什么是慢查询日志？</h2><p>MySQL的慢询日志，提供了记录在MySQL中响应时间超过指定阈值语句的功能，比如设定阈值为3秒，那么任何SQL执行超过3秒都会被记录下来。</p>
<p>我们借助慢查询日志功能可以发现哪些那些执行时间特别长的询，并且有针对性地进行优化，从而提高系统的整体效率。</p>
<h2 id="怎么开启慢查询日志？"><a href="#怎么开启慢查询日志？" class="headerlink" title="怎么开启慢查询日志？"></a>怎么开启慢查询日志？</h2><p>默认情况下，MySQL数据库<strong>没有开启</strong>慢查询日志，因为多多少少会带来一定性能的影响。我们可以在开发测试环境、或者生产环境做调优的时候开启，<strong>那怎么查看是否开启了呢？</strong></p>
<ol>
<li><strong>查看慢SQL是否开启</strong></li>
</ol>
<p>执行下面命令查看是否开启慢SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/d27eadf02574490392490f937b367416tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ul>
<li><code>OFF</code>: 未开启</li>
<li><code>ON</code>: 开启</li>
</ul>
<ol>
<li><strong>如何开启慢查询</strong></li>
</ol>
<p>执行下面的命令开启慢查询日志</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> set global <span class="attr">slow_query_log</span>=<span class="string">&#x27;ON&#x27;</span><span class="comment">;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/25c5256478534072aeaeae967b8a164btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ol>
<li><strong>修改慢查询阈值</strong></li>
</ol>
<p>前面介绍了SQL执行到达了制定的时间阈值后记录到慢查询日志中，那么如何设置呢？</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set global <span class="attr">long_query_time</span> = N<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">set <span class="attr">long_query_time</span> = N</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置global的方式对当前<code>session</code>的<code>long_query_time</code>失效。对新连接的客户端有效。所以可以一并执行下述语句</p>
</li>
<li><p>N表示设置的阈值，单位为秒</p>
</li>
</ul>
<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/193484811274457cb7bfc12be950bfe7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ul>
<li>这里的<code>show global variables like &#39;%long_query_time%&#39;;</code>可以查看阈值大小</li>
</ul>
<ol>
<li><strong>如何设置永久生效</strong></li>
</ol>
<p>前面是通过命令行的方式设置，如果MySQL重启，那么配置就会重置。我们可以通过修改MySQL的配置<code>my.cfg</code>或者<code>my.ini</code>永久生效。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="literal">ON</span>  <span class="comment"># 开启慢查询日志开关</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=/var/lib/mysql/alvin-slow.log  <span class="comment"># 慢查询日志的目录和文件名信息</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">3</span>  <span class="comment"># 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line"><span class="attr">log_output</span>=FILE</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="慢查询日志在哪里呢？"><a href="#慢查询日志在哪里呢？" class="headerlink" title="慢查询日志在哪里呢？"></a>慢查询日志在哪里呢？</h2><p>前面讲解了如何开启MySQL的慢查询日志，那么它把日志记录在哪里了呢?</p>
<ol>
<li><strong>查看慢查询日志位置</strong></li>
</ol>
<p>通过<code>show variables like &#39;%slow_query_log_file%&#39;;</code>命令可以查看慢SQL文件位置，如下图所示：</p>
<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/b8cde05cdcac4b069abc4cab2c48e223tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ol>
<li><strong>修改慢查询日志位置</strong></li>
</ol>
<p>也很简单，执行下面的命令即可：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global <span class="attr">slow_query_log_file</span> = <span class="string">&#x27;/usr/local/mysql/data/alvin-slow-slow.log&#x27;</span><span class="comment">;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="怎么查看慢SQL内容？"><a href="#怎么查看慢SQL内容？" class="headerlink" title="怎么查看慢SQL内容？"></a>怎么查看慢SQL内容？</h2><p>现在我们已经知道慢查询日志在哪里了，那么如何查看里面的内容呢？我们这里用一个例子演示下吧。</p>
<ol>
<li><strong>执行一个查询的SQL</strong></li>
</ol>
<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/ca631d0a573c4afbac3c6c853b74a7aatplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ul>
<li>执行花了1秒多，超过了前面设置的阈值1s</li>
</ul>
<ol>
<li><strong>查看慢查询数目</strong></li>
</ol>
<p>执行下面命令查询当前系统中有多少条慢查询记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/554c1a7baf8c497985dfa3b06849bc50tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ul>
<li>value&#x3D;1, 表明刚刚的日志被记录了。</li>
</ul>
<ol>
<li><strong>查看日志内容</strong></li>
</ol>
<p>通过<code>cat</code>命令查看文件内容，可以看到对应的慢SQL。</p>
<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/a054f8b478b24c2c8112ecf49c5e280btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<h3 id="慢查询日志分析工具mysqldumpslow"><a href="#慢查询日志分析工具mysqldumpslow" class="headerlink" title="慢查询日志分析工具mysqldumpslow"></a>慢查询日志分析工具mysqldumpslow</h3><p>果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 <code>mysqldumpslow</code> 。</p>
<p><code>mysqldumpslow</code> 命令的具体参数如下：</p>
<ul>
<li><p>-a: 不将数字抽象成N，字符串抽象成S</p>
</li>
<li><p>-s: 是表示按照何种方式排序：</p>
</li>
<li><ul>
<li>c: 访问次数</li>
<li>l: 锁定时间</li>
<li>r: 返回记录</li>
<li>t: 查询时间</li>
<li>al:平均锁定时间</li>
<li>ar:平均返回记录数</li>
<li>at:平均查询时间 （默认方式）</li>
<li>ac:平均查询次数</li>
</ul>
</li>
<li><p>-t: 即为返回前面多少条的数据；</p>
</li>
<li><p>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</p>
</li>
</ul>
<p>可mysqldumpslow位置mysql的bin目录下，以通过执行 mysqldumpslow –help命令查看使用。</p>
<p><strong>举例：</strong> 我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t <span class="number">5</span> /usr/<span class="keyword">local</span>/mysql/data/alvin-slow-slow.<span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/17062293febf4466b0b27e4abcccea76tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<p><strong>常见的用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /usr/local/mysql/data/alvin-slow-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /usr/local/mysql/data/alvin-slow-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g <span class="string">&quot;left join&quot;</span> /usr/local/mysql/data/alvin-slow-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /usr/local/mysql/data/alvin-slow-slow.log | more</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="怎么删除慢SQL日志？"><a href="#怎么删除慢SQL日志？" class="headerlink" title="怎么删除慢SQL日志？"></a>怎么删除慢SQL日志？</h2><p>现在慢查询日志很多了啊，为了不互相混淆，我要删除一些慢SQL日志，怎么删除呢？</p>
<ol>
<li>手动删除慢查询日志文件即可, 也就是<code>rm</code>命令。</li>
<li>使用命令<code>mysqladmin flush-logs </code>重置慢sql日志内容，完整命令如下 ：</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs slow</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql%E8%B7%B3%E8%B7%83%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql%E8%B7%B3%E8%B7%83%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95/" itemprop="url">MySQL 8.0 索引跳跃扫描</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL-8-0-索引跳跃扫描"><a href="#MySQL-8-0-索引跳跃扫描" class="headerlink" title="MySQL 8.0 索引跳跃扫描"></a>MySQL 8.0 索引跳跃扫描</h1><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdb?from=10680"><strong>MySQL</strong></a> <strong>8.0 实现了Index skip scan，翻译过来就是索引跳跃扫描。</strong>熟悉ORACLE的朋友是不是发现越来越像ORACLE了？再者，熟悉MySQL 5.7 的朋友是不是觉得这个很类似当时优化器的选项MRR？好了，先具体说下什么 ISS，我后面全部用 ISS 简称。</p>
<p><strong>考虑以下的场景：</strong></p>
<p>表t1有一个联合索引idx_u1(rank1,rank2)，但是查询的时候却没有rank1这列，只有rank2。比如，select * from t1 where rank2 &#x3D; 30。</p>
<p>那以前遇到这样的情况，如果没有针对rank2这列单独建立普通索引，这条SQL怎么着都是走的FULL TABLE SCAN。</p>
<p>ISS 就是在这样的场景下产生的。<strong>ISS 可以在查询过滤组合索引不包括最左列的情况下，走索引扫描，而不必要单独建立额外的索引。</strong>因为毕竟额外的索引对写开销很大，能省则省。</p>
<p><strong>还是拿刚才的例子来讲，假设：</strong></p>
<p>表t1的两个字段rank1,rank2。有这样的记录，</p>
<p><img src="/.%5Cmedia%5C1620.jpg" alt="img"></p>
<p>我们给出的SQL是，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> t1 where rank2 &gt;<span class="number">400</span>,</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>那MySQL通过ISS把这条SQL变为，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> t1 where rank1=<span class="number">1</span> and rank2 &gt; 400union allselect * <span class="keyword">from</span> t1 where rank1 = <span class="number">5</span> and rank2 &gt; <span class="number">400</span>;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>可以看出来，MySQL其实内部自己把左边的列做了一次DISTINCT，完了加进去。</p>
<p><strong>我们拿实际的例子来看下。假设：</strong></p>
<p>还是刚才描述那张表，rank1字段值的distinct值比较少。查询计划的对比，</p>
<p><img src="/.%5Cmedia%5C1621.jpg" alt="img"></p>
<p>关闭 ISS，</p>
<p>很显然，ISS 扫描的行数要比之前的少很多。</p>
<p><strong>ISS其实恰好适合在这种左边字段的唯一值较少的情况下，效率来的高。</strong>比如性别，状态等等。</p>
<p><strong>那假设：rank1字段的distinct值比较多呢？</strong></p>
<p>我们重新造了点数据，这次，rank1的唯一值个数有快上万个。</p>
<p><img src="/.%5Cmedia%5C1623.jpg" alt="img"></p>
<p>我们来再次看一遍这样SQL的执行计划，</p>
<p><img src="/.%5Cmedia%5C1624.jpg" alt="img"></p>
<p><img src="/.%5Cmedia%5C1625.jpg" alt="img"></p>
<p>这次我们发现，无论如何MySQL也不会选择 ISS，而选了FULL INDEX SCAN。</p>
<p>那这样的场景就必须给rank2加一个单独索引了。</p>
<p><img src="/.%5Cmedia%5C1626.jpg" alt="img"></p>
<p><strong>Index Skip Scan限制条件：</strong></p>
<ol>
<li>查询只能涉及一张表，多表关联无法使用该特性</li>
<li>查询SQL不能使用 GROUP BY 或者 DISTINCT子句</li>
<li><strong>查询字段必须是索引中的字段</strong></li>
<li>组合索引形式：([A_1, …, A_k,] B_1, …, B_m, C [, D_1, …, D_n])，A，D 可以为空，但是B ,C 不能为空</li>
</ol>
<p><strong>参数开关：</strong></p>
<p>通过设置参数optimizer_switch中的skip_scan&#x3D;on&#x2F;off，来控制是否打开该优化策略，默认打开。</p>
<p>那来总结下 ISS 就是一句话：<strong>ISS 其实就是MySQL 8.0推出的适合联合索引左边列唯一值较少的情况的一种优化策略。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql-%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql-%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/" itemprop="url">orderby 详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MYSQL：order-by详解"><a href="#MYSQL：order-by详解" class="headerlink" title="MYSQL：order by详解"></a>MYSQL：order by详解</h1><p>原创 捡田螺的小男孩 <a href="javascript:void(0);">捡田螺的小男孩</a> <em>2021-06-15 07:59</em></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>日常开发中，我们经常会使用到order by，亲爱的小伙伴，你是否知道order by 的工作原理呢？order by的优化思路是怎样的呢？使用order by有哪些注意的问题呢？本文将跟大家一起来学习，攻克order by~</p>
<p><img src="/.%5Cmedia%5C1.jpg" alt="图片"></p>
<ul>
<li>微信公众号：<strong>捡田螺的小男孩</strong></li>
</ul>
<h2 id="一个使用order-by-的简单例子"><a href="#一个使用order-by-的简单例子" class="headerlink" title="一个使用order by 的简单例子"></a><strong>一个使用order by 的简单例子</strong></h2><p>假设用一张员工表，表结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `staff` (</span><br><span class="line">`id` BIGINT ( 11 ) AUTO_INCREMENT COMMENT &#x27;主键id&#x27;,</span><br><span class="line">`id_card` VARCHAR ( 20 ) NOT NULL COMMENT &#x27;身份证号码&#x27;,</span><br><span class="line">`name` VARCHAR ( 64 ) NOT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">`age` INT ( 4 ) NOT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">`city` VARCHAR ( 64 ) NOT NULL COMMENT &#x27;城市&#x27;,</span><br><span class="line">PRIMARY KEY ( `id`),</span><br><span class="line">INDEX idx_city ( `city` )</span><br><span class="line">) ENGINE = INNODB COMMENT &#x27;员工表&#x27;;</span><br></pre></td></tr></table></figure>

<p>表数据如下：</p>
<p><img src="/.%5Cmedia%5C2.jpg" alt="图片"></p>
<p>我们现在有这么一个需求：<strong>查询前10个，来自深圳员工的姓名、年龄、城市，并且按照年龄小到大排序</strong>。对应的 SQL 语句就可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br></pre></td></tr></table></figure>

<p>这条语句的逻辑很清楚，但是它的<strong>底层执行流程</strong>是怎样的呢？</p>
<h2 id="order-by-工作原理"><a href="#order-by-工作原理" class="headerlink" title="order by 工作原理"></a><strong>order by 工作原理</strong></h2><p><img src="/.%5Cmedia%5C3.jpg" alt="图片"></p>
<h3 id="explain-执行计划"><a href="#explain-执行计划" class="headerlink" title="explain 执行计划"></a>explain 执行计划</h3><p>我们先用<strong>Explain</strong>关键字查看一下执行计划</p>
<p><img src="/.%5Cmedia%5C4.jpg" alt="图片"></p>
<ul>
<li>执行计划的<strong>key</strong>这个字段，表示使用到索引idx_city</li>
<li>Extra 这个字段的 <strong>Using index condition</strong> 表示索引条件</li>
<li>Extra 这个字段的 <strong>Using filesort</strong>表示用到排序</li>
</ul>
<p>我们可以发现，这条SQL使用到了索引，并且也用到排序。那么它是<strong>怎么排序</strong>的呢？</p>
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>MySQL 会给每个查询线程分配一块小<strong>内存</strong>，用于<strong>排序</strong>的，称为 <strong>sort_buffer</strong>。什么时候把字段放进去排序呢，其实是通过<code>idx_city</code>索引找到对应的数据，才把数据放进去啦。</p>
<p>我们回顾下索引是怎么找到匹配的数据的，现在先把索引树画出来吧，<strong>idx_city</strong>索引树如下：</p>
<p><img src="/.%5Cmedia%5C5.jpg" alt="图片"></p>
<p>idx_city索引树，叶子节点存储的是<strong>主键id</strong>。还有一棵id主键聚族索引树，我们再画出聚族索引树图吧：</p>
<p><img src="/.%5Cmedia%5C6.jpg" alt="图片"></p>
<p><strong>我们的查询语句是怎么找到匹配数据的呢</strong>？先通过<strong>idx_city</strong>索引树，找到对应的主键id，然后再通过拿到的主键id，搜索<strong>id主键索引树</strong>，找到对应的行数据。</p>
<p>加上<strong>order by</strong>之后，整体的执行流程就是：</p>
<ol>
<li>MySQL 为对应的线程初始化<strong>sort_buffer</strong>，放入需要查询的name、age、city字段；</li>
<li>从<strong>索引树idx_city</strong>， 找到第一个满足 city&#x3D;’深圳’条件的主键 id，也就是图中的id&#x3D;9；</li>
<li>到<strong>主键 id 索引树</strong>拿到id&#x3D;9的这一行数据， 取name、age、city三个字段的值，存到sort_buffer；</li>
<li>从<strong>索引树idx_city</strong> 拿到下一个记录的主键 id，即图中的id&#x3D;13；</li>
<li>重复步骤 3、4 直到<strong>city的值不等于深圳</strong>为止；</li>
<li>前面5步已经查找到了所有<strong>city为深圳</strong>的数据，在 sort_buffer中，将所有数据根据age进行排序；</li>
<li>按照排序结果取前10行返回给客户端。</li>
</ol>
<p>执行示意图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65Gx3PbkcEKH5GOKWnpicr6sVJ1HSEiaJo6xqeUV1X5WRxdFRbfz1DEOow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>将查询所需的字段全部读取到sort_buffer中，就是<strong>全字段排序</strong>。这里面，有些小伙伴可能会有个疑问,把查询的所有字段都放到sort_buffer，而sort_buffer是一块内存来的，如果数据量太大，sort_buffer放不下怎么办呢？</p>
<h3 id="磁盘临时文件辅助排序"><a href="#磁盘临时文件辅助排序" class="headerlink" title="磁盘临时文件辅助排序"></a>磁盘临时文件辅助排序</h3><p>实际上，sort_buffer的大小是由一个参数控制的：<strong>sort_buffer_size</strong>。如果要排序的数据小于sort_buffer_size，排序在<strong>sort_buffer</strong> 内存中完成，如果要排序的数据大于sort_buffer_size，则<strong>借助磁盘文件来进行排序</strong></p>
<p>如何确定是否使用了磁盘文件来进行排序呢？可以使用以下这几个命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 打开optimizer_trace，开启统计</span><br><span class="line">set optimizer_trace = &quot;enabled=on&quot;;</span><br><span class="line">## 执行SQL语句</span><br><span class="line">select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br><span class="line">## 查询输出的统计信息</span><br><span class="line">select * from information_schema.optimizer_trace </span><br></pre></td></tr></table></figure>

<p>可以从 <strong>number_of_tmp_files</strong> 中看出，是否使用了临时文件。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65RZ9YcPAmsEnj3YxNBuVbnp2x0ncg9qzBYlpYWsuUd2eAUEkWDJlaxg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>number_of_tmp_files</strong> 表示使用来排序的磁盘临时文件数。如果number_of_tmp_files&gt;0，则表示使用了磁盘文件来进行排序。</p>
<p>使用了磁盘临时文件，整个排序过程又是怎样的呢？</p>
<ol>
<li>从<strong>主键Id索引树</strong>，拿到需要的数据，并放到<strong>sort_buffer内存</strong>块中。当sort_buffer快要满时，就对sort_buffer中的数据排序，排完后，把数据临时放到磁盘一个小文件中。</li>
<li>继续回到主键 id 索引树取数据，继续放到sort_buffer内存中，排序后，也把这些数据写入到磁盘临时小文件中。</li>
<li>继续循环，直到取出所有满足条件的数据。最后把磁盘的临时排好序的小文件，合并成一个有序的大文件。</li>
</ol>
<p><strong>TPS:</strong> 借助磁盘临时小文件排序，实际上使用的是<strong>归并排序</strong>算法。</p>
<p>小伙伴们可能会有个疑问，既然<strong>sort_buffer</strong>放不下，就需要用到临时磁盘文件，这会影响排序效率。那为什么还要把排序不相关的字段（name，city）放到sort_buffer中呢？只放排序相关的age字段，它<strong>不香</strong>吗？可以了解下<strong>rowid 排序</strong>。</p>
<h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><p>rowid 排序就是，只把查询SQL<strong>需要用于排序的字段和主键id</strong>，放到sort_buffer中。那怎么确定走的是全字段排序还是rowid 排序排序呢？</p>
<p>实际上有个参数控制的。这个参数就是<strong>max_length_for_sort_data</strong>，它表示MySQL用于排序行数据的长度的一个参数，如果单行的长度超过这个值，MySQL 就认为单行太大，就换rowid 排序。我们可以通过命令看下这个参数取值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;max_length_for_sort_data&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65bg60JTICaqju2NMsMSP6vw7cKg8nZbkQJDZQo5ia9oI0XiaklaibunLfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>max_length_for_sort_data</strong> 默认值是1024。因为本文示例中name,age,city长度&#x3D;64+4+64 &#x3D;132 &lt; 1024, 所以走的是全字段排序。我们来改下这个参数，改小一点，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 修改排序数据最大单行长度为32</span><br><span class="line">set max_length_for_sort_data = 32;</span><br><span class="line">## 执行查询SQL</span><br><span class="line">select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br></pre></td></tr></table></figure>

<p>使用rowid 排序的话，整个SQL执行流程又是怎样的呢？</p>
<ol>
<li>MySQL 为对应的线程初始化<strong>sort_buffer</strong>，放入需要排序的age字段，以及主键id；</li>
<li>从<strong>索引树idx_city</strong>， 找到第一个满足 city&#x3D;’深圳’条件的主键 id，也就是图中的id&#x3D;9；</li>
<li>到<strong>主键 id 索引树</strong>拿到id&#x3D;9的这一行数据， 取age和主键id的值，存到sort_buffer；</li>
<li>从<strong>索引树idx_city</strong> 拿到下一个记录的主键 id，即图中的id&#x3D;13；</li>
<li>重复步骤 3、4 直到<strong>city的值不等于深圳</strong>为止；</li>
<li>前面5步已经查找到了所有city为深圳的数据，在 <strong>sort_buffer</strong>中，将所有数据根据age进行排序；</li>
<li>遍历排序结果，取前10行，并按照 id 的值<strong>回到原表</strong>中，取出city、name 和 age 三个字段返回给客户端。</li>
</ol>
<p>执行示意图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65KylUcdB0IUG6OGEAK95wnGgkNQO8zr5zibdiawXD08l6REB8qVH3vYCQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>对比一下<strong>全字段排序</strong>的流程，rowid 排序多了一次<strong>回表</strong>。</p>
<blockquote>
<p>★</p>
<p>什么是回表？拿到主键再回到主键索引查询的过程，就叫做回表</p>
<p>”</p>
</blockquote>
<p>我们通过<strong>optimizer_trace</strong>，可以看到是否使用了rowid排序的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 打开optimizer_trace，开启统计</span><br><span class="line">set optimizer_trace = &quot;enabled=on&quot;;</span><br><span class="line">## 执行SQL语句</span><br><span class="line">select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br><span class="line">## 查询输出的统计信息</span><br><span class="line">select * from information_schema.optimizer_trace </span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65fxGiatHhp7EwQc7SxjSEDiczBWibZj9LIU0McPSJkweje3kIniapXHwccg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="全字段排序与rowid排序对比"><a href="#全字段排序与rowid排序对比" class="headerlink" title="全字段排序与rowid排序对比"></a>全字段排序与rowid排序对比</h3><ul>
<li>全字段排序：sort_buffer内存不够的话，就需要用到磁盘临时文件，造成<strong>磁盘访问</strong>。</li>
<li>rowid排序：sort_buffer可以放更多数据，但是需要再回到原表去取数据，比全字段排序多一次<strong>回表</strong>。</li>
</ul>
<p>一般情况下，对于InnoDB存储引擎，会优先使<strong>用全字段</strong>排序。可以发现 <strong>max_length_for_sort_data</strong> 参数设置为1024，这个数比较大的。一般情况下，排序字段不会超过这个值，也就是都会走<strong>全字段</strong>排序。</p>
<h2 id="order-by的一些优化思路"><a href="#order-by的一些优化思路" class="headerlink" title="order by的一些优化思路"></a><strong>order by的一些优化思路</strong></h2><p>我们如何优化order by语句呢？</p>
<ul>
<li>因为数据是无序的，所以就需要排序。如果数据本身是有序的，那就不用排了。而索引数据本身是有序的，我们通过建立<strong>联合索引</strong>，优化order by 语句。</li>
<li>我们还可以通过调整<strong>max_length_for_sort_data</strong>等参数优化；</li>
</ul>
<h3 id="联合索引优化"><a href="#联合索引优化" class="headerlink" title="联合索引优化"></a>联合索引优化</h3><p>再回顾下示例SQL的查询计划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65icYyQdam0TnJ04EglPRtAlaKqCZEnSla0j9GdbuXAwqjwsEQBKwqrCw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们给查询条件<code>city</code>和排序字段<code>age</code>，加个联合索引<strong>idx_city_age</strong>。再去查看执行计划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table staff add  index idx_city_age(city,age);</span><br><span class="line">explain select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65yz6tfzMfpJrIXUhLasHBDdxRm9qRpMlM7Tgo603CHMmoE6c47eN89g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以发现，加上<strong>idx_city_age</strong>联合索引，就不需要<strong>Using filesort</strong>排序了。为什么呢？因为<strong>索引本身是有序的</strong>，我们可以看下<strong>idx_city_age</strong>联合索引示意图，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65hh5Pu2cIJrytFx1YZicLJcr2NKhSvZV4lJFAocibRBAyLtFlXGq0s9Yw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>整个SQL执行流程变成酱紫：</p>
<ol>
<li>从索引idx_city_age找到满足<strong>city&#x3D;’深圳’</strong> 的主键 id</li>
<li>到<strong>主键 id索引</strong>取出整行，拿到 name、city、age 三个字段的值，作为结果集的一部分直接返回</li>
<li>从索引<strong>idx_city_age</strong>取下一个记录主键id</li>
<li>重复步骤 2、3，直到查到<strong>第10条</strong>记录，或者是<strong>不满足city&#x3D;’深圳’</strong> 条件时循环结束。</li>
</ol>
<p>流程示意图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65JtaRBnfVFzSyzI1uIWyyGPKW6wxeiaMJqyqkduCQiaP6QPq1jZxCGFoA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>从示意图看来，还是有一次<strong>回表</strong>操作。针对本次示例，有没有更高效的方案呢？有的，可以使用<strong>覆盖索引</strong>：</p>
<blockquote>
<p>★</p>
<p>覆盖索引：在查询的数据列里面，不需要回表去查，直接从索引列就能取到想要的结果。换句话说，你SQL用到的索引列数据，覆盖了查询结果的列，就算上覆盖索引了。</p>
<p>”</p>
</blockquote>
<p>我们给city，name，age 组成一个联合索引，即可用到了覆盖索引，这时候SQL执行时，连回表操作都可以省去啦。</p>
<h3 id="调整参数优化"><a href="#调整参数优化" class="headerlink" title="调整参数优化"></a>调整参数优化</h3><p>我们还可以通过调整参数，去优化order by的执行。比如可以调整sort_buffer_size的值。因为sort_buffer值太小，数据量大的话，会借助磁盘临时文件排序。如果MySQL服务器配置高的话，可以使用稍微调整大点。</p>
<p>我们还可以调整max_length_for_sort_data的值，这个值太小的话，order by会走rowid排序，会回表，降低查询性能。所以max_length_for_sort_data可以适当大一点。</p>
<p>当然，很多时候，这些MySQL参数值，我们直接采用默认值就可以了。</p>
<h2 id="使用order-by-的一些注意点"><a href="#使用order-by-的一些注意点" class="headerlink" title="使用order by 的一些注意点"></a><strong>使用order by 的一些注意点</strong></h2><h3 id="没有where条件，order-by字段需要加索引吗"><a href="#没有where条件，order-by字段需要加索引吗" class="headerlink" title="没有where条件，order by字段需要加索引吗"></a>没有where条件，order by字段需要加索引吗</h3><p>日常开发过程中，我们可能会遇到没有where条件的order by，那么，这时候order by后面的字段是否需要加索引呢。如有这么一个SQL，create_time是否需要加索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A order by create_time;</span><br></pre></td></tr></table></figure>

<p>无条件查询的话，即使create_time上有索引,也不会使用到。因为MySQL优化器认为走普通二级索引，再去回表成本比全表扫描排序更高。所以选择走全表扫描,然后根据全字段排序或者rowid排序来进行。</p>
<p>如果查询SQL修改一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A order by create_time limit m;</span><br></pre></td></tr></table></figure>

<ul>
<li>无条件查询,如果m值较小,是可以走索引的.因为MySQL优化器认为，根据索引有序性去回表查数据,然后得到m条数据,就可以终止循环,那么成本比全表扫描小,则选择走二级索引。</li>
</ul>
<h3 id="分页limit过大时，会导致大量排序怎么办"><a href="#分页limit过大时，会导致大量排序怎么办" class="headerlink" title="分页limit过大时，会导致大量排序怎么办?"></a>分页limit过大时，会导致大量排序怎么办?</h3><p>假设SQL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A order by a limit 100000,10</span><br></pre></td></tr></table></figure>

<ul>
<li>可以记录上一页最后的id，下一页查询时，查询条件带上id，如：where id &gt; 上一页最后id limit 10。</li>
<li>也可以在业务允许的情况下，限制页数。</li>
</ul>
<h3 id="索引存储顺序与order-by不一致，如何优化？"><a href="#索引存储顺序与order-by不一致，如何优化？" class="headerlink" title="索引存储顺序与order by不一致，如何优化？"></a>索引存储顺序与order by不一致，如何优化？</h3><p>假设有联合索引 idx_age_name, 我们需求修改为这样：<strong>查询前10个员工的姓名、年龄，并且按照年龄小到大排序，如果年龄相同，则按姓名降序排</strong>。对应的 SQL 语句就可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age from staff  order by age ,name desc limit 10;</span><br></pre></td></tr></table></figure>

<p>我们看下执行计划，发现使用到<strong>Using filesort</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65VrmibD2cCNg3v3E87G41k1Dzax3ibEGzKzbNV89aPYnxBIgvaw8Hibndw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这是因为，idx_age_name索引树中，age从小到大排序，如果<strong>age相同，再按name从小到大排序</strong>。而order by 中，是按age从小到大排序，如果<strong>age相同，再按name从大到小排序</strong>。也就是说，索引存储顺序与order by不一致。</p>
<p>我们怎么优化呢？如果MySQL是8.0版本，支持<strong>Descending Indexes</strong>，可以这样修改索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `staff` (</span><br><span class="line">  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键id&#x27;,</span><br><span class="line">  `id_card` varchar(20) NOT NULL COMMENT &#x27;身份证号码&#x27;,</span><br><span class="line">  `name` varchar(64) NOT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">  `age` int(4) NOT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">  `city` varchar(64) NOT NULL COMMENT &#x27;城市&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_age_name` (`age`,`name` desc) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COMMENT=&#x27;员工表&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="使用了in条件多个属性时，SQL执行是否有排序过程"><a href="#使用了in条件多个属性时，SQL执行是否有排序过程" class="headerlink" title="使用了in条件多个属性时，SQL执行是否有排序过程"></a>使用了in条件多个属性时，SQL执行是否有排序过程</h3><p>如果我们有<strong>联合索引idx_city_name</strong>，执行这个SQL的话，是不会走排序过程的，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from staff where city in (&#x27;深圳&#x27;) order by age limit 10;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65UpPoVY8QBJeKXCypp6XxTtmxY5DhwPc2eLfrtFdTL3tUqujToZna2A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>但是，如果使用in条件，并且有多个条件时，就会有排序过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from staff where city in (&#x27;深圳&#x27;,&#x27;上海&#x27;) order by age limit 10;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65mBZzGBAC5xu0PZoPndgHwrV9ELiaibMg07wiaHMc1C9U3suZkOLGniaKnQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这是因为:in有两个条件，在满足深圳时，age是排好序的，但是把满足上海的age也加进来，就不能保证满足所有的age都是排好序的。因此需要Using filesort。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F/" itemprop="url">mysql大小写敏感</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql大小写敏感"><a href="#mysql大小写敏感" class="headerlink" title="mysql大小写敏感"></a>mysql大小写敏感</h1><ol>
<li><p>查看mysql是否大小写敏感</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show VARIABLES like &#x27;lower%&#x27;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Variable_name</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>lower_case_file_system</td>
<td>ON</td>
</tr>
<tr>
<td>lower_case_table_names</td>
<td>1</td>
</tr>
</tbody></table>
<p>解析</p>
<ul>
<li><strong>lower_case_file_system</strong> 		OFF表示大小写敏感，ON表示大小写不敏感</li>
<li><strong>lower_case_table_names</strong>      0代表大小写敏感，1表示不敏感</li>
</ul>
</li>
<li><p>根据数据库表的字段属性决定是否敏感</p>
<p>collation 值为 utf8_bin时，采用二进制模式进行存储，大小写敏感</p>
<p>若为utf8_general_ci时，大小写不敏感</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/" itemprop="url">MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL-默认隔离级别是RR，为什么阿里等大厂会改成RC？"><a href="#MySQL-默认隔离级别是RR，为什么阿里等大厂会改成RC？" class="headerlink" title="MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？"></a>MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？</h1><p><a target="_blank" rel="noopener" href="https://www.51cto.com/database">数据库</a><a target="_blank" rel="noopener" href="https://www.51cto.com/mysql">MySQL</a></p>
<p>本文介绍了一些 MySQL数据库的 RR 和 RC 两种事务隔离级别。他们主要在加锁机制、主从同步以及一致性读方面存在一些差异。</p>
<p><a target="_blank" rel="noopener" href="https://s4.51cto.com/oss/202112/10/f60aed5572130a97f3bd19e4299af009.jpg"><img src="/media/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/f60aed5572130a97f3bd19e4299af009.jpg" alt="img"></a></p>
<p> 我之前写过一篇文章《为什么MySQL选择REPEATABLE READ作为默认隔离级别？》介绍过MySQL 的默认隔离级别是 Repeatable Reads以及背后的原因。</p>
<p>主要是因为MySQL在主从复制的过程是通过bin log 进行数据同步的，而MySQL早期只有statement这种bin log格式，这种格式下，bin log记录的是SQL语句的原文。</p>
<p>当出现事务乱序的时候，就会导致备库在 SQL 回放之后，结果和主库内容不一致。</p>
<p>为了解决这个问题，MySQL默认采用了Repetable Read这种隔离级别，因为在 RR 中，会在更新数据的时候增加记录锁的同时增加间隙锁。可以避免这种情况的发生。</p>
<p>关于MySQL的加锁方式及加锁原则，可以参考我写的另外一篇《求你了，别再说数据库锁的只是索引了！》，这里就不再赘述了。</p>
<p>在我知道MySQL 默认隔离级别是RR后，很长一段时间都以为应该不会有人去修改这个默认配置。</p>
<p>但是直到有一天，我们线上发生了一次死锁的问题，我在排查的过程中，才发现我们的数据库用的隔离级别没有使用默认的 RR，而是修改成了Read Committed 。（关于那次死锁排查过程，可以参考：一次数据库的死锁问题排查过程）</p>
<p>大家可以通过这个命令查看数据库当前的隔离级别： </p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation; </span><br><span class="line">1.</span><br></pre></td></tr></table></figure>

<p>那么，这里不禁就有疑问了，为啥阿里要把这个数据库隔离级别修改成 RC 呢，背后有什么思考吗？</p>
<h2 id="RR-和-RC-的区别"><a href="#RR-和-RC-的区别" class="headerlink" title="RR 和 RC 的区别"></a>RR 和 RC 的区别</h2><p>想要搞清楚这个问题，我们需要先弄清楚 RR 和 RC 的区别，分析下各自的优缺点。</p>
<h3 id="一致性读"><a href="#一致性读" class="headerlink" title="一致性读"></a>一致性读</h3><p>一致性读，又称为快照读。快照即当前行数据之前的历史版本。快照读就是使用快照信息显示基于某个时间点的查询结果，而不考虑与此同时运行的其他事务所执行的更改。</p>
<p>在MySQL 中，只有READ COMMITTED 和 REPEATABLE READ这两种事务隔离级别才会使用一致性读。</p>
<p>在 RC 中，每次读取都会重新生成一个快照，总是读取行的最新版本。</p>
<p>在 RR 中，快照会在事务中第一次SELECT语句执行时生成，只有在本事务中对数据进行更改才会更新快照。</p>
<p>在数据库的 RC 这种隔离级别中，还支持”半一致读” ，一条update语句，如果 where 条件匹配到的记录已经加锁，那么InnoDB会返回记录最近提交的版本，由MySQL上层判断此是否需要真的加锁。</p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>数据库的锁，在不同的事务隔离级别下，是采用了不同的机制的。在 MySQL 中，有三种类型的锁，分别是Record Lock、Gap Lock和 Next-Key Lock。</p>
<p>Record Lock表示记录锁，锁的是索引记录。</p>
<p>Gap Lock是间隙锁，锁的是索引记录之间的间隙。</p>
<p>Next-Key Lock是Record Lock和Gap Lock的组合，同时锁索引记录和间隙。他的范围是左开右闭的。</p>
<p>在 RC 中，只会对索引增加Record Lock，不会添加Gap Lock和Next-Key Lock。</p>
<p>在 RR 中，为了解决幻读的问题，在支持Record Lock的同时，还支持Gap Lock和Next-Key Lock；</p>
<h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p>在数据主从同步时，不同格式的 binlog 也对事务隔离级别有要求。</p>
<p>MySQL的binlog主要支持三种格式，分别是statement、row以及mixed，但是，RC 隔离级别只支持row格式的binlog。如果指定了mixed作为 binlog 格式，那么如果使用RC，服务器会自动使用基于row 格式的日志记录。</p>
<p>而 RR 的隔离级别同时支持statement、row以及mixed三种。</p>
<h2 id="为什么互联网公司选择使用-RC"><a href="#为什么互联网公司选择使用-RC" class="headerlink" title="为什么互联网公司选择使用 RC"></a>为什么互联网公司选择使用 RC</h2><h3 id="提升并发"><a href="#提升并发" class="headerlink" title="提升并发"></a>提升并发</h3><p>互联网公司和传统企业最大的区别是什么？</p>
<p><strong>高并发！</strong></p>
<p>没错，互联网业务的并发度比传统企业要高处很多。2020年双十一当天，订单创建峰值达到 58.3 万笔&#x2F;秒。</p>
<p>很多人问，要怎么做才能扛得住这么大的并发量。其实，这背后的优化多到几个小时都讲不完，因为要做的、可以做的事情实在是太多了。</p>
<p>而有一个和我们今天这篇文章有关的优化，那就是通过修改数据库的隔离级别来提升并发度。</p>
<p>为什么 RC 比 RR 的并发度要好呢？</p>
<p>首先，RC 在加锁的过程中，是不需要添加Gap Lock和 Next-Key Lock 的，只对要修改的记录添加行级锁就行了。</p>
<p>这就使得并发度要比 RR 高很多。</p>
<p>另外，因为 RC 还支持”半一致读”，可以大大的减少了更新语句时行锁的冲突；对于不满足更新条件的记录，可以提前释放锁，提升并发度。</p>
<h3 id="减少死锁"><a href="#减少死锁" class="headerlink" title="减少死锁"></a>减少死锁</h3><p>因为RR这种事务隔离级别会增加Gap Lock和 Next-Key Lock，这就使得锁的粒度变大，那么就会使得死锁的概率增大。</p>
<p> 死锁：一个事务锁住了表A，然后又访问表B；另一个事务锁住了表B，然后企图访问表A；这时就会互相等待对方释放锁，就导致了死锁。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了一些 MySQL数据库的 RR 和 RC 两种事务隔离级别。他们主要在加锁机制、主从同步以及一致性读方面存在一些差异。</p>
<p>而很多大厂，为了提升并发度和降低死锁发生的概率，会把数据库的隔离级别从默认的 RR 调整成 RC。</p>
<p>当然，这样做也不是完全没有问题，首先使用 RC 之后，就需要自己解决幻读的问题，这个其实还好，很多时候幻读问题其实是可以忽略的，或者可以用其他手段解决。</p>
<p>还有就是使用 RC 的时候，不能使用statement格式的 binlog，这种影响其实可以忽略不计了，因为MySQL是在5.1.5版本开始支持row的、在5.1.8版本中开始支持mixed，后面这两种可以代替 statement格式。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql%20%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql%20%E9%94%81/" itemprop="url">mysql 锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h1 id="1-什么是锁"><a href="#1-什么是锁" class="headerlink" title="1. 什么是锁"></a>1. 什么是锁</h1><p>​	锁是数据库系统区别于文件系统的一个关键特性。<strong>锁机制用于管理对共享资源的并发访问。</strong>InnoDB存储引擎会在行级别上对表数据上锁，这固然不错。不过InnoDB存诸引擎也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如，操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保正一致性，必须有锁的介人。<strong>数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。</strong></p>
<h1 id="2-MySQL的锁分类"><a href="#2-MySQL的锁分类" class="headerlink" title="2. MySQL的锁分类"></a>2. MySQL的锁分类</h1><blockquote>
<p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。</p>
</blockquote>
<p>MySQL大致可归纳为以下3种锁：</p>
<ul>
<li><strong>行级锁</strong>：<strong>共享锁（S Lock）、排他锁（X Lock）</strong><ul>
<li>开销大，加锁慢；</li>
<li>会出现死锁；</li>
<li>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
</ul>
</li>
<li><strong>表级锁</strong>：<strong>意向共享锁（IS Lock）、意向排他锁（IX Lock）</strong><ul>
<li>开销小，加锁快；</li>
<li>不会出现死锁；</li>
<li>锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
</ul>
</li>
<li>页面锁：<ul>
<li>开销和加锁时间界于表锁和行锁之间；</li>
<li>会出现死锁；</li>
<li>锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
</li>
</ul>
<h2 id="表锁-VS-行锁"><a href="#表锁-VS-行锁" class="headerlink" title="表锁 VS 行锁"></a>表锁 VS 行锁</h2><blockquote>
<p>表锁和行锁的概念很容易理解<strong>一个是锁定整张表****一个是锁定一行记录</strong>，那么两者有什么区别呢。</p>
</blockquote>
<p><strong>锁的粒度</strong>：表锁 &gt; 行锁 – 这是因为表锁会锁定更多的记录以及资源因此粒度比较大</p>
<p><strong>加锁效率</strong>：表锁 &gt; 行锁 – 这是因为表锁直接锁定了整个表资源而不需要向行锁一样一行行锁</p>
<p><strong>冲突概论</strong>：表锁 &gt; 行锁 – 锁整张表数据所有写的操作都需要阻塞因此冲突更多</p>
<p><strong>并发性能</strong>：表锁 &lt; 行锁 – 行锁的冲突概率小自然并发高</p>
<h2 id="2-1-行级锁"><a href="#2-1-行级锁" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h2><p><strong>InnoDB存储引擎实现了如下两种标准的行级锁</strong></p>
<table>
<thead>
<tr>
<th>锁之间的兼容性</th>
<th>读锁S</th>
<th>写锁X</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁（读锁、S Lock）</td>
<td><strong>兼容</strong></td>
<td>不兼容</td>
</tr>
<tr>
<td>排他锁（写锁、X Lock）</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>可以发现<strong>X锁与任何的锁都不兼容</strong>，而<strong>S锁仅和S锁兼容</strong>。</li>
<li>需要特别注意的是，S和X锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。</li>
</ul>
</blockquote>
<h3 id="共享锁——S-Lock"><a href="#共享锁——S-Lock" class="headerlink" title="共享锁——S Lock"></a>共享锁——S Lock</h3><blockquote>
<p>允许事务<strong>读一行</strong>数据</p>
</blockquote>
<h3 id="排他锁——X-Lock"><a href="#排他锁——X-Lock" class="headerlink" title="排他锁——X Lock"></a>排他锁——X Lock</h3><blockquote>
<p>允许事务<strong>删除或者更新一行</strong>数据</p>
</blockquote>
<h2 id="2-2-表级锁"><a href="#2-2-表级锁" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h2><p>​	InnoDB存储引擎支持多粒度（(granular〉锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。<strong>为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式</strong>，称之为**意向锁(Intention Lock)**。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度(fine granularity)上进行加锁，如下图所示：<img src="/.%5Cmedia%5C7.jpg" alt="image-20220601105306954"></p>
<ul>
<li>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是<strong>对最细粒度的对象进行上锁</strong></li>
<li>那么首先需要对粗粒度的对象上锁，如果需要对页上的记录r进行上X锁，那么分别需要对<strong>数据库A、表、页</strong>上，最后对<strong>记录r</strong>上。若<code>意向锁IX``X锁</code></li>
</ul>
<p><strong>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫意外的任何请求</strong></p>
<table>
<thead>
<tr>
<th>锁之间的兼容性</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>IS</td>
<td></td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX</td>
<td></td>
<td>兼容</td>
<td></td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td></td>
<td></td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；</li>
<li>反之，<strong>如果两者两者不兼容，该事务就要等待锁释放。</strong></li>
</ul>
<h3 id="意向共享锁——IS-Lock"><a href="#意向共享锁——IS-Lock" class="headerlink" title="意向共享锁——IS Lock"></a>意向共享锁——IS Lock</h3><blockquote>
<p>事务想要获得<strong>一张表中的某几行</strong>的共享锁</p>
</blockquote>
<h3 id="意向排他锁——IX-Lock"><a href="#意向排他锁——IX-Lock" class="headerlink" title="意向排他锁——IX Lock"></a>意向排他锁——IX Lock</h3><blockquote>
<p>事务想要获得<strong>一张表中某几行</strong>的排他锁</p>
</blockquote>
<h2 id="多版本并发控制——MVCC"><a href="#多版本并发控制——MVCC" class="headerlink" title="多版本并发控制——MVCC"></a>多版本并发控制——MVCC</h2><p>快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为<strong>多版本并发控制(Multi VersionConcurrency Control，MVCC)。</strong></p>
<p>文章可以看：<a href="https://link.juejin.cn/?target=https://blog.csdn.net/huyuyang6688/article/details/123028254">深入理解MySQL的MVCC原理</a></p>
<h2 id="2-3-一致性非锁定读"><a href="#2-3-一致性非锁定读" class="headerlink" title="2.3 一致性非锁定读"></a>2.3 一致性非锁定读</h2><p>​	一致性的非锁定读(consistent nonlocking read）是指InnoDB存储引擎通过的方式来读取当前执行时间数据库中行的数据。<code>行多版本控制（multi versioning）</code></p>
<blockquote>
<p>​	如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据。<strong>这样就不需要等待行上的X锁释放了，极大的提高了数据库的并发性</strong></p>
<p><img src="/.%5Cmedia%5C8.jpg" alt="image-20220601110046377"></p>
<p><strong>说明：快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</strong></p>
</blockquote>
<p><strong>注意：</strong></p>
<p>​	在事务隔离级别和 (InnoDB存储引擎的默认事务隔离级别)下，InnoDB存储引擎使用非锁定的一致性读。然而，对于快照数据的<strong>定义却不相同</strong>。在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在<strong>REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</strong>来看下面的一个例：<code>READ COMMITTED``REPEATABLE READ</code></p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>一样是我们的tb_user表，可以看这篇<a target="_blank" rel="noopener" href="https://juejin.cn/post/7103493390318190606#heading-13">Mysql高级——索引篇</a>的环境准备获取</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;（首次读-值1）</td>
</tr>
<tr>
<td>3</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>update tb_user set age&#x3D;50 where id &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;（值1）</td>
</tr>
<tr>
<td>6</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;（值2）</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>commit;</td>
</tr>
</tbody></table>
<h4 id="测试——REPEATABLE-READ-可重复读事务隔离级别"><a href="#测试——REPEATABLE-READ-可重复读事务隔离级别" class="headerlink" title="测试——REPEATABLE READ(可重复读事务隔离级别)"></a>测试——REPEATABLE READ(可重复读事务隔离级别)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 由于mysql数据库的更新，在旧版本中tx_isolation是作为transaction_isolation的别名被应用的，新版本已经弃用了，所以输入会显示未知变量.</span><br><span class="line">-- 新版mysql查看事务隔离级别</span><br><span class="line">SELECT @@transaction_isolation</span><br><span class="line"></span><br><span class="line">-- 旧版mysql</span><br><span class="line">SELECT @@tx_isolation;</span><br><span class="line"></span><br><span class="line">-- 设置事务隔离级别</span><br><span class="line">set session transaction isolation level  REPEATABLE READ</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578cc416f7d042c4a1c966c44cd3acc4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601140935100"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/036a2a80b86e446b87464aec05a85247~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134237107"></p>
<blockquote>
<p>– 开启事务B，进行首次读取</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0690b0c4ab1747cf98b953844258308b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134457169"></p>
<blockquote>
<p>– 开启事务A，对该条数据进行修改，<strong>将age修改为50</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf28e92e497a4a559e36eabc1b4a9ebe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134556694"></p>
<blockquote>
<p>– 此时，再回到事务B再次对该行数据进行读取，发现该行数据<strong>还是我们事务B首次读取到的数据</strong>，<strong>并没有因为事务A的更新操作而受到影响</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa39b8c3db8c4952b24ffc7c762e015c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134724021"></p>
<blockquote>
<p>– 此时对<strong>事务A进行提交操作</strong>，再次对该行数据进行读取操作，还是一样的结果（如果此时是READ COMMITTED事务隔离级别，也是一样的结果，因为事务A提交事务后，只生成了一份数据快照，该<strong>快照的age值也是23</strong>，则此时事务B读取到的是最新的一份快照数据，也是一样的）</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1a52445dd464da9b9cc3f28711ab995~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134843841"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1d07ac80fbb4d39b3ef47535e5ab76d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601135000970"></p>
<blockquote>
<p>– <strong>提交事务B</strong>后再次进行读取操作，可以看到此时读到的age值已经改变了</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/107c6b302cb343da83d9d6c0adc0a8b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601135211255"></p>
<h4 id="测试——READ-COMMITTED"><a href="#测试——READ-COMMITTED" class="headerlink" title="测试——READ COMMITTED"></a>测试——READ COMMITTED</h4><blockquote>
<p>修改事务的隔离级别为——<code>read committed</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 修改事务的隔离级别为——read committed</span><br><span class="line">set session transaction isolation level read committed</span><br><span class="line">select @@transaction_isolation</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b71a19e8ddd4289938bf951f5810426~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601141324664"></p>
<blockquote>
<p>注意：此时对于id&#x3D;1这一行的数据，已经有一个数据快照了，是age&#x3D;23的数据快照</p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;</td>
</tr>
<tr>
<td>3</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>update tb_user set age&#x3D;50 where id &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;</td>
</tr>
<tr>
<td>6</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>commit;</td>
</tr>
</tbody></table>
<blockquote>
<p>– 开启事务B，进行首次读取</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f28173bee0e148f69ba986c7979d3656~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601151924209"></p>
<blockquote>
<p>– <strong>开启事务A，进行一次更新操作，修改age为49</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f293169dc2314c2a8f4e4d84f7821f21~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152046666"></p>
<blockquote>
<p>– 在<strong>事务B</strong>中读取一次数据，<strong>依旧是50</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88b3cbb9170b4234acbea07b927b78a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152116193"></p>
<blockquote>
<p>– <strong>在事务A中提交事务后</strong>，此时数据快照多了一份是49的</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2917f27105bf46b1932c1926e972b886~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152316735"></p>
<blockquote>
<p>– 再次去到事务B中读取id&#x3D;1的该行数据，会发现读取的是最新的数据快照，<strong>此时事务B还没进行事务的提交，但是事务A进行事务的提交了</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e416ea0ea5bf4ff89adf608fb225cd14~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152407088"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><blockquote>
<p><strong>可见</strong></p>
<ul>
<li>在<strong>REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</strong></li>
<li>在<strong>READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。</strong></li>
</ul>
</blockquote>
<h2 id="2-4-一致性锁定读"><a href="#2-4-一致性锁定读" class="headerlink" title="2.4 一致性锁定读"></a>2.4 一致性锁定读</h2><p>​	在默认配置下，即事务的隔离级别为REPEATABLE READ模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。但是在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于SELECT的只读操作。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读操作：</p>
<ul>
<li><strong>共享锁（Ｓ）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE</strong></li>
<li><strong>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE</strong></li>
</ul>
<blockquote>
<ol>
<li>意向锁是InnoDB自动加的，不需用户干预。</li>
<li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及的数据集加排他锁Ｘ；</li>
<li>对于普通SELECT语句，InnoDB不会加任何锁；</li>
<li>事务可以通过上面的语句显示给记录集加共享锁或排他锁X。</li>
</ol>
<p>​    用SELECT .. IN SHARE MODE获得共享锁，主要用在需要数据依存关系时确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。</p>
<p>​    但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT … FOR UPDATE方式获取排他锁。</p>
</blockquote>
<h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 事务隔离级别设置为默认的</span><br><span class="line">set session transaction isolation level  REPEATABLE READ</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="for-update测试"><a href="#for-update测试" class="headerlink" title="for update测试"></a>for update测试</h4><table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>select * from tb_user where id&#x3D;1 for update;</td>
</tr>
<tr>
<td>3</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>update tb_user set age&#x3D;40 where id &#x3D; 2;（被阻塞）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>commit；（释放X锁）</td>
</tr>
<tr>
<td>6</td>
<td>update tb_user set age&#x3D;40 where id &#x3D; 2;（成功）</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>commit；</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>– 事务A开启事务后使用一致性的锁定读操作给id&#x3D;1的行上了X锁</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tb_user where id = 1 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/886e1cc7e5134e5980dbbe42b6f7d47e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601165621942"></p>
<blockquote>
<p>– 事务B此时开启事务，对id&#x3D;1的行进行更新操作，<strong>出现被阻塞情况</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update tb_user set age=40 where id = 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcf9cd9b682d42cdb72f3b273fa847e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601170306504"></p>
<blockquote>
<p>– 同样的使用for update操作对表上X锁（锁不兼容），<strong>一样会被阻塞</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_user where id = 1 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed32d91abb1144a39984572814eeede7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601170251538"></p>
<h4 id="lock-in-share-mode测试"><a href="#lock-in-share-mode测试" class="headerlink" title="lock in share mode测试"></a>lock in share mode测试</h4><blockquote>
<p>– <strong>事务A</strong>开启事务后使用一致性的锁定读操作给id&#x3D;1的行上了S锁</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin ;</span><br><span class="line">select * from tb_user where id=1 lock in share mode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02afdfff8c5b4c41b1f59c4f38e48acc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601170949968"></p>
<blockquote>
<p>– <strong>事务B</strong>开启事务后也请求对id&#x3D;1的行数据上S锁，因为S锁之间互相兼容，并<strong>没有出现阻塞</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tb_user where id=1 lock in share mode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88713e1a1516426d8d4f5b368aba2431~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601171112299"></p>
<blockquote>
<p>– 事务B也请求对id&#x3D;1的行数据上X锁，会<strong>出现阻塞的情况</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_user where id = 1 for update</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd8d49ae2ffa475baece156a2e4cce0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601171250234"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p><code>SELECT…FOR UPDATE</code>对读取的行记录<strong>加一个X锁</strong>，其他事务不能对已锁定的行加上任何锁。</p>
<p><code>SELECT…LOCK IN SHARE MODE</code>对读取的行记录<strong>加一个S锁</strong>，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。</p>
</blockquote>
<h2 id="非锁定读与锁定读注意点"><a href="#非锁定读与锁定读注意点" class="headerlink" title="非锁定读与锁定读注意点"></a>非锁定读与锁定读注意点</h2><blockquote>
<ol>
<li><strong>对于一致性非锁定读</strong>，即使读取的行已被执行了，也是可以进行读取的，这和之前讨论的情况一样。<code>SELECT…FOR UPDATE</code></li>
<li>此外，，必须在一个事务中，当事务提交了，锁也就释放了。<strong>因此在使用上述两句SELECT锁定语句时，务必加上BEGIN，START TRANSACTION或SETAUTOCOMMIT&#x3D;0。</strong><code>SELBCT…FOR UPDATE``SELECT…LOCK IN SHARE MODE</code></li>
</ol>
</blockquote>
<h2 id="2-5-自增长与锁——AUTO-INC-Locking"><a href="#2-5-自增长与锁——AUTO-INC-Locking" class="headerlink" title="2.5 自增长与锁——AUTO-INC Locking"></a>2.5 自增长与锁——AUTO-INC Locking</h2><p>自增长在数据库中是非常常见的一种属性，也是很多DBA或开发人员首选的主键方式。在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（ auto-increment counter)。当对含有自增长的计数器的表进行插人操作时，这个计数器会被初始化，<strong>插人操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式称做AUTO-INC Locking。**这种锁其实是**采用一种特殊的表锁机制**，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后</strong>立即释放**。</p>
<p><strong>注意点</strong>：</p>
<ul>
<li>在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第个列。</li>
<li>如果不是第一个列，则 MySQL数据库会抛出异常，而MyISAM存储引擎没有这个问题。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/222108cc4c214b7cade6f2a04aaa0369~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601201848034"></p>
<p><strong>存在的问题</strong>：</p>
<p>虽然AUTO-INC Locking 从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。</p>
<ol>
<li>首先，对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成)。</li>
<li>其次，对于 INSERT…SELECT 的大数据量的插人会影响插入的性能，因为另一个事务中的插入会被阻塞。</li>
</ol>
<h2 id="2-6-外键和锁"><a href="#2-6-外键和锁" class="headerlink" title="2.6 外键和锁"></a>2.6 外键和锁</h2><p>​    外键主要用于引用完整性的约束检查。<strong>在InnoDB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其加一个索引，因为这样可以避免表锁</strong>（这比Oracle数据库做得好，Oracle数据库不会自动添加索引，用户必须自己手动添加，这也导致了Oracle数据库中可能产生死锁。）</p>
<p><strong>注意点</strong>：</p>
<p>对于外键值的插入或更新，首先需要查询父表中的记录，即SELECT父表。但是<strong>对于父表的SELECT操作</strong>，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，<strong>因此这时使用的是SELECT…LOCK IN SHARE MODE方式</strong>，即<strong>主动对父表加一个S锁。</strong></p>
<p><strong>解释</strong>：</p>
<blockquote>
<p>设想如果这时父表上已经这样加X锁，子表上的操作会被阻塞，如下图：</p>
<p><strong>parent是父表，child是子表</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7278f865339942888c2dafb5bce8f5e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601202657505"></p>
<blockquote>
<p>设想，如果访问父表时，使用的是一致性的非锁定读，这时的Session B会读到父表有id&#x3D;3的记录，可以进行插入操作。但是如果会话A对事务提交了，则父表中就不存在id为3的记录。数据在父、子表就会存在不一致的情况。若这时用户查询，会看到如下结果:<code>INNODB_LOCKS表</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ed84fb74ba64fe7b468a398c92e39f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601203302777"></p>
<p>参数说明：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25b7e071621e42d493e91291ba505ca2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601203339844"></p>
</blockquote>
<h1 id="3-锁的算法"><a href="#3-锁的算法" class="headerlink" title="3. 锁的算法"></a>3. 锁的算法</h1><h2 id="3-1-行锁的三种算法"><a href="#3-1-行锁的三种算法" class="headerlink" title="3.1 行锁的三种算法"></a>3.1 行锁的三种算法</h2><p>InnoDB存储引擎有三种行锁的算法：</p>
<ol>
<li><strong>Record Lock</strong>：单个行记录上的锁</li>
<li><strong>Gap Lock</strong>：间隙锁，锁定一个范围，但不包含记录本身</li>
<li><strong>Next-Key Lock</strong>：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ol>
<p><strong>锁类型锁定的大致范围：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8683dbabcf4b2ca98439e1459ace52~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<blockquote>
<p>Record Lock：10</p>
<p>Gap Lock：（-∞，10），（10，20），（20，+∞）</p>
<p>Next-Key Lock：（-∞，10]，（10，20]，（20，+∞）</p>
</blockquote>
<h3 id="1️⃣Record-Lock"><a href="#1️⃣Record-Lock" class="headerlink" title="1️⃣Record Lock"></a>1️⃣Record Lock</h3><p><strong>Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</strong></p>
<blockquote>
<p>行锁是加在索引上的，<strong>如果当你的查询语句不走索引的话，那么它就会升级到表锁</strong>，最终造成效率低下，所以在写SQL语句时需要特别注意。</p>
</blockquote>
<h3 id="2️⃣Gap-Lock"><a href="#2️⃣Gap-Lock" class="headerlink" title="2️⃣Gap Lock"></a>2️⃣Gap Lock</h3><p>当我们使用范围条件而不是相等条件去检索，并请求锁时，InnoDB就会给符合条件的记录的索引项加上锁；而对于键值在条件范围内但并不存在（参考上面所说的空闲块）的记录，就叫做间隙，InnoDB在此时也会对间隙加锁</p>
<blockquote>
<ul>
<li>间隙锁只有一个目的就是在RR、SERIALIZABLE隔离级别下为了防止其他事务插入数据。</li>
<li>假如一个索引有2、4、5、9、12 五个值，那该索引可能被间隙锁锁的范围为(-∞ , 2),(2 , 4),(4 , 5),(5 , 9),(9 , 12),(12 , +∞)。</li>
</ul>
</blockquote>
<h3 id="3️⃣Next-Key-Lock"><a href="#3️⃣Next-Key-Lock" class="headerlink" title="3️⃣Next-Key Lock"></a>3️⃣Next-Key Lock</h3><p><strong>Next-Key Lock是结合了Gap Lock和 Record Lock的一种锁定算法，在Next-KeyLock算法下，InnoDB对于行的查询都是采用这种锁定算法。</strong>其目的就是为了解决Phantom Problem（幻象问题）。</p>
<blockquote>
<ul>
<li>对【某一个行记录】和【这条记录与它前一条记录之间的范围&#x2F;间隙】都上锁，这里我们称它为邻键锁。</li>
<li>假如一个索引有2、4、5、9、12 五个值，那该索引可能被邻键锁锁的范围为(-∞ , 2],(2 , 4],(4 , 5],(5 , 9],(9 , 12],(12 , +∞)。在InnoDB中，加锁的基本单位是Next-Key Lock，只不过在某些特殊情况下会退化为 Record Lock 或者 Gap Lock。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>特别说明：</strong></p>
<p>然而，<strong>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。</strong>（可在下面测试代码中看到）</p>
</blockquote>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建a作为主键（即唯一索引），b为辅助索引</span><br><span class="line">CREATE TABLE lock_test ( a INT,b INT,PRIMARY KEY(a),KEY(b));</span><br><span class="line">INSERT INTO lock_test SELECT 1,1;</span><br><span class="line">INSERT INTO lock_test SELECT 3,1;</span><br><span class="line">INSERT INTO lock_test SELECT 5,3;</span><br><span class="line">INSERT INTO lock_test SELECT 7,6;</span><br><span class="line">INSERT INTO lock_test SELECT 10,8;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63179baa8b8540d6994e222042b787e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601223051155"></p>
<h3 id="唯一索引的锁定示例"><a href="#唯一索引的锁定示例" class="headerlink" title="唯一索引的锁定示例"></a>唯一索引的锁定示例</h3><blockquote>
<p><strong>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from lock_test where a&#x3D;5 for update；</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin；</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><strong>insert into lock_test select 4,5;</strong></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>commit； #成功，不需要等待</td>
</tr>
<tr>
<td>6</td>
<td>commit；</td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d61e6c7c08841b88ec19f011f811d7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601223019835"></p>
<blockquote>
<p>– 事务A开启事务后，先给记录a&#x3D;5上一个X锁，但是因为此时a索引是主键即唯一索引，Next-Key Lock会降级为Record Lock，<strong>仅仅锁住了a&#x3D;5这一行的记录</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A先给记录a=5上一个X锁，但是因为此时a索引是主键即唯一索引，Next-Key Lock会降级为Record Lock</span><br><span class="line">begin;</span><br><span class="line">select * from lock_test where a=5 for update</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>– 事务B插入一条a&#x3D;4，b&#x3D;5的记录，<strong>因为事务A的X锁仅仅加在了a&#x3D;5这一行，所以事务B在执行插入操作时候可以正常获取X锁，并不会被阻塞</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 事务B插入一条a=4，b=5的记录，因为事务A的X锁仅仅加在了a=5这一行，所以事务B在执行插入操作时候可以正常获取X锁</span><br><span class="line">begin;</span><br><span class="line">insert into lock_test select 4,5;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/879b058e828c48e1b5be3e8b77d824df~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601223526341"></p>
<h3 id="辅助索引的锁定示例"><a href="#辅助索引的锁定示例" class="headerlink" title="辅助索引的锁定示例"></a>辅助索引的锁定示例</h3><blockquote>
<p><strong>对于辅助索引，其加上的是Next-Key Lock，锁定的是一个范围值（即Record Lock和Gap Lock的混合锁）</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from lock_test where a&#x3D;5 for update；</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin；</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><strong>select * from lock_test where b&#x3D;3 for update</strong> #阻塞</td>
</tr>
</tbody></table>
<blockquote>
<p>在上个操作的事务B中进行一致性锁定读操作，请求对辅助索引b&#x3D;3加上一个X锁，<strong>会有阻塞的出现</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 在上个操作的事务B中进行一致性锁定读操作，请求对辅助索引b=3加上一个X锁</span><br><span class="line">select * from lock_test where b=3 for update</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edb40207d579499c87f603da34fe0698~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601224329511"></p>
<blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ee5e80e1b384568b324fe7a12e26bf5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601224653635"></p>
<p><strong>说明：</strong></p>
<p>这是因为，针对辅助索引，其上锁上的是Next-Key Lock，这个邻键锁会对辅助索引的上一个键值和下一个键值上一个范围锁，示例中<strong>加X锁的辅助索引是b&#x3D;3，其上一个键值是1，后一个键值是6</strong>，故Next-Key Lock锁定的范围是 <strong>(1, 3],(3,6)<strong>，</strong>这区间内的都被加上了X锁，其他事务无法获取，若获取会被阻塞</strong></p>
<p><strong>所以，此时，因为<code>select \* from lock_test where b=3 for update</code>无法获取a&#x3D;5这一行记录的X锁而导致了事务B发生了阻塞</strong></p>
</blockquote>
<p><strong>此时重新进行操作</strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from lock_test where b&#x3D;3 for update</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>select * from lock_test where a&#x3D;5 lock in share mode; #阻塞</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>insert into lock_test select 4,2；#阻塞</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>insert into lock_test select 6,5;  #阻塞</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>insert into lock_test select 8,6;  #正常执行</td>
</tr>
</tbody></table>
<blockquote>
<p>– 事务A开启事务，对b&#x3D;3这条记录进行一致性锁读（X锁），<strong>此时被加锁的范围：(1, 3],(3,6)</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0ea27e922dc497db8b5ce755df39dac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601232131174"></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A开启事务，对b=3这条记录上锁</span><br><span class="line">begin;</span><br><span class="line">select * from lock_test where b=3 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d0fe386b01f4e55818c4e85f992ace5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601230805400"></p>
<blockquote>
<p>– 开启事务B，对a&#x3D;5的记录上X锁，会出现阻塞</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务B，对a=5的记录上X锁，会出现阻塞</span><br><span class="line">begin;</span><br><span class="line">select * from lock_test where a=5 lock in share mode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0201fcd3da1d49439cd723a1bfcbd0ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601231731724"></p>
<blockquote>
<p>– 事务B插入一条a&#x3D;4，b&#x3D;2的数据（X锁）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into lock_test select 4,2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed4bc5359f014b2594a376cf332d51d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601233714262"></p>
<blockquote>
<p>– 事务B插入一条a&#x3D;6，b&#x3D;5的数据（X锁），会出现阻塞</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into lock_test select 6,5;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82bf1d4e1a0243f58ac89ae342ebef24~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601234025094"></p>
<blockquote>
<p>解释：</p>
<p><strong>第一个SQL语句不能执行</strong>，因为在会话A中执行的SQL语句已经对聚集索引中列a &#x3D;5的值加上X锁，因此执行会被阻塞。</p>
<p>第二个SQL语句，主键插入4，没有问题，但是插人的辅助索引值2在锁定的范围(1，3)中，因此执行同样会被阻塞。</p>
<p>第三个SQL语句，插入的主键6没有被锁定，5也不在范围(1，3)之间。但插入的值5在另一个锁定的范围(3，6)中，故同样需要等待。</p>
</blockquote>
<p>而<strong>下面的SQL语句，不会被阻塞</strong>，可以立即执行:</p>
<blockquote>
<p>– 事务B插入一条a&#x3D;8，b&#x3D;6的数据（X锁），不会出现阻塞</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 下面sql</span><br><span class="line">insert into lock_test select 8,6;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edecf561fe394c6f857dcdd83780f30b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220602005321000"></p>
<h2 id="3-2-深入分析MySQL行锁加锁规则"><a href="#3-2-深入分析MySQL行锁加锁规则" class="headerlink" title="3.2 深入分析MySQL行锁加锁规则"></a>3.2 深入分析MySQL行锁加锁规则</h2><p>具体详细的可以看——》<a href="https://link.juejin.cn/?target=https://huyuyang.blog.csdn.net/article/details/123508245?spm=1001.2014.3001.5502">深入分析MySQL行锁加锁规则</a></p>
<h2 id="3-3-幻象问题（幻读）"><a href="#3-3-幻象问题（幻读）" class="headerlink" title="3.3 幻象问题（幻读）"></a>3.3 幻象问题（幻读）</h2><blockquote>
<p>Phantom Problem是指在同一事务下，<strong>连续执行两次同样的SQL语句可能导致不同的结果</strong>，第二次的SQL语句可能会返回之前不存在的行。</p>
</blockquote>
<p>​	**在默认的事务隔离级别下，即REPEATABLE READ 下，InnoDB存储引擎采用Next-Key Locking机制来避免Phantom Problem（幻像问题)**。（这点可能不同于与其他的数据库，如Oracle数据库，因为其可能需要在SERIALIZABLE的事务隔离级别下才能解决Phantom Problem。）</p>
<blockquote>
<p>此外，用户可以通过InnoDB存储引擎的Next-Key Locking机制在应用层面实现唯一性的检查。</p>
</blockquote>
<p>​	如果用户通过索引查询一个值，并对该行加上一个SLock，那么即使查询的值不在，其锁定的也是一个范围，因此若没有返回任何行，那么新插人的值一定是唯一的。也许有读者会有疑问，如果在进行第一步SELECT…LOCK IN SHARE MODE操作时，有多个事务并发操作，那么这种唯一性检查机制是否存在问题。<strong>其实并不会，因为这时会导致死锁，只有一个事务的插人操作会成功，而其余的事务会抛出死锁的错误</strong>，如表6-14所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d9f8301d124eb580f99113a870abca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220602010206860"></p>
<h1 id="4-锁问题"><a href="#4-锁问题" class="headerlink" title="4. 锁问题"></a>4. 锁问题</h1><h2 id="4-1-脏读"><a href="#4-1-脏读" class="headerlink" title="4.1 脏读"></a>4.1 脏读</h2><blockquote>
<p>脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186bf15a970b47b1aace2e5dc5138836~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601234330312"></p>
<p>事务的隔离级别进行了更换，由默认的 ——&gt;。<code>REPEATABLE READ``READ UNCOMMITTED</code></p>
<ul>
<li>可以看到，在会话A中，在事务并没有提交的前提下，会话B中的两次SELECT操作取得了不同的结果。</li>
<li>并且2这条记录是在会话A中并未提交的数据，即产生了脏读，违反了事务的隔离性。</li>
</ul>
<h2 id="4-2-不可重复读"><a href="#4-2-不可重复读" class="headerlink" title="4.2 不可重复读"></a>4.2 不可重复读</h2><blockquote>
<p>不可重复读是指在一个事务内多次读取同一数据集合。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea6a46d9c0144e888221781aa647d07~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601234514701"></p>
<ul>
<li>在事务开始前，会话A和会话B的事务隔离级别都调整为。<code>READ COMMITTED</code></li>
<li>在<strong>会话A</strong>中开始一个事务，第一次读取到的记录是1。</li>
<li>在另一个<strong>会话B</strong>中开始了另一个事务，插入一条为2的记录。</li>
<li>在没有提交之前，对<strong>会话A</strong>中的事务进行再次读取时，读到的记录还是1，没有发生脏读的现象。</li>
<li><strong>但会话B中的事务提交后</strong>，在对<strong>会话A</strong>中的事务进行读取时，这时<strong>读到是1和2两条记录</strong>。</li>
</ul>
<h2 id="4-3-丢失更新"><a href="#4-3-丢失更新" class="headerlink" title="4.3 丢失更新"></a>4.3 丢失更新</h2><blockquote>
<p>丢失更新是另一个锁导致的问题，简单来说其就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。</p>
</blockquote>
<h1 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5. 死锁"></a>5. 死锁</h1><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><blockquote>
<p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。</p>
</blockquote>
<h2 id="5-2-死锁的检测"><a href="#5-2-死锁的检测" class="headerlink" title="5.2 死锁的检测"></a>5.2 死锁的检测</h2><p>死锁的检查方法：</p>
<ol>
<li>超时机制——<strong>被动</strong>检测死锁</li>
<li>wait-for group(等待图)——主动检测死锁</li>
</ol>
<h3 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h3><p>​	解决死锁问题最简单的一种方法是超时，<strong>即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。</strong>在 InnoDB存储引擎中，参数innodb_lock_wait_timeout用来设置超时的时间。</p>
<blockquote>
<p><strong>注意：</strong>超时机制虽然简单，但是其仅通过超时后对事务进行回滚的方式来处理，或者说其是根据FIFO的顺序选择回滚对象。但若超时的事务所占权重比较大，如事务操作更新了很多行，占用了较多的undo log，这时采用FIFO的方式，就显得不合适了，因为回滚这个事务的时间相对另一个事务所占用的时间可能会很多。</p>
</blockquote>
<h3 id="wait-for-group-等待图"><a href="#wait-for-group-等待图" class="headerlink" title="wait-for group(等待图)"></a>wait-for group(等待图)</h3><p>wait-for graph要求数据库保存以下两种信息：</p>
<ol>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ol>
<p><strong>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。</strong></p>
<ul>
<li>在 wait-for graph 中，事务为图中的节点。</li>
<li>事务T1指向T2边的定义为：<ul>
<li>事务T1等待事务T2所占用的资源</li>
<li>事务T1最终等待T2所占用的资源，也就是事务之间在等待相同的资源，而事务T1发生在事务T2的后面</li>
</ul>
</li>
</ul>
<p><strong>根据下图</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/500228d94f854938b19a52968eb70808~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601214238586"></p>
<p><strong>解释：</strong></p>
<ul>
<li>在Transaction Wait Lists中可以看到共有4个事务t1、t2、t3、t4，故在wait-forgraph中应有4个节点。</li>
<li>而事务t2对row1占用x锁，事务t1对row2占用s锁。</li>
<li>事务t1需要等待事务t2中row1的资源，因此在wait-for graph中有条边从节点t1指向节点t2。</li>
<li>事务t2需要等待事务t1、t4所占用的row2对象，故而存在节点t2到节点t1、t4的边。</li>
<li>同样，存在节点t3到节点t1、t2、t4的边，因此最终的wait-for graph，如图6-6所示。</li>
</ul>
<p><strong>产生的wait-for group(等待图)</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2df0b5dfec904dc4821fce32e01fbb6f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601214259726"></p>
<blockquote>
<p><strong>通过图6-6可以发现存在回路(t1，t2)，因此存在死锁。</strong></p>
<p>通过上述的介绍，可以发现wait-for graph是一种较为主动的死锁检测机制，<strong>在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务。</strong></p>
</blockquote>
<h2 id="5-3-死锁的示例"><a href="#5-3-死锁的示例" class="headerlink" title="5.3 死锁的示例"></a>5.3 死锁的示例</h2><p><strong>表结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t (</span><br><span class="line">	a INT PRIMARY KEY</span><br><span class="line">)ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">INSERT INTO t VALUES (1), (2), (4), (5);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>经典的AB-BA死锁</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b424e5c1442413cba047b6cc631feda~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601214725244"></p>
<blockquote>
<p><strong>解释</strong>：</p>
<p>在上述操作中，会话B中的事务抛出了1213这个错误提示，即表示事务发生了死锁。</p>
<p>死锁的原因是<strong>会话A和B的资源在互相等待</strong>。大多数的死锁InnoDB存储引擎本身可以侦测到，不需要人为进行干预。</p>
<p>但是在上面的例子中，在<strong>会话B</strong>中的事务抛出死锁异常后，<strong>会话A</strong>中马上得到了记录为2的这个资源，这其实是因为会话B中的事务发生了回滚，否则会话A中的事务是不可能得到该资源的。</p>
<p><strong>因为InnoDB存储引擎并不会回滚大部分的错误异常，但是死锁除外。发现死锁后，InnoDB存储引擎会马上回滚一个事务，这点是需要注意的。因此如果在应用程序中捕获了1213这个错误，其实并不需要对其进行回滚。</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfea99ffcf234e94816198857400dab0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601215650438"></p>
<blockquote>
<p>可以看到，<strong>会话A</strong>中已经对持有了X锁，但是<strong>会话A</strong>中插人时会导致死锁发生。<code>记录4``记录3</code></p>
<p>这个问题的产生是由于<strong>会话B</strong>中请求的S锁而发生等待，但之前请求的锁对于主键值记录1、2都已经成功，若在事件点5能插入记录，那么<strong>会话B</strong>在获得持有的S锁后，还需要向后获得的记录，这样就显得有点不合理。<code>记录4``记录4``记录3</code></p>
<p>因此InnoDB存储引擎在这里主动选择了死锁，而回滚的是undo log记录大的事务，这与AB-BA死锁的处理方式又有所不同。</p>
</blockquote>
<blockquote>
<p>资料来源——&gt;《MySQL技术内幕》</p>
<p><a href="https://link.juejin.cn/?target=https://huyuyang.blog.csdn.net/article/details/123508245?spm=1001.2014.3001.5502">深入分析MySQL行锁加锁规则</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/tags.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/shoushi" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liqun.guan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Shoushi`s Notes" type="application/atom+xml" />






<meta name="description" content="只是做些力所能及的事罢了">
<meta property="og:type" content="website">
<meta property="og:title" content="Shoushi&#96;s Notes">
<meta property="og:url" content="http://localhost:4000/index.html">
<meta property="og:site_name" content="Shoushi&#96;s Notes">
<meta property="og:description" content="只是做些力所能及的事罢了">
<meta property="og:locale">
<meta property="article:author" content="liqun.guan">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://localhost:4000/"/>





  <title>Shoushi`s Notes</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shoushi`s Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/index" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/me" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/%E9%94%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/%E9%94%81%E8%AF%A6%E8%A7%A3/" itemprop="url">MySQL——锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL——锁（全面总结）"><a href="#MySQL——锁（全面总结）" class="headerlink" title="MySQL——锁（全面总结）"></a>MySQL——锁（全面总结）</h1><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁机制用于管理对共享资源的并发访问。</p>
<h2 id="lock和latch"><a href="#lock和latch" class="headerlink" title="lock和latch"></a>lock和latch</h2><p>在<a target="_blank" rel="noopener" href="https://cloud.tencent.com/solution/database?from=10680">数据库</a>中，lock和Latch都称为锁，但是两者意义不同。</p>
<p>latch称为闩锁（shuang suo），其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又分为mutex互斥锁 和 rwLock读写锁。其目的是为了保证并发线程操作临界资源的正确性。通常没有死锁的检测机制。</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620.jpeg" alt="img"></p>
<p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或者rollback后进行释放。有死锁检测机制。</p>
<p>通过<code>show engine innodb mutex</code>可以查看InnoDB存储引擎的中latch，具体字段详情如下表：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842881.jpeg" alt="img"></p>
<h2 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h2><p>有几个索引，需要分别向索引加锁。</p>
<h3 id="共享锁、排他锁"><a href="#共享锁、排他锁" class="headerlink" title="共享锁、排他锁"></a>共享锁、排他锁</h3><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p>
<p><strong>共享锁（S Lock）</strong>：允许事务读一行数据</p>
<p><strong>排他锁（X Lock）</strong>：允许事务删除 或 更新一行数据</p>
<p>如果一个事务T1已经获取了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁。因为读取并不会改变行的数据，所以可以多个事务同时获取共享锁，称这种情况为<strong>锁兼容</strong>。但若有其他的事务T3想获得行R的排他锁，则其必须等待事务T1、T2释放行r上面的共享锁，称这种情况为<strong>锁不兼容</strong>。下面显示了共享锁和排他锁的兼容性：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842892.jpeg" alt="img"></p>
<p>从表6-3可以看出X锁与任何锁都不兼容，而S锁仅和S锁兼容。S锁和X锁都是行锁，兼容是指对同一行记录锁的兼容情况。</p>
<p><strong>普通 select 语句默认不加锁，而CUD操作默认加排他锁。</strong></p>
<h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>Record Lock，<strong>仅锁定一行记录</strong>（如共享锁、排他锁）</p>
<ul>
<li>记录锁总是会去锁定索引记录，如果表在建立的时候，没有设置任何一个索引，那么InnoDB会使用隐式的主键来进行锁定。</li>
<li>查询条件的列是唯一索引的情况下，临键锁退化为记录锁</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>Gap Lock，<strong>锁定一个范围，但不包含记录本身。</strong></p>
<p>关闭间隙锁的2种方式：</p>
<p>（1）将事务隔离级别变为read committed</p>
<p>（2）将参数innodb_locks_unsafe_for_binlog设置为1</p>
<p>在上述配置下，除了外键和唯一性检查依然需要间隙锁，其余情况仅适用行锁进行锁定。</p>
<h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><p>Next-Key Lock，等于记录锁 + 间隙锁，<strong>锁定一个范围，并且锁定记录本身</strong>。主要是阻止多个事务将记录插入到同一个范围内，从而避免幻读。</p>
<p>假如一个索引有10、11、13、20这四个值，那么该索引可能被锁定的区间为：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842893.jpeg" alt="img"></p>
<p>若事务T1已经通过临键锁锁定了如下范围： </p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842894.jpeg" alt="img"></p>
<p>当插入新的记录12时，则锁定的范围变成：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842895.jpeg" alt="img"></p>
<p><strong>当查询的索引是唯一索引的时候，InnoDB会将临键锁优化成记录锁，从而提高并发</strong>。这时候，将不再由间隙锁避免幻读的问题。</p>
<p>在可重复读的情况下，MVCC的SELECT操作只会查找行版本号小于当前事务版本号的记录，其他事务（事务开启时间比当前事务晚）新插入的记录版本号不满足条件，就不会查出来。</p>
<p>对于辅助索引，当执行类似<code>select * from z where b = 3 for update;</code>加锁语句时，会加上临键锁，并且下一个键值的范围也会加上间隙锁。（这里参考《<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a>技术内幕》，里面有具体例子）</p>
<p>值得注意的是，对于唯一键值的锁定，由临键锁优化为记录锁，仅存在于<strong>查询所有的唯一索引</strong>。若唯一索引由多列组成，而查询仅是查找多个唯一索引中的一个，那么查询其实是range类型查询，而不是point类型查询，故InnoDB存储引擎还是继续使用临键锁。</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842906.jpeg" alt="img"></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842907.jpeg" alt="img"></p>
<p>在InnoDB存储引擎中，通过使用临键锁来避免不可重复读的问题（即幻读）。在使用临键锁的情况下，对于索引的扫描，不仅仅锁住扫描的到索引，而且还锁住这些索引覆盖的范围。因此，在这些范围内插入都是不允许的。这样子就避免了其他事务在这些范围内插入数据导致不可重复读的问题。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>概念：<strong>事务可能要加共享&#x2F;排它锁了，先提前声明一个意向</strong></p>
<p>意向锁有这样一些特点：</p>
<p>（1）意向锁是表级别的锁</p>
<p>（2）意向锁分为：</p>
<ul>
<li><strong>意向共享锁</strong>(intention shared lock, IS)，它预示着，事务有意向对表中的<strong>某些行</strong>加共享S锁 </li>
<li><strong>意向排它锁</strong>(intention exclusive lock, IX)，它预示着，事务有意向对表中的<strong>某些行</strong>加排它X锁</li>
</ul>
<p>（3）意向锁协议：</p>
<ul>
<li><strong>事务要获得某些行的共享锁，必须先获得表的意向共享锁IS</strong></li>
<li><strong>事务要获取某些行的排他锁，必须先获得表的意向排他锁IX</strong></li>
</ul>
<p>（4）由于意向锁仅仅表明意向，它其实是比较弱的锁，<strong>意向锁之间并不相互互斥，而是可以并行</strong>，其<strong>兼容互斥表</strong>如下：</p>
<p>​          IS          IX</p>
<p>IS      兼容      兼容</p>
<p>IX      兼容      兼容</p>
<p>（5）既然意向锁之间都相互兼容，<strong>那其意义在哪里呢</strong>？它会与共享锁&#x2F;排它锁互斥，其<strong>兼容互斥表</strong>如下：</p>
<p>​          S          X</p>
<p>IS      兼容      互斥</p>
<p>IX      互斥      互斥</p>
<p>（排它锁是很强的锁，不与其他类型的锁兼容。这也很好理解，修改和删除某一行的时候，必须获得强锁，禁止这一行上的其他并发，以保障数据的一致性。）</p>
<p>InnoDB支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。<strong>为了支持不同粒度上进行加锁操作</strong>，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更粗的粒度上进行加锁。如图6-3所示：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842908.jpeg" alt="img"></p>
<p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象上锁，那么首先需要对粗粒度的对象进行上锁。如上图，如果需要对页上的记录上X锁，那么需要分别对数据库A、表、页 上意向锁IX，最后对记录r上排他锁X。</p>
<p>若其中任何一部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，事务T1在对记录r加X锁之前，已有事务T2对表1进行了S表锁，那么表1上面已经存在S锁，之后事务T1试图在表1上加IX锁（获取记录r的X锁必须先获取表1的IX锁），由于不兼容，所以事务T1需要等待事务T2释放表锁。</p>
<h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>对已有数据行的<strong>修改与删除</strong>，必须排他锁，那对于<strong>数据的插入</strong>，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。</p>
<p><strong>插入意向锁</strong>，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），<strong>它是专门针对insert操作的</strong>。</p>
<p>它的用处是：<strong>多个事务，在同一个索引上插入记录时，如果插入的位置不冲突，不会阻塞彼此。</strong></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">在<span class="title class_">MySQL</span>，<span class="title class_">InnoDB</span>，<span class="variable constant_">RR</span>下：</span><br><span class="line"></span><br><span class="line"><span class="title function_">t</span>(id unique <span class="variable constant_">PK</span>, name);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">数据表中有数据：</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>, shenjian</span><br><span class="line"></span><br><span class="line"><span class="number">20</span>, zhangsan</span><br><span class="line"></span><br><span class="line"><span class="number">30</span>, lisi</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">事务A先执行，在<span class="number">10</span>与<span class="number">20</span>两条记录中插入了一行，还未提交：</span><br><span class="line"></span><br><span class="line">insert into t <span class="title function_">values</span>(<span class="number">11</span>, xxx);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">事务B后执行，也在<span class="number">10</span>与<span class="number">20</span>两条记录中插入了一行：</span><br><span class="line"></span><br><span class="line">insert into t <span class="title function_">values</span>(<span class="number">12</span>, ooo);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>)会使用什么锁？</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)事务B会不会被阻塞呢？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">回答：虽然事务隔离级别是<span class="variable constant_">RR</span>，虽然是同一个索引，虽然是同一个区间，但插入的记录并不冲突，故这里：</span><br><span class="line"></span><br><span class="line">使用的是插入意向锁</span><br><span class="line"></span><br><span class="line">并不会阻塞事务B</span><br></pre></td></tr></table></figure>

<p>复制</p>
<h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><p>自增锁是MySQL一种特殊的锁，如果<strong>表中存在自增字段，MySQL便会自动维护一个自增锁。</strong></p>
<p>在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长计数器的表进行插入操作时，这个计数器会被初始化，执行如下操作来得到计数器的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(auto_inc_col) from t for </span><br></pre></td></tr></table></figure>

<p>插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式成为<strong>Auto-Inc Locking</strong>。这种锁其实是采用一种表锁的机制，为了提高插入的性能，<strong>自增长锁不是在一个事务完成以后才释放，而是在完成自增长值插入的SQL后立即释放。</strong></p>
<p>虽然<strong>Auto-Inc Locking</strong>从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成）。</p>
<p>从MySQL5.12版本开始，InnoDB存储引擎提供了一种轻量级互斥量的自增长实现方式。这种方式大大提高了自增长值插入的性能。并且从该版本开始，InnoDB存储引起提供了一个参数innodb_innodb_autoinc_lock_mode来控制自增长模式，该参数的默认值为1。首先看下<strong>自增长的插入分类</strong>，如下图：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-16702966842909.jpeg" alt="img"></p>
<p>下图展示了innodb_innodb_autoinc_lock_mode的不同值对自增的影响：（<strong>值为1、2的时候，看不懂。。</strong>）</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429110.jpeg" alt="img"></p>
<p>InnoDB存储引擎中自增长的实现和MyISAM不同。<strong>MyISAM存储引擎是表锁设计，自增长不用考虑并发插入的问题</strong>。<strong>在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列</strong>，如果不是第一个列，则MySQL会抛出异常。MyISAM存储引擎没有这个问题。</p>
<p>参考：<a target="_blank" rel="noopener" href="http://blog.itpub.net/15498/viewspace-2141640/">http://blog.itpub.net/15498/viewspace-2141640/</a></p>
<h3 id="外键与锁"><a href="#外键与锁" class="headerlink" title="外键与锁"></a>外键与锁</h3><p><strong>如果没有为外键显式添加索引，InnoDB自动为外键创建索引，这样子避免表锁。</strong></p>
<p>对于外键值的插入或更新，首先需要查询父表中的记录，即select父表。但不使用一致性非锁定读，因为这样子会发生数据不一致的问题。因此这时使用的是select…lock in share mode，即主动对父表加一个共享锁（这也解释了为了外键一定要索引，如果没有索引，就只能使用表锁了）。如果这时父表已经加了X锁，子表上面的操作将会被阻塞，如下图：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429111.jpeg" alt="img"></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429212.jpeg" alt="img"></p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MVCC数据多版本又称为<strong>一致性非锁定读</strong>。指<strong>InnoDB通过行多版本控制的方式来读取当前数据库中行的数据</strong>。如果读取的行正在执行delete或者update操作，这时读操作不会因此去等待行上锁的释放。相反的，InnoDB存储引擎会去读取行的一个快照数据。</p>
<p>在默认配置下，即事务的隔离界别为<strong>REPEATABLE READ（可重复读）</strong>模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。</p>
<p>快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</p>
<p>非锁定度机制极大的提高了数据库的并发性。这是InnoDB默认的读取方式，即读取不会占用表上的锁。但是在不同事务隔离界别下，读取的方式不同，并不是在每个事务隔离界别下都是采用非锁定的一致性读。此外，即使都是使用非锁定的一致性读，但是对于快照数据的定义也是各不相同。</p>
<p>快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。<strong>一个行记录可能有不止一个快照数据</strong>，一般称这种技术为<strong>行多版本技术</strong>，由此带来的并发控制，称之为<strong>多版本并发控制</strong> MVCC。</p>
<p>在<strong>事务隔离界别read committed 和 repeatable read</strong>（InnoDB默认的事务隔离界别）下，InnoDB使用非锁定一致性读。然而，对于快照数据的定义却不相同。</p>
<ul>
<li>在read committed隔离级别下，非一致性读总是读取被锁定行的最新一份快照数据（如果没有被锁定，则读取行的最新数据；如果行锁定了，则读取该行的最新一个快照）。</li>
<li>在repeatable read事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的快照。</li>
</ul>
<h3 id="MVCC的优缺点"><a href="#MVCC的优缺点" class="headerlink" title="MVCC的优缺点"></a>MVCC的优缺点</h3><p>MVCC在大多数情况下代替了行锁，<strong>实现了对读的非阻塞，读不加锁，读写不冲突</strong>，极大的提高了读效率。</p>
<p>缺点是每行记录都需要<strong>额外的存储空间</strong>，需要做更多的行维护和检查工作。</p>
<p>注意<strong>写写不能并行</strong>。一个事务的写操作是会加排他锁的，其他事务如果对该记录进行修改，必须等待之前的事务释放锁。</p>
<h3 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h3><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>undo log是为回滚而用，具体内容就是复制事务开始前的<strong>行</strong>到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。在Innodb中，undo log被划分为多个段，具体某行的undo log就保存在某个段中，称为回滚段。<strong>可以认为undo log和回滚段是同一意思</strong>。</p>
<p>为了便于理解MVCC的实现原理，这里简单介绍一下undo log的工作过程</p>
<p>在不考虑redo log 的情况下利用undo log工作的简化过程为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">序号	动作</span><br><span class="line"><span class="number">1</span>	   开始事务</span><br><span class="line"><span class="number">2</span>		 记录数据行数据备份到undo log</span><br><span class="line"><span class="number">3</span>		 更新数据</span><br><span class="line"><span class="number">4</span>		 将undo log写到磁盘</span><br><span class="line"><span class="number">5</span>		 提交事务</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>（1）undo log的持久化必须在在数据持久化之前，这样才能保证系统崩溃时，可以用undo log来回滚事务</p>
<p>（2）Innodb通过undo log保存了已更改行的旧版本的快照。</p>
<p>（3）提交事务做的事情有：写redo log和binlog，并且把数据持久化到磁盘（可以通过参数控制）</p>
<h4 id="InnoDB中的隐藏列"><a href="#InnoDB中的隐藏列" class="headerlink" title="InnoDB中的隐藏列"></a>InnoDB中的隐藏列</h4><p>InnoDB的内部实现中为每一行数据增加了三个隐藏列用于实现MVCC。</p>
<table>
<thead>
<tr>
<th align="left">列名</th>
<th align="left">长度(字节)</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DB_TRX_ID</td>
<td align="left">6</td>
<td align="left">插入或更新行的最后一个事务的事务ID。（删除视为更新，将其标记为已删除）</td>
</tr>
<tr>
<td align="left">DB_ROLL_PTR</td>
<td align="left">7</td>
<td align="left">写入回滚段的撤消日志记录（若行已更新，则撤消日志记录包含在更新行之前重建行内容所需的信息）</td>
</tr>
<tr>
<td align="left">DB_ROW_ID</td>
<td align="left">6</td>
<td align="left">行ID（隐藏单调自增id）</td>
</tr>
</tbody></table>
<p>一行记录的结构如下：</p>
<table>
<thead>
<tr>
<th align="left">数据列</th>
<th align="left">…</th>
<th align="left">DB_ROW_ID</th>
<th align="left">DB_TRX_ID</th>
<th align="left">DB_ROLL_PTR</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="MVCC的SQL规则"><a href="#MVCC的SQL规则" class="headerlink" title="MVCC的SQL规则"></a>MVCC的SQL规则</h4><p>MVCC只在READ COMMITED 和 REPEATABLE READ 两个隔离级别下工作。READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE 则会对所有读取的行都加锁。另外事务的版本号是递增的。</p>
<p><strong>SELECT</strong></p>
<p>InnoDB只查找 行的事务ID 小于当前事务ID 的数据行（避免幻读）</p>
<p><strong>INSERT</strong></p>
<p>新插入的每一行保存当前事务ID作为行的事务ID</p>
<p><strong>DELETE</strong></p>
<p>删除的每一行保存当前事务ID作为行的事务ID</p>
<p><strong>UPDATE</strong></p>
<p>实际上是删除旧行，插入新行。</p>
<p>保存当前的事务ID作为新行的事务ID，同时保存当前事务ID到旧行的事务ID。</p>
<h4 id="MVCC插入示例"><a href="#MVCC插入示例" class="headerlink" title="MVCC插入示例"></a>MVCC插入示例</h4><p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429213.jpeg" alt="img"></p>
<p>F1F6是字段名称，16是对应的数据。后面3个隐藏字段分别对应行ID、事务ID、回滚指针。</p>
<p><strong>初始状态</strong></p>
<p>假如有一条初始的数据，可以认为行ID为1，其他两个字段为空。</p>
<p><strong>事务1更改该行的值</strong></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429314.jpeg" alt="img"></p>
<p>当事务1更改该行的值时，会进行如下操作：</p>
<ul>
<li>用排他锁锁定该行</li>
<li><strong>把该行修改前的值复制到undo log</strong>，即上图中下面的行</li>
<li>使回滚指针指向undo log中的行</li>
<li>修改当前的行的值，填写事务编号</li>
<li>释放锁</li>
</ul>
<p><strong>事务2更改该行的值</strong></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429315.jpeg" alt="img"></p>
<p>与事务1相同，此时undo log中有2条记录，并且通过回滚指针连在一起。</p>
<p>因此，如果undo log一直不删除，则可以通过当前记录的回滚指针回溯到该行创建时的初始内容，所幸的是在<strong>InnoDB中存在清理线程，它会查询比现在最老的事务还早的undo log，并删除它们，从而保证undo log文件不会无限增长</strong>。</p>
<h4 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h4><p>主要用来判断当前版本数据的可见性。</p>
<p>在InnoDB中，创建一个新事务的时候，InnoDB会将当前系统中的活跃事务列表（trx_sys-&gt;trx_list）创建一个副本（read view），副本中保存的是系统当前不应该被本事务看到的其他事务id列表。当用户在这个事务中要读取该行记录的时候，innodb会将该行当前的版本号与该read view进行比较。 具体的算法如下:</p>
<ol>
<li>设该行的当前事务id为trx_id_0，read view中最早的事务id为trx_id_1, 最迟的事务id为trx_id_2。</li>
<li>如果trx_id_0&lt; trx_id_1的话，那么表明该行记录所在的事务已经在本次新事务创建之前就提交了，所以该行记录的当前值是可见的。跳到步骤6.</li>
<li>如果trx_id_0&gt;trx_id_2的话，那么表明该行记录所在的事务在本次新事务创建之后才开启，所以该行记录的当前值不可见.跳到步骤5。</li>
<li>如果trx_id_1&lt;&#x3D;trx_id_0&lt;&#x3D;trx_id_2, 那么表明该行记录所在事务在本次新事务创建的时候处于活动状态，从trx_id_1到trx_id_2进行遍历，如果trx_id_0等于他们之中的某个事务id的话，那么不可见。跳到步骤5.</li>
<li>从该行记录的DB_ROLL_PTR指针所指向的回滚段中取出最新的undo-log的版本号，将它赋值该trx_id_0，然后跳到步骤2.</li>
<li>将该可见行的值返回。</li>
</ol>
<p>需要注意的是，新建事务(当前事务)与正在内存中commit 的事务不在活跃事务链表中。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>读操作远远大于写操作的场景，因此适用于绝大多数互联网场景。</p>
<h2 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h2><p>在默认的配置下，即事务的隔离级别为可重复度，InnoDB存储引擎的select操作使用一致性非锁定读（即MVCC）。但是在某些情况下，用户需要显示的对数据库读取操作进行加锁，以保证数据逻辑的一致性。而这要求数据库支持加锁语句，InnoDB存储引擎对select支持两种一致性的锁定读操作：</p>
<ul>
<li>select …  for update</li>
<li>select … lock in share mode;</li>
</ul>
<p><strong>select…for update对读取的行记录加一个X锁</strong>，其他事务不能对已锁定的行加上任何锁。</p>
<p><strong>select…lock in share mode对读取的行记录加一个S锁</strong>，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。</p>
<p>对于一致性非锁定读，即时读取的行已经被执行了select…for update，也是可以进行读取的。</p>
<p>select…for update或者select…lock in share mode必须在事务中，因为当事务提交了，锁也就释放了。从而避免锁没有释放，可能导致死锁的情况。</p>
<p><strong>如果不加筛选条件（或者筛选条件不走索引），会升级为表锁</strong></p>
<p><strong>索引数据重复率太高会导致全表扫描：当表中索引字段数据重复率太高，则MySQL可能会忽略索引，进行全表扫描，此时使用表锁。可使用 force index 强制使用索引。</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012099869/article/details/52778728">https://blog.csdn.net/u012099869/article/details/52778728</a> </p>
<h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>脏数据</strong>：指的是<strong>事务对缓冲池中行记录的修改，并且还没有提交</strong>。即事务未提交的数据。</p>
<p><strong>脏读</strong>：指当前事务可以读到其他事务的未提交的数据。如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，显然违反了事务的隔离性。</p>
<p><strong>脏读的条件</strong>：需要事务的隔离级别为<strong>读未提交</strong>。</p>
<p><strong>示例</strong>：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429316.jpeg" alt="img"></p>
<p><strong>解决</strong>：设置事务的隔离级别为“读已提交”或者更高的隔离界别。</p>
<p>​    那<strong>为什么“读已提交”能解决脏读的问题？</strong>  我的理解是，在“读已提交”的情况下，读取的是快照的最新版本的数据，那么既然读取的是快照数据了，那么这些数据肯定是之前的事务提交过了的。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>不可重复读</strong>：指在在一个事务内多次读取同一个数据集合，在这个事务还没有结束时，另外一个事务也访问了同一个数据集合，并且做了一些修改或新增操作。因此，在第一个事务的两次读数据之间，由于第二个事务的修改，第一个事务两次读取到的数据可能是不一样的（具体看隔离级别）。这种称为<strong>不可重复读</strong>。</p>
<p><strong>示例</strong>：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429317.jpeg" alt="img"></p>
<p><strong>幻读：同一事务下，连续执行2次相同的sql，可能返回不同的结果，第二次的sql可能返回之前不存在的行。</strong></p>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p><strong>丢失更新</strong>：指一个事务的更新操作被另外一个事务的更新操作所覆盖，从而导致数据的不一致。</p>
<p><strong>丢失更新的实例</strong>：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429318.jpeg" alt="img"></p>
<p><strong>解决办法</strong>：对用户读取的记录加上一个排他锁，这样子其他事务就必须等待前一个事务的完成。从而避免并发问题。</p>
<p><strong>解决办法的示例</strong>：</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429419.jpeg" alt="img"></p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p><strong>阻塞</strong>：事务因为等待其他事务释放锁而等待</p>
<p><strong>超时</strong>：等待其他事务释放锁，超过超时时间，就认为是超时。</p>
<p><strong>innodb_lock_wait_timeout</strong>：用来控制超时时间，默认是50秒。可以在MYSQL运行时进行设置。</p>
<p><strong>innodb_rollback_on_timeout</strong>：用来设定是否在等待超时时对进行中的事务进行回滚操作。默认是OFF，不回滚。不可以在MySQL启动时进行修改。用户在超时的情况下，必须判断是是否需要commit或者rollback，之后再进行下一步的操作。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><strong>概念</strong>：死锁是指两个或者两个以上的事务，因争夺资源而造成的一种互相等待的现象。若无外力作用，所有事务都将无法推进下去。</p>
<h3 id="FIFO处理死锁"><a href="#FIFO处理死锁" class="headerlink" title="FIFO处理死锁"></a>FIFO处理死锁</h3><p><strong>解决数据库死锁最简单的方法</strong>：设置超时时间。即当两个事务互相等待时，当一个等待时间超过设置的阈值时，其中一个事务进行回滚，另外一个等待的事务就能继续执行。</p>
<p>超时机制虽然简单，但是其使用FIFO的方式来选择超时回滚的事务，假如第一个超时的事务 更新了很多行，远比第二个事务多，因此占用了更多的undo log，这时FIFO的方式，就显得不适用了，因为第一个事务回滚时间明显比第二个事务回滚时间长很多。</p>
<h3 id="等待图"><a href="#等待图" class="headerlink" title="等待图"></a>等待图</h3><p>因为FIFO处理死锁可能不适用，所以数据库普遍采用了wait-for graph（等待图）的方式来进行死锁检测。和超时机制比较，这是一种更为主动的死锁检测方式，InnoDB也采用了这种方式。</p>
<p>等待图要求数据库保存以下两种信息：</p>
<p>（1）锁的信息链表（见图6-5 右）</p>
<p>（2）事务等待链表（见图6-5 左）</p>
<p>通过上述链表可以构造出一张图，而在这个<strong>图中存在回路，则代表存在死锁</strong>。在等待图中，事务为图中的节点。在图中，事务T1指向事务T2边的定义为：</p>
<p>（1）事务T1等待事务T2所占用的资源</p>
<p>（2）事务之间在等待相同的资源，而事务T1在事务T2之后</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429420.jpeg" alt="img"></p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429421.jpeg" alt="img"></p>
<p>发现死锁后，InnoDB会马上回滚一个undo量最小的事务。 </p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p><strong>概念</strong>：<strong>将当前锁的粒度降低，比如说把行锁升级为表锁，那样子会导致并发性能降低。</strong></p>
<p>InnoDB不是根据每个记录来产生行锁的，而是根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式，因此不管一个事务锁住页中一条还是多条记录，都是用一个锁，其开销通常是一致的。</p>
<p><img src="/media/%E9%94%81%E8%AF%A6%E8%A7%A3/1620-167029668429422.jpeg" alt="img"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>快照读、当前读指的是什么，有什么区别？</strong></p>
<p>快照读:</p>
<ul>
<li>读取数据的备份，不用加锁，这个数据可能是旧数据.</li>
<li>比如说普通的select语句。</li>
</ul>
<p>当前读:</p>
<ul>
<li>读取的数据最新版本 </li>
<li>读数据的时候会加上锁，保证其他事务不会并发修改这条记录。 </li>
<li>如select … lock in share mode select … for update 	insert 	update 	delete</li>
</ul>
<p>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/%E6%85%A2%E6%9F%A5%E8%AF%A2/" itemprop="url">MySQL慢查询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="你的哪些SQL慢？看看MySQL慢查询日志吧"><a href="#你的哪些SQL慢？看看MySQL慢查询日志吧" class="headerlink" title="你的哪些SQL慢？看看MySQL慢查询日志吧"></a>你的哪些SQL慢？看看MySQL慢查询日志吧</h1><p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/c54e191f715b46f790314f91ee307dd9tplv-k3u1fbpfcp-zoom-crop-mark3024302430241702.awebp" alt="你的哪些SQL慢？看看MySQL慢查询日志吧"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在项目里面，多多少少都隐藏着一些执行比较慢的SQL, 不同的开发测试人员在平时使用的过程中多多少少都能够遇到，但是无法立马有时间去排查解决。那么如果有一个文件能够将这些使用过程中比较慢的SQL记录下来，定期去分析排查，那该多美好啊。这种情况MySQL也替我们想到了，它提供了SQL慢查询的日志，本文就分享下如何使用吧。</p>
<h2 id="什么是慢查询日志？"><a href="#什么是慢查询日志？" class="headerlink" title="什么是慢查询日志？"></a>什么是慢查询日志？</h2><p>MySQL的慢询日志，提供了记录在MySQL中响应时间超过指定阈值语句的功能，比如设定阈值为3秒，那么任何SQL执行超过3秒都会被记录下来。</p>
<p>我们借助慢查询日志功能可以发现哪些那些执行时间特别长的询，并且有针对性地进行优化，从而提高系统的整体效率。</p>
<h2 id="怎么开启慢查询日志？"><a href="#怎么开启慢查询日志？" class="headerlink" title="怎么开启慢查询日志？"></a>怎么开启慢查询日志？</h2><p>默认情况下，MySQL数据库<strong>没有开启</strong>慢查询日志，因为多多少少会带来一定性能的影响。我们可以在开发测试环境、或者生产环境做调优的时候开启，<strong>那怎么查看是否开启了呢？</strong></p>
<ol>
<li><strong>查看慢SQL是否开启</strong></li>
</ol>
<p>执行下面命令查看是否开启慢SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/d27eadf02574490392490f937b367416tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ul>
<li><code>OFF</code>: 未开启</li>
<li><code>ON</code>: 开启</li>
</ul>
<ol>
<li><strong>如何开启慢查询</strong></li>
</ol>
<p>执行下面的命令开启慢查询日志</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> set global <span class="attr">slow_query_log</span>=<span class="string">&#x27;ON&#x27;</span><span class="comment">;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/25c5256478534072aeaeae967b8a164btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ol>
<li><strong>修改慢查询阈值</strong></li>
</ol>
<p>前面介绍了SQL执行到达了制定的时间阈值后记录到慢查询日志中，那么如何设置呢？</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set global <span class="attr">long_query_time</span> = N<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">set <span class="attr">long_query_time</span> = N</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置global的方式对当前<code>session</code>的<code>long_query_time</code>失效。对新连接的客户端有效。所以可以一并执行下述语句</p>
</li>
<li><p>N表示设置的阈值，单位为秒</p>
</li>
</ul>
<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/193484811274457cb7bfc12be950bfe7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ul>
<li>这里的<code>show global variables like &#39;%long_query_time%&#39;;</code>可以查看阈值大小</li>
</ul>
<ol>
<li><strong>如何设置永久生效</strong></li>
</ol>
<p>前面是通过命令行的方式设置，如果MySQL重启，那么配置就会重置。我们可以通过修改MySQL的配置<code>my.cfg</code>或者<code>my.ini</code>永久生效。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="literal">ON</span>  <span class="comment"># 开启慢查询日志开关</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=/var/lib/mysql/alvin-slow.log  <span class="comment"># 慢查询日志的目录和文件名信息</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">3</span>  <span class="comment"># 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line"><span class="attr">log_output</span>=FILE</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="慢查询日志在哪里呢？"><a href="#慢查询日志在哪里呢？" class="headerlink" title="慢查询日志在哪里呢？"></a>慢查询日志在哪里呢？</h2><p>前面讲解了如何开启MySQL的慢查询日志，那么它把日志记录在哪里了呢?</p>
<ol>
<li><strong>查看慢查询日志位置</strong></li>
</ol>
<p>通过<code>show variables like &#39;%slow_query_log_file%&#39;;</code>命令可以查看慢SQL文件位置，如下图所示：</p>
<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/b8cde05cdcac4b069abc4cab2c48e223tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ol>
<li><strong>修改慢查询日志位置</strong></li>
</ol>
<p>也很简单，执行下面的命令即可：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global <span class="attr">slow_query_log_file</span> = <span class="string">&#x27;/usr/local/mysql/data/alvin-slow-slow.log&#x27;</span><span class="comment">;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="怎么查看慢SQL内容？"><a href="#怎么查看慢SQL内容？" class="headerlink" title="怎么查看慢SQL内容？"></a>怎么查看慢SQL内容？</h2><p>现在我们已经知道慢查询日志在哪里了，那么如何查看里面的内容呢？我们这里用一个例子演示下吧。</p>
<ol>
<li><strong>执行一个查询的SQL</strong></li>
</ol>
<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/ca631d0a573c4afbac3c6c853b74a7aatplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ul>
<li>执行花了1秒多，超过了前面设置的阈值1s</li>
</ul>
<ol>
<li><strong>查看慢查询数目</strong></li>
</ol>
<p>执行下面命令查询当前系统中有多少条慢查询记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/554c1a7baf8c497985dfa3b06849bc50tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<ul>
<li>value&#x3D;1, 表明刚刚的日志被记录了。</li>
</ul>
<ol>
<li><strong>查看日志内容</strong></li>
</ol>
<p>通过<code>cat</code>命令查看文件内容，可以看到对应的慢SQL。</p>
<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/a054f8b478b24c2c8112ecf49c5e280btplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<h3 id="慢查询日志分析工具mysqldumpslow"><a href="#慢查询日志分析工具mysqldumpslow" class="headerlink" title="慢查询日志分析工具mysqldumpslow"></a>慢查询日志分析工具mysqldumpslow</h3><p>果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具 <code>mysqldumpslow</code> 。</p>
<p><code>mysqldumpslow</code> 命令的具体参数如下：</p>
<ul>
<li><p>-a: 不将数字抽象成N，字符串抽象成S</p>
</li>
<li><p>-s: 是表示按照何种方式排序：</p>
</li>
<li><ul>
<li>c: 访问次数</li>
<li>l: 锁定时间</li>
<li>r: 返回记录</li>
<li>t: 查询时间</li>
<li>al:平均锁定时间</li>
<li>ar:平均返回记录数</li>
<li>at:平均查询时间 （默认方式）</li>
<li>ac:平均查询次数</li>
</ul>
</li>
<li><p>-t: 即为返回前面多少条的数据；</p>
</li>
<li><p>-g: 后边搭配一个正则匹配模式，大小写不敏感的；</p>
</li>
</ul>
<p>可mysqldumpslow位置mysql的bin目录下，以通过执行 mysqldumpslow –help命令查看使用。</p>
<p><strong>举例：</strong> 我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t <span class="number">5</span> /usr/<span class="keyword">local</span>/mysql/data/alvin-slow-slow.<span class="built_in">log</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="/media/%E6%85%A2%E6%9F%A5%E8%AF%A2/17062293febf4466b0b27e4abcccea76tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.awebp" alt="img"></p>
<p><strong>常见的用法：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /usr/local/mysql/data/alvin-slow-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /usr/local/mysql/data/alvin-slow-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g <span class="string">&quot;left join&quot;</span> /usr/local/mysql/data/alvin-slow-slow.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /usr/local/mysql/data/alvin-slow-slow.log | more</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="怎么删除慢SQL日志？"><a href="#怎么删除慢SQL日志？" class="headerlink" title="怎么删除慢SQL日志？"></a>怎么删除慢SQL日志？</h2><p>现在慢查询日志很多了啊，为了不互相混淆，我要删除一些慢SQL日志，怎么删除呢？</p>
<ol>
<li>手动删除慢查询日志文件即可, 也就是<code>rm</code>命令。</li>
<li>使用命令<code>mysqladmin flush-logs </code>重置慢sql日志内容，完整命令如下 ：</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs slow</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql%E8%B7%B3%E8%B7%83%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql%E8%B7%B3%E8%B7%83%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95/" itemprop="url">MySQL 8.0 索引跳跃扫描</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL-8-0-索引跳跃扫描"><a href="#MySQL-8-0-索引跳跃扫描" class="headerlink" title="MySQL 8.0 索引跳跃扫描"></a>MySQL 8.0 索引跳跃扫描</h1><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdb?from=10680"><strong>MySQL</strong></a> <strong>8.0 实现了Index skip scan，翻译过来就是索引跳跃扫描。</strong>熟悉ORACLE的朋友是不是发现越来越像ORACLE了？再者，熟悉MySQL 5.7 的朋友是不是觉得这个很类似当时优化器的选项MRR？好了，先具体说下什么 ISS，我后面全部用 ISS 简称。</p>
<p><strong>考虑以下的场景：</strong></p>
<p>表t1有一个联合索引idx_u1(rank1,rank2)，但是查询的时候却没有rank1这列，只有rank2。比如，select * from t1 where rank2 &#x3D; 30。</p>
<p>那以前遇到这样的情况，如果没有针对rank2这列单独建立普通索引，这条SQL怎么着都是走的FULL TABLE SCAN。</p>
<p>ISS 就是在这样的场景下产生的。<strong>ISS 可以在查询过滤组合索引不包括最左列的情况下，走索引扫描，而不必要单独建立额外的索引。</strong>因为毕竟额外的索引对写开销很大，能省则省。</p>
<p><strong>还是拿刚才的例子来讲，假设：</strong></p>
<p>表t1的两个字段rank1,rank2。有这样的记录，</p>
<p><img src="/.%5Cmedia%5C1620.jpg" alt="img"></p>
<p>我们给出的SQL是，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> t1 where rank2 &gt;<span class="number">400</span>,</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>那MySQL通过ISS把这条SQL变为，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> t1 where rank1=<span class="number">1</span> and rank2 &gt; 400union allselect * <span class="keyword">from</span> t1 where rank1 = <span class="number">5</span> and rank2 &gt; <span class="number">400</span>;</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>可以看出来，MySQL其实内部自己把左边的列做了一次DISTINCT，完了加进去。</p>
<p><strong>我们拿实际的例子来看下。假设：</strong></p>
<p>还是刚才描述那张表，rank1字段值的distinct值比较少。查询计划的对比，</p>
<p><img src="/.%5Cmedia%5C1621.jpg" alt="img"></p>
<p>关闭 ISS，</p>
<p>很显然，ISS 扫描的行数要比之前的少很多。</p>
<p><strong>ISS其实恰好适合在这种左边字段的唯一值较少的情况下，效率来的高。</strong>比如性别，状态等等。</p>
<p><strong>那假设：rank1字段的distinct值比较多呢？</strong></p>
<p>我们重新造了点数据，这次，rank1的唯一值个数有快上万个。</p>
<p><img src="/.%5Cmedia%5C1623.jpg" alt="img"></p>
<p>我们来再次看一遍这样SQL的执行计划，</p>
<p><img src="/.%5Cmedia%5C1624.jpg" alt="img"></p>
<p><img src="/.%5Cmedia%5C1625.jpg" alt="img"></p>
<p>这次我们发现，无论如何MySQL也不会选择 ISS，而选了FULL INDEX SCAN。</p>
<p>那这样的场景就必须给rank2加一个单独索引了。</p>
<p><img src="/.%5Cmedia%5C1626.jpg" alt="img"></p>
<p><strong>Index Skip Scan限制条件：</strong></p>
<ol>
<li>查询只能涉及一张表，多表关联无法使用该特性</li>
<li>查询SQL不能使用 GROUP BY 或者 DISTINCT子句</li>
<li><strong>查询字段必须是索引中的字段</strong></li>
<li>组合索引形式：([A_1, …, A_k,] B_1, …, B_m, C [, D_1, …, D_n])，A，D 可以为空，但是B ,C 不能为空</li>
</ol>
<p><strong>参数开关：</strong></p>
<p>通过设置参数optimizer_switch中的skip_scan&#x3D;on&#x2F;off，来控制是否打开该优化策略，默认打开。</p>
<p>那来总结下 ISS 就是一句话：<strong>ISS 其实就是MySQL 8.0推出的适合联合索引左边列唯一值较少的情况的一种优化策略。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql-%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql-%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/" itemprop="url">orderby 详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MYSQL：order-by详解"><a href="#MYSQL：order-by详解" class="headerlink" title="MYSQL：order by详解"></a>MYSQL：order by详解</h1><p>原创 捡田螺的小男孩 <a href="javascript:void(0);">捡田螺的小男孩</a> <em>2021-06-15 07:59</em></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>日常开发中，我们经常会使用到order by，亲爱的小伙伴，你是否知道order by 的工作原理呢？order by的优化思路是怎样的呢？使用order by有哪些注意的问题呢？本文将跟大家一起来学习，攻克order by~</p>
<p><img src="/.%5Cmedia%5C1.jpg" alt="图片"></p>
<ul>
<li>微信公众号：<strong>捡田螺的小男孩</strong></li>
</ul>
<h2 id="一个使用order-by-的简单例子"><a href="#一个使用order-by-的简单例子" class="headerlink" title="一个使用order by 的简单例子"></a><strong>一个使用order by 的简单例子</strong></h2><p>假设用一张员工表，表结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `staff` (</span><br><span class="line">`id` BIGINT ( 11 ) AUTO_INCREMENT COMMENT &#x27;主键id&#x27;,</span><br><span class="line">`id_card` VARCHAR ( 20 ) NOT NULL COMMENT &#x27;身份证号码&#x27;,</span><br><span class="line">`name` VARCHAR ( 64 ) NOT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">`age` INT ( 4 ) NOT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">`city` VARCHAR ( 64 ) NOT NULL COMMENT &#x27;城市&#x27;,</span><br><span class="line">PRIMARY KEY ( `id`),</span><br><span class="line">INDEX idx_city ( `city` )</span><br><span class="line">) ENGINE = INNODB COMMENT &#x27;员工表&#x27;;</span><br></pre></td></tr></table></figure>

<p>表数据如下：</p>
<p><img src="/.%5Cmedia%5C2.jpg" alt="图片"></p>
<p>我们现在有这么一个需求：<strong>查询前10个，来自深圳员工的姓名、年龄、城市，并且按照年龄小到大排序</strong>。对应的 SQL 语句就可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br></pre></td></tr></table></figure>

<p>这条语句的逻辑很清楚，但是它的<strong>底层执行流程</strong>是怎样的呢？</p>
<h2 id="order-by-工作原理"><a href="#order-by-工作原理" class="headerlink" title="order by 工作原理"></a><strong>order by 工作原理</strong></h2><p><img src="/.%5Cmedia%5C3.jpg" alt="图片"></p>
<h3 id="explain-执行计划"><a href="#explain-执行计划" class="headerlink" title="explain 执行计划"></a>explain 执行计划</h3><p>我们先用<strong>Explain</strong>关键字查看一下执行计划</p>
<p><img src="/.%5Cmedia%5C4.jpg" alt="图片"></p>
<ul>
<li>执行计划的<strong>key</strong>这个字段，表示使用到索引idx_city</li>
<li>Extra 这个字段的 <strong>Using index condition</strong> 表示索引条件</li>
<li>Extra 这个字段的 <strong>Using filesort</strong>表示用到排序</li>
</ul>
<p>我们可以发现，这条SQL使用到了索引，并且也用到排序。那么它是<strong>怎么排序</strong>的呢？</p>
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>MySQL 会给每个查询线程分配一块小<strong>内存</strong>，用于<strong>排序</strong>的，称为 <strong>sort_buffer</strong>。什么时候把字段放进去排序呢，其实是通过<code>idx_city</code>索引找到对应的数据，才把数据放进去啦。</p>
<p>我们回顾下索引是怎么找到匹配的数据的，现在先把索引树画出来吧，<strong>idx_city</strong>索引树如下：</p>
<p><img src="/.%5Cmedia%5C5.jpg" alt="图片"></p>
<p>idx_city索引树，叶子节点存储的是<strong>主键id</strong>。还有一棵id主键聚族索引树，我们再画出聚族索引树图吧：</p>
<p><img src="/.%5Cmedia%5C6.jpg" alt="图片"></p>
<p><strong>我们的查询语句是怎么找到匹配数据的呢</strong>？先通过<strong>idx_city</strong>索引树，找到对应的主键id，然后再通过拿到的主键id，搜索<strong>id主键索引树</strong>，找到对应的行数据。</p>
<p>加上<strong>order by</strong>之后，整体的执行流程就是：</p>
<ol>
<li>MySQL 为对应的线程初始化<strong>sort_buffer</strong>，放入需要查询的name、age、city字段；</li>
<li>从<strong>索引树idx_city</strong>， 找到第一个满足 city&#x3D;’深圳’条件的主键 id，也就是图中的id&#x3D;9；</li>
<li>到<strong>主键 id 索引树</strong>拿到id&#x3D;9的这一行数据， 取name、age、city三个字段的值，存到sort_buffer；</li>
<li>从<strong>索引树idx_city</strong> 拿到下一个记录的主键 id，即图中的id&#x3D;13；</li>
<li>重复步骤 3、4 直到<strong>city的值不等于深圳</strong>为止；</li>
<li>前面5步已经查找到了所有<strong>city为深圳</strong>的数据，在 sort_buffer中，将所有数据根据age进行排序；</li>
<li>按照排序结果取前10行返回给客户端。</li>
</ol>
<p>执行示意图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65Gx3PbkcEKH5GOKWnpicr6sVJ1HSEiaJo6xqeUV1X5WRxdFRbfz1DEOow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>将查询所需的字段全部读取到sort_buffer中，就是<strong>全字段排序</strong>。这里面，有些小伙伴可能会有个疑问,把查询的所有字段都放到sort_buffer，而sort_buffer是一块内存来的，如果数据量太大，sort_buffer放不下怎么办呢？</p>
<h3 id="磁盘临时文件辅助排序"><a href="#磁盘临时文件辅助排序" class="headerlink" title="磁盘临时文件辅助排序"></a>磁盘临时文件辅助排序</h3><p>实际上，sort_buffer的大小是由一个参数控制的：<strong>sort_buffer_size</strong>。如果要排序的数据小于sort_buffer_size，排序在<strong>sort_buffer</strong> 内存中完成，如果要排序的数据大于sort_buffer_size，则<strong>借助磁盘文件来进行排序</strong></p>
<p>如何确定是否使用了磁盘文件来进行排序呢？可以使用以下这几个命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 打开optimizer_trace，开启统计</span><br><span class="line">set optimizer_trace = &quot;enabled=on&quot;;</span><br><span class="line">## 执行SQL语句</span><br><span class="line">select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br><span class="line">## 查询输出的统计信息</span><br><span class="line">select * from information_schema.optimizer_trace </span><br></pre></td></tr></table></figure>

<p>可以从 <strong>number_of_tmp_files</strong> 中看出，是否使用了临时文件。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65RZ9YcPAmsEnj3YxNBuVbnp2x0ncg9qzBYlpYWsuUd2eAUEkWDJlaxg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>number_of_tmp_files</strong> 表示使用来排序的磁盘临时文件数。如果number_of_tmp_files&gt;0，则表示使用了磁盘文件来进行排序。</p>
<p>使用了磁盘临时文件，整个排序过程又是怎样的呢？</p>
<ol>
<li>从<strong>主键Id索引树</strong>，拿到需要的数据，并放到<strong>sort_buffer内存</strong>块中。当sort_buffer快要满时，就对sort_buffer中的数据排序，排完后，把数据临时放到磁盘一个小文件中。</li>
<li>继续回到主键 id 索引树取数据，继续放到sort_buffer内存中，排序后，也把这些数据写入到磁盘临时小文件中。</li>
<li>继续循环，直到取出所有满足条件的数据。最后把磁盘的临时排好序的小文件，合并成一个有序的大文件。</li>
</ol>
<p><strong>TPS:</strong> 借助磁盘临时小文件排序，实际上使用的是<strong>归并排序</strong>算法。</p>
<p>小伙伴们可能会有个疑问，既然<strong>sort_buffer</strong>放不下，就需要用到临时磁盘文件，这会影响排序效率。那为什么还要把排序不相关的字段（name，city）放到sort_buffer中呢？只放排序相关的age字段，它<strong>不香</strong>吗？可以了解下<strong>rowid 排序</strong>。</p>
<h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><p>rowid 排序就是，只把查询SQL<strong>需要用于排序的字段和主键id</strong>，放到sort_buffer中。那怎么确定走的是全字段排序还是rowid 排序排序呢？</p>
<p>实际上有个参数控制的。这个参数就是<strong>max_length_for_sort_data</strong>，它表示MySQL用于排序行数据的长度的一个参数，如果单行的长度超过这个值，MySQL 就认为单行太大，就换rowid 排序。我们可以通过命令看下这个参数取值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;max_length_for_sort_data&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65bg60JTICaqju2NMsMSP6vw7cKg8nZbkQJDZQo5ia9oI0XiaklaibunLfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>max_length_for_sort_data</strong> 默认值是1024。因为本文示例中name,age,city长度&#x3D;64+4+64 &#x3D;132 &lt; 1024, 所以走的是全字段排序。我们来改下这个参数，改小一点，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 修改排序数据最大单行长度为32</span><br><span class="line">set max_length_for_sort_data = 32;</span><br><span class="line">## 执行查询SQL</span><br><span class="line">select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br></pre></td></tr></table></figure>

<p>使用rowid 排序的话，整个SQL执行流程又是怎样的呢？</p>
<ol>
<li>MySQL 为对应的线程初始化<strong>sort_buffer</strong>，放入需要排序的age字段，以及主键id；</li>
<li>从<strong>索引树idx_city</strong>， 找到第一个满足 city&#x3D;’深圳’条件的主键 id，也就是图中的id&#x3D;9；</li>
<li>到<strong>主键 id 索引树</strong>拿到id&#x3D;9的这一行数据， 取age和主键id的值，存到sort_buffer；</li>
<li>从<strong>索引树idx_city</strong> 拿到下一个记录的主键 id，即图中的id&#x3D;13；</li>
<li>重复步骤 3、4 直到<strong>city的值不等于深圳</strong>为止；</li>
<li>前面5步已经查找到了所有city为深圳的数据，在 <strong>sort_buffer</strong>中，将所有数据根据age进行排序；</li>
<li>遍历排序结果，取前10行，并按照 id 的值<strong>回到原表</strong>中，取出city、name 和 age 三个字段返回给客户端。</li>
</ol>
<p>执行示意图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65KylUcdB0IUG6OGEAK95wnGgkNQO8zr5zibdiawXD08l6REB8qVH3vYCQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>对比一下<strong>全字段排序</strong>的流程，rowid 排序多了一次<strong>回表</strong>。</p>
<blockquote>
<p>★</p>
<p>什么是回表？拿到主键再回到主键索引查询的过程，就叫做回表</p>
<p>”</p>
</blockquote>
<p>我们通过<strong>optimizer_trace</strong>，可以看到是否使用了rowid排序的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 打开optimizer_trace，开启统计</span><br><span class="line">set optimizer_trace = &quot;enabled=on&quot;;</span><br><span class="line">## 执行SQL语句</span><br><span class="line">select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br><span class="line">## 查询输出的统计信息</span><br><span class="line">select * from information_schema.optimizer_trace </span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65fxGiatHhp7EwQc7SxjSEDiczBWibZj9LIU0McPSJkweje3kIniapXHwccg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="全字段排序与rowid排序对比"><a href="#全字段排序与rowid排序对比" class="headerlink" title="全字段排序与rowid排序对比"></a>全字段排序与rowid排序对比</h3><ul>
<li>全字段排序：sort_buffer内存不够的话，就需要用到磁盘临时文件，造成<strong>磁盘访问</strong>。</li>
<li>rowid排序：sort_buffer可以放更多数据，但是需要再回到原表去取数据，比全字段排序多一次<strong>回表</strong>。</li>
</ul>
<p>一般情况下，对于InnoDB存储引擎，会优先使<strong>用全字段</strong>排序。可以发现 <strong>max_length_for_sort_data</strong> 参数设置为1024，这个数比较大的。一般情况下，排序字段不会超过这个值，也就是都会走<strong>全字段</strong>排序。</p>
<h2 id="order-by的一些优化思路"><a href="#order-by的一些优化思路" class="headerlink" title="order by的一些优化思路"></a><strong>order by的一些优化思路</strong></h2><p>我们如何优化order by语句呢？</p>
<ul>
<li>因为数据是无序的，所以就需要排序。如果数据本身是有序的，那就不用排了。而索引数据本身是有序的，我们通过建立<strong>联合索引</strong>，优化order by 语句。</li>
<li>我们还可以通过调整<strong>max_length_for_sort_data</strong>等参数优化；</li>
</ul>
<h3 id="联合索引优化"><a href="#联合索引优化" class="headerlink" title="联合索引优化"></a>联合索引优化</h3><p>再回顾下示例SQL的查询计划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65icYyQdam0TnJ04EglPRtAlaKqCZEnSla0j9GdbuXAwqjwsEQBKwqrCw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>我们给查询条件<code>city</code>和排序字段<code>age</code>，加个联合索引<strong>idx_city_age</strong>。再去查看执行计划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table staff add  index idx_city_age(city,age);</span><br><span class="line">explain select name,age,city from staff where city = &#x27;深圳&#x27; order by age limit 10;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65yz6tfzMfpJrIXUhLasHBDdxRm9qRpMlM7Tgo603CHMmoE6c47eN89g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>可以发现，加上<strong>idx_city_age</strong>联合索引，就不需要<strong>Using filesort</strong>排序了。为什么呢？因为<strong>索引本身是有序的</strong>，我们可以看下<strong>idx_city_age</strong>联合索引示意图，如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65hh5Pu2cIJrytFx1YZicLJcr2NKhSvZV4lJFAocibRBAyLtFlXGq0s9Yw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>整个SQL执行流程变成酱紫：</p>
<ol>
<li>从索引idx_city_age找到满足<strong>city&#x3D;’深圳’</strong> 的主键 id</li>
<li>到<strong>主键 id索引</strong>取出整行，拿到 name、city、age 三个字段的值，作为结果集的一部分直接返回</li>
<li>从索引<strong>idx_city_age</strong>取下一个记录主键id</li>
<li>重复步骤 2、3，直到查到<strong>第10条</strong>记录，或者是<strong>不满足city&#x3D;’深圳’</strong> 条件时循环结束。</li>
</ol>
<p>流程示意图如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65JtaRBnfVFzSyzI1uIWyyGPKW6wxeiaMJqyqkduCQiaP6QPq1jZxCGFoA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>从示意图看来，还是有一次<strong>回表</strong>操作。针对本次示例，有没有更高效的方案呢？有的，可以使用<strong>覆盖索引</strong>：</p>
<blockquote>
<p>★</p>
<p>覆盖索引：在查询的数据列里面，不需要回表去查，直接从索引列就能取到想要的结果。换句话说，你SQL用到的索引列数据，覆盖了查询结果的列，就算上覆盖索引了。</p>
<p>”</p>
</blockquote>
<p>我们给city，name，age 组成一个联合索引，即可用到了覆盖索引，这时候SQL执行时，连回表操作都可以省去啦。</p>
<h3 id="调整参数优化"><a href="#调整参数优化" class="headerlink" title="调整参数优化"></a>调整参数优化</h3><p>我们还可以通过调整参数，去优化order by的执行。比如可以调整sort_buffer_size的值。因为sort_buffer值太小，数据量大的话，会借助磁盘临时文件排序。如果MySQL服务器配置高的话，可以使用稍微调整大点。</p>
<p>我们还可以调整max_length_for_sort_data的值，这个值太小的话，order by会走rowid排序，会回表，降低查询性能。所以max_length_for_sort_data可以适当大一点。</p>
<p>当然，很多时候，这些MySQL参数值，我们直接采用默认值就可以了。</p>
<h2 id="使用order-by-的一些注意点"><a href="#使用order-by-的一些注意点" class="headerlink" title="使用order by 的一些注意点"></a><strong>使用order by 的一些注意点</strong></h2><h3 id="没有where条件，order-by字段需要加索引吗"><a href="#没有where条件，order-by字段需要加索引吗" class="headerlink" title="没有where条件，order by字段需要加索引吗"></a>没有where条件，order by字段需要加索引吗</h3><p>日常开发过程中，我们可能会遇到没有where条件的order by，那么，这时候order by后面的字段是否需要加索引呢。如有这么一个SQL，create_time是否需要加索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A order by create_time;</span><br></pre></td></tr></table></figure>

<p>无条件查询的话，即使create_time上有索引,也不会使用到。因为MySQL优化器认为走普通二级索引，再去回表成本比全表扫描排序更高。所以选择走全表扫描,然后根据全字段排序或者rowid排序来进行。</p>
<p>如果查询SQL修改一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A order by create_time limit m;</span><br></pre></td></tr></table></figure>

<ul>
<li>无条件查询,如果m值较小,是可以走索引的.因为MySQL优化器认为，根据索引有序性去回表查数据,然后得到m条数据,就可以终止循环,那么成本比全表扫描小,则选择走二级索引。</li>
</ul>
<h3 id="分页limit过大时，会导致大量排序怎么办"><a href="#分页limit过大时，会导致大量排序怎么办" class="headerlink" title="分页limit过大时，会导致大量排序怎么办?"></a>分页limit过大时，会导致大量排序怎么办?</h3><p>假设SQL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A order by a limit 100000,10</span><br></pre></td></tr></table></figure>

<ul>
<li>可以记录上一页最后的id，下一页查询时，查询条件带上id，如：where id &gt; 上一页最后id limit 10。</li>
<li>也可以在业务允许的情况下，限制页数。</li>
</ul>
<h3 id="索引存储顺序与order-by不一致，如何优化？"><a href="#索引存储顺序与order-by不一致，如何优化？" class="headerlink" title="索引存储顺序与order by不一致，如何优化？"></a>索引存储顺序与order by不一致，如何优化？</h3><p>假设有联合索引 idx_age_name, 我们需求修改为这样：<strong>查询前10个员工的姓名、年龄，并且按照年龄小到大排序，如果年龄相同，则按姓名降序排</strong>。对应的 SQL 语句就可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name,age from staff  order by age ,name desc limit 10;</span><br></pre></td></tr></table></figure>

<p>我们看下执行计划，发现使用到<strong>Using filesort</strong>。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65VrmibD2cCNg3v3E87G41k1Dzax3ibEGzKzbNV89aPYnxBIgvaw8Hibndw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这是因为，idx_age_name索引树中，age从小到大排序，如果<strong>age相同，再按name从小到大排序</strong>。而order by 中，是按age从小到大排序，如果<strong>age相同，再按name从大到小排序</strong>。也就是说，索引存储顺序与order by不一致。</p>
<p>我们怎么优化呢？如果MySQL是8.0版本，支持<strong>Descending Indexes</strong>，可以这样修改索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `staff` (</span><br><span class="line">  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键id&#x27;,</span><br><span class="line">  `id_card` varchar(20) NOT NULL COMMENT &#x27;身份证号码&#x27;,</span><br><span class="line">  `name` varchar(64) NOT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">  `age` int(4) NOT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">  `city` varchar(64) NOT NULL COMMENT &#x27;城市&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_age_name` (`age`,`name` desc) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COMMENT=&#x27;员工表&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="使用了in条件多个属性时，SQL执行是否有排序过程"><a href="#使用了in条件多个属性时，SQL执行是否有排序过程" class="headerlink" title="使用了in条件多个属性时，SQL执行是否有排序过程"></a>使用了in条件多个属性时，SQL执行是否有排序过程</h3><p>如果我们有<strong>联合索引idx_city_name</strong>，执行这个SQL的话，是不会走排序过程的，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from staff where city in (&#x27;深圳&#x27;) order by age limit 10;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65UpPoVY8QBJeKXCypp6XxTtmxY5DhwPc2eLfrtFdTL3tUqujToZna2A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>但是，如果使用in条件，并且有多个条件时，就会有排序过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from staff where city in (&#x27;深圳&#x27;,&#x27;上海&#x27;) order by age limit 10;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1Pmpwlj1dDtegxsHWfNCSQev65mBZzGBAC5xu0PZoPndgHwrV9ELiaibMg07wiaHMc1C9U3suZkOLGniaKnQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>这是因为:in有两个条件，在满足深圳时，age是排好序的，但是把满足上海的age也加进来，就不能保证满足所有的age都是排好序的。因此需要Using filesort。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F/" itemprop="url">mysql大小写敏感</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql大小写敏感"><a href="#mysql大小写敏感" class="headerlink" title="mysql大小写敏感"></a>mysql大小写敏感</h1><ol>
<li><p>查看mysql是否大小写敏感</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show VARIABLES like &#x27;lower%&#x27;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Variable_name</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>lower_case_file_system</td>
<td>ON</td>
</tr>
<tr>
<td>lower_case_table_names</td>
<td>1</td>
</tr>
</tbody></table>
<p>解析</p>
<ul>
<li><strong>lower_case_file_system</strong> 		OFF表示大小写敏感，ON表示大小写不敏感</li>
<li><strong>lower_case_table_names</strong>      0代表大小写敏感，1表示不敏感</li>
</ul>
</li>
<li><p>根据数据库表的字段属性决定是否敏感</p>
<p>collation 值为 utf8_bin时，采用二进制模式进行存储，大小写敏感</p>
<p>若为utf8_general_ci时，大小写不敏感</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/" itemprop="url">MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL-默认隔离级别是RR，为什么阿里等大厂会改成RC？"><a href="#MySQL-默认隔离级别是RR，为什么阿里等大厂会改成RC？" class="headerlink" title="MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？"></a>MySQL 默认隔离级别是RR，为什么阿里等大厂会改成RC？</h1><p><a target="_blank" rel="noopener" href="https://www.51cto.com/database">数据库</a><a target="_blank" rel="noopener" href="https://www.51cto.com/mysql">MySQL</a></p>
<p>本文介绍了一些 MySQL数据库的 RR 和 RC 两种事务隔离级别。他们主要在加锁机制、主从同步以及一致性读方面存在一些差异。</p>
<p><a target="_blank" rel="noopener" href="https://s4.51cto.com/oss/202112/10/f60aed5572130a97f3bd19e4299af009.jpg"><img src="/media/mysql%E5%A4%A7%E5%8E%82%E4%BD%BF%E7%94%A8RC/f60aed5572130a97f3bd19e4299af009.jpg" alt="img"></a></p>
<p> 我之前写过一篇文章《为什么MySQL选择REPEATABLE READ作为默认隔离级别？》介绍过MySQL 的默认隔离级别是 Repeatable Reads以及背后的原因。</p>
<p>主要是因为MySQL在主从复制的过程是通过bin log 进行数据同步的，而MySQL早期只有statement这种bin log格式，这种格式下，bin log记录的是SQL语句的原文。</p>
<p>当出现事务乱序的时候，就会导致备库在 SQL 回放之后，结果和主库内容不一致。</p>
<p>为了解决这个问题，MySQL默认采用了Repetable Read这种隔离级别，因为在 RR 中，会在更新数据的时候增加记录锁的同时增加间隙锁。可以避免这种情况的发生。</p>
<p>关于MySQL的加锁方式及加锁原则，可以参考我写的另外一篇《求你了，别再说数据库锁的只是索引了！》，这里就不再赘述了。</p>
<p>在我知道MySQL 默认隔离级别是RR后，很长一段时间都以为应该不会有人去修改这个默认配置。</p>
<p>但是直到有一天，我们线上发生了一次死锁的问题，我在排查的过程中，才发现我们的数据库用的隔离级别没有使用默认的 RR，而是修改成了Read Committed 。（关于那次死锁排查过程，可以参考：一次数据库的死锁问题排查过程）</p>
<p>大家可以通过这个命令查看数据库当前的隔离级别： </p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation; </span><br><span class="line">1.</span><br></pre></td></tr></table></figure>

<p>那么，这里不禁就有疑问了，为啥阿里要把这个数据库隔离级别修改成 RC 呢，背后有什么思考吗？</p>
<h2 id="RR-和-RC-的区别"><a href="#RR-和-RC-的区别" class="headerlink" title="RR 和 RC 的区别"></a>RR 和 RC 的区别</h2><p>想要搞清楚这个问题，我们需要先弄清楚 RR 和 RC 的区别，分析下各自的优缺点。</p>
<h3 id="一致性读"><a href="#一致性读" class="headerlink" title="一致性读"></a>一致性读</h3><p>一致性读，又称为快照读。快照即当前行数据之前的历史版本。快照读就是使用快照信息显示基于某个时间点的查询结果，而不考虑与此同时运行的其他事务所执行的更改。</p>
<p>在MySQL 中，只有READ COMMITTED 和 REPEATABLE READ这两种事务隔离级别才会使用一致性读。</p>
<p>在 RC 中，每次读取都会重新生成一个快照，总是读取行的最新版本。</p>
<p>在 RR 中，快照会在事务中第一次SELECT语句执行时生成，只有在本事务中对数据进行更改才会更新快照。</p>
<p>在数据库的 RC 这种隔离级别中，还支持”半一致读” ，一条update语句，如果 where 条件匹配到的记录已经加锁，那么InnoDB会返回记录最近提交的版本，由MySQL上层判断此是否需要真的加锁。</p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>数据库的锁，在不同的事务隔离级别下，是采用了不同的机制的。在 MySQL 中，有三种类型的锁，分别是Record Lock、Gap Lock和 Next-Key Lock。</p>
<p>Record Lock表示记录锁，锁的是索引记录。</p>
<p>Gap Lock是间隙锁，锁的是索引记录之间的间隙。</p>
<p>Next-Key Lock是Record Lock和Gap Lock的组合，同时锁索引记录和间隙。他的范围是左开右闭的。</p>
<p>在 RC 中，只会对索引增加Record Lock，不会添加Gap Lock和Next-Key Lock。</p>
<p>在 RR 中，为了解决幻读的问题，在支持Record Lock的同时，还支持Gap Lock和Next-Key Lock；</p>
<h3 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h3><p>在数据主从同步时，不同格式的 binlog 也对事务隔离级别有要求。</p>
<p>MySQL的binlog主要支持三种格式，分别是statement、row以及mixed，但是，RC 隔离级别只支持row格式的binlog。如果指定了mixed作为 binlog 格式，那么如果使用RC，服务器会自动使用基于row 格式的日志记录。</p>
<p>而 RR 的隔离级别同时支持statement、row以及mixed三种。</p>
<h2 id="为什么互联网公司选择使用-RC"><a href="#为什么互联网公司选择使用-RC" class="headerlink" title="为什么互联网公司选择使用 RC"></a>为什么互联网公司选择使用 RC</h2><h3 id="提升并发"><a href="#提升并发" class="headerlink" title="提升并发"></a>提升并发</h3><p>互联网公司和传统企业最大的区别是什么？</p>
<p><strong>高并发！</strong></p>
<p>没错，互联网业务的并发度比传统企业要高处很多。2020年双十一当天，订单创建峰值达到 58.3 万笔&#x2F;秒。</p>
<p>很多人问，要怎么做才能扛得住这么大的并发量。其实，这背后的优化多到几个小时都讲不完，因为要做的、可以做的事情实在是太多了。</p>
<p>而有一个和我们今天这篇文章有关的优化，那就是通过修改数据库的隔离级别来提升并发度。</p>
<p>为什么 RC 比 RR 的并发度要好呢？</p>
<p>首先，RC 在加锁的过程中，是不需要添加Gap Lock和 Next-Key Lock 的，只对要修改的记录添加行级锁就行了。</p>
<p>这就使得并发度要比 RR 高很多。</p>
<p>另外，因为 RC 还支持”半一致读”，可以大大的减少了更新语句时行锁的冲突；对于不满足更新条件的记录，可以提前释放锁，提升并发度。</p>
<h3 id="减少死锁"><a href="#减少死锁" class="headerlink" title="减少死锁"></a>减少死锁</h3><p>因为RR这种事务隔离级别会增加Gap Lock和 Next-Key Lock，这就使得锁的粒度变大，那么就会使得死锁的概率增大。</p>
<p> 死锁：一个事务锁住了表A，然后又访问表B；另一个事务锁住了表B，然后企图访问表A；这时就会互相等待对方释放锁，就导致了死锁。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了一些 MySQL数据库的 RR 和 RC 两种事务隔离级别。他们主要在加锁机制、主从同步以及一致性读方面存在一些差异。</p>
<p>而很多大厂，为了提升并发度和降低死锁发生的概率，会把数据库的隔离级别从默认的 RR 调整成 RC。</p>
<p>当然，这样做也不是完全没有问题，首先使用 RC 之后，就需要自己解决幻读的问题，这个其实还好，很多时候幻读问题其实是可以忽略的，或者可以用其他手段解决。</p>
<p>还有就是使用 RC 的时候，不能使用statement格式的 binlog，这种影响其实可以忽略不计了，因为MySQL是在5.1.5版本开始支持row的、在5.1.8版本中开始支持mixed，后面这两种可以代替 statement格式。 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/mysql%20%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/mysql%20%E9%94%81/" itemprop="url">mysql 锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h1 id="1-什么是锁"><a href="#1-什么是锁" class="headerlink" title="1. 什么是锁"></a>1. 什么是锁</h1><p>​	锁是数据库系统区别于文件系统的一个关键特性。<strong>锁机制用于管理对共享资源的并发访问。</strong>InnoDB存储引擎会在行级别上对表数据上锁，这固然不错。不过InnoDB存诸引擎也会在数据库内部其他多个地方使用锁，从而允许对多种不同资源提供并发访问。例如，操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保正一致性，必须有锁的介人。<strong>数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。</strong></p>
<h1 id="2-MySQL的锁分类"><a href="#2-MySQL的锁分类" class="headerlink" title="2. MySQL的锁分类"></a>2. MySQL的锁分类</h1><blockquote>
<p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。</p>
</blockquote>
<p>MySQL大致可归纳为以下3种锁：</p>
<ul>
<li><strong>行级锁</strong>：<strong>共享锁（S Lock）、排他锁（X Lock）</strong><ul>
<li>开销大，加锁慢；</li>
<li>会出现死锁；</li>
<li>锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
</ul>
</li>
<li><strong>表级锁</strong>：<strong>意向共享锁（IS Lock）、意向排他锁（IX Lock）</strong><ul>
<li>开销小，加锁快；</li>
<li>不会出现死锁；</li>
<li>锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
</ul>
</li>
<li>页面锁：<ul>
<li>开销和加锁时间界于表锁和行锁之间；</li>
<li>会出现死锁；</li>
<li>锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
</li>
</ul>
<h2 id="表锁-VS-行锁"><a href="#表锁-VS-行锁" class="headerlink" title="表锁 VS 行锁"></a>表锁 VS 行锁</h2><blockquote>
<p>表锁和行锁的概念很容易理解<strong>一个是锁定整张表****一个是锁定一行记录</strong>，那么两者有什么区别呢。</p>
</blockquote>
<p><strong>锁的粒度</strong>：表锁 &gt; 行锁 – 这是因为表锁会锁定更多的记录以及资源因此粒度比较大</p>
<p><strong>加锁效率</strong>：表锁 &gt; 行锁 – 这是因为表锁直接锁定了整个表资源而不需要向行锁一样一行行锁</p>
<p><strong>冲突概论</strong>：表锁 &gt; 行锁 – 锁整张表数据所有写的操作都需要阻塞因此冲突更多</p>
<p><strong>并发性能</strong>：表锁 &lt; 行锁 – 行锁的冲突概率小自然并发高</p>
<h2 id="2-1-行级锁"><a href="#2-1-行级锁" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h2><p><strong>InnoDB存储引擎实现了如下两种标准的行级锁</strong></p>
<table>
<thead>
<tr>
<th>锁之间的兼容性</th>
<th>读锁S</th>
<th>写锁X</th>
</tr>
</thead>
<tbody><tr>
<td>共享锁（读锁、S Lock）</td>
<td><strong>兼容</strong></td>
<td>不兼容</td>
</tr>
<tr>
<td>排他锁（写锁、X Lock）</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>可以发现<strong>X锁与任何的锁都不兼容</strong>，而<strong>S锁仅和S锁兼容</strong>。</li>
<li>需要特别注意的是，S和X锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。</li>
</ul>
</blockquote>
<h3 id="共享锁——S-Lock"><a href="#共享锁——S-Lock" class="headerlink" title="共享锁——S Lock"></a>共享锁——S Lock</h3><blockquote>
<p>允许事务<strong>读一行</strong>数据</p>
</blockquote>
<h3 id="排他锁——X-Lock"><a href="#排他锁——X-Lock" class="headerlink" title="排他锁——X Lock"></a>排他锁——X Lock</h3><blockquote>
<p>允许事务<strong>删除或者更新一行</strong>数据</p>
</blockquote>
<h2 id="2-2-表级锁"><a href="#2-2-表级锁" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h2><p>​	InnoDB存储引擎支持多粒度（(granular〉锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。<strong>为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式</strong>，称之为**意向锁(Intention Lock)**。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度(fine granularity)上进行加锁，如下图所示：<img src="/.%5Cmedia%5C7.jpg" alt="image-20220601105306954"></p>
<ul>
<li>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是<strong>对最细粒度的对象进行上锁</strong></li>
<li>那么首先需要对粗粒度的对象上锁，如果需要对页上的记录r进行上X锁，那么分别需要对<strong>数据库A、表、页</strong>上，最后对<strong>记录r</strong>上。若<code>意向锁IX``X锁</code></li>
</ul>
<p><strong>由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫意外的任何请求</strong></p>
<table>
<thead>
<tr>
<th>锁之间的兼容性</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>IS</td>
<td></td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX</td>
<td></td>
<td>兼容</td>
<td></td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td></td>
<td></td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；</li>
<li>反之，<strong>如果两者两者不兼容，该事务就要等待锁释放。</strong></li>
</ul>
<h3 id="意向共享锁——IS-Lock"><a href="#意向共享锁——IS-Lock" class="headerlink" title="意向共享锁——IS Lock"></a>意向共享锁——IS Lock</h3><blockquote>
<p>事务想要获得<strong>一张表中的某几行</strong>的共享锁</p>
</blockquote>
<h3 id="意向排他锁——IX-Lock"><a href="#意向排他锁——IX-Lock" class="headerlink" title="意向排他锁——IX Lock"></a>意向排他锁——IX Lock</h3><blockquote>
<p>事务想要获得<strong>一张表中某几行</strong>的排他锁</p>
</blockquote>
<h2 id="多版本并发控制——MVCC"><a href="#多版本并发控制——MVCC" class="headerlink" title="多版本并发控制——MVCC"></a>多版本并发控制——MVCC</h2><p>快照数据其实就是当前行数据之前的历史版本，每行记录可能有多个版本。一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为<strong>多版本并发控制(Multi VersionConcurrency Control，MVCC)。</strong></p>
<p>文章可以看：<a href="https://link.juejin.cn/?target=https://blog.csdn.net/huyuyang6688/article/details/123028254">深入理解MySQL的MVCC原理</a></p>
<h2 id="2-3-一致性非锁定读"><a href="#2-3-一致性非锁定读" class="headerlink" title="2.3 一致性非锁定读"></a>2.3 一致性非锁定读</h2><p>​	一致性的非锁定读(consistent nonlocking read）是指InnoDB存储引擎通过的方式来读取当前执行时间数据库中行的数据。<code>行多版本控制（multi versioning）</code></p>
<blockquote>
<p>​	如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据。<strong>这样就不需要等待行上的X锁释放了，极大的提高了数据库的并发性</strong></p>
<p><img src="/.%5Cmedia%5C8.jpg" alt="image-20220601110046377"></p>
<p><strong>说明：快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。</strong></p>
</blockquote>
<p><strong>注意：</strong></p>
<p>​	在事务隔离级别和 (InnoDB存储引擎的默认事务隔离级别)下，InnoDB存储引擎使用非锁定的一致性读。然而，对于快照数据的<strong>定义却不相同</strong>。在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在<strong>REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</strong>来看下面的一个例：<code>READ COMMITTED``REPEATABLE READ</code></p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>一样是我们的tb_user表，可以看这篇<a target="_blank" rel="noopener" href="https://juejin.cn/post/7103493390318190606#heading-13">Mysql高级——索引篇</a>的环境准备获取</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;（首次读-值1）</td>
</tr>
<tr>
<td>3</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>update tb_user set age&#x3D;50 where id &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;（值1）</td>
</tr>
<tr>
<td>6</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;（值2）</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>commit;</td>
</tr>
</tbody></table>
<h4 id="测试——REPEATABLE-READ-可重复读事务隔离级别"><a href="#测试——REPEATABLE-READ-可重复读事务隔离级别" class="headerlink" title="测试——REPEATABLE READ(可重复读事务隔离级别)"></a>测试——REPEATABLE READ(可重复读事务隔离级别)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 由于mysql数据库的更新，在旧版本中tx_isolation是作为transaction_isolation的别名被应用的，新版本已经弃用了，所以输入会显示未知变量.</span><br><span class="line">-- 新版mysql查看事务隔离级别</span><br><span class="line">SELECT @@transaction_isolation</span><br><span class="line"></span><br><span class="line">-- 旧版mysql</span><br><span class="line">SELECT @@tx_isolation;</span><br><span class="line"></span><br><span class="line">-- 设置事务隔离级别</span><br><span class="line">set session transaction isolation level  REPEATABLE READ</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578cc416f7d042c4a1c966c44cd3acc4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601140935100"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/036a2a80b86e446b87464aec05a85247~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134237107"></p>
<blockquote>
<p>– 开启事务B，进行首次读取</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0690b0c4ab1747cf98b953844258308b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134457169"></p>
<blockquote>
<p>– 开启事务A，对该条数据进行修改，<strong>将age修改为50</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf28e92e497a4a559e36eabc1b4a9ebe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134556694"></p>
<blockquote>
<p>– 此时，再回到事务B再次对该行数据进行读取，发现该行数据<strong>还是我们事务B首次读取到的数据</strong>，<strong>并没有因为事务A的更新操作而受到影响</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa39b8c3db8c4952b24ffc7c762e015c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134724021"></p>
<blockquote>
<p>– 此时对<strong>事务A进行提交操作</strong>，再次对该行数据进行读取操作，还是一样的结果（如果此时是READ COMMITTED事务隔离级别，也是一样的结果，因为事务A提交事务后，只生成了一份数据快照，该<strong>快照的age值也是23</strong>，则此时事务B读取到的是最新的一份快照数据，也是一样的）</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1a52445dd464da9b9cc3f28711ab995~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601134843841"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1d07ac80fbb4d39b3ef47535e5ab76d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601135000970"></p>
<blockquote>
<p>– <strong>提交事务B</strong>后再次进行读取操作，可以看到此时读到的age值已经改变了</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/107c6b302cb343da83d9d6c0adc0a8b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601135211255"></p>
<h4 id="测试——READ-COMMITTED"><a href="#测试——READ-COMMITTED" class="headerlink" title="测试——READ COMMITTED"></a>测试——READ COMMITTED</h4><blockquote>
<p>修改事务的隔离级别为——<code>read committed</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 修改事务的隔离级别为——read committed</span><br><span class="line">set session transaction isolation level read committed</span><br><span class="line">select @@transaction_isolation</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b71a19e8ddd4289938bf951f5810426~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601141324664"></p>
<blockquote>
<p>注意：此时对于id&#x3D;1这一行的数据，已经有一个数据快照了，是age&#x3D;23的数据快照</p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;</td>
</tr>
<tr>
<td>3</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>update tb_user set age&#x3D;50 where id &#x3D; 1;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;</td>
</tr>
<tr>
<td>6</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>select * from tb_user where id &#x3D; 1;</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>commit;</td>
</tr>
</tbody></table>
<blockquote>
<p>– 开启事务B，进行首次读取</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f28173bee0e148f69ba986c7979d3656~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601151924209"></p>
<blockquote>
<p>– <strong>开启事务A，进行一次更新操作，修改age为49</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f293169dc2314c2a8f4e4d84f7821f21~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152046666"></p>
<blockquote>
<p>– 在<strong>事务B</strong>中读取一次数据，<strong>依旧是50</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88b3cbb9170b4234acbea07b927b78a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152116193"></p>
<blockquote>
<p>– <strong>在事务A中提交事务后</strong>，此时数据快照多了一份是49的</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2917f27105bf46b1932c1926e972b886~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152316735"></p>
<blockquote>
<p>– 再次去到事务B中读取id&#x3D;1的该行数据，会发现读取的是最新的数据快照，<strong>此时事务B还没进行事务的提交，但是事务A进行事务的提交了</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e416ea0ea5bf4ff89adf608fb225cd14~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601152407088"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><blockquote>
<p><strong>可见</strong></p>
<ul>
<li>在<strong>REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。</strong></li>
<li>在<strong>READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。</strong></li>
</ul>
</blockquote>
<h2 id="2-4-一致性锁定读"><a href="#2-4-一致性锁定读" class="headerlink" title="2.4 一致性锁定读"></a>2.4 一致性锁定读</h2><p>​	在默认配置下，即事务的隔离级别为REPEATABLE READ模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。但是在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。而这要求数据库支持加锁语句，即使是对于SELECT的只读操作。InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读操作：</p>
<ul>
<li><strong>共享锁（Ｓ）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE</strong></li>
<li><strong>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE</strong></li>
</ul>
<blockquote>
<ol>
<li>意向锁是InnoDB自动加的，不需用户干预。</li>
<li>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及的数据集加排他锁Ｘ；</li>
<li>对于普通SELECT语句，InnoDB不会加任何锁；</li>
<li>事务可以通过上面的语句显示给记录集加共享锁或排他锁X。</li>
</ol>
<p>​    用SELECT .. IN SHARE MODE获得共享锁，主要用在需要数据依存关系时确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。</p>
<p>​    但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT … FOR UPDATE方式获取排他锁。</p>
</blockquote>
<h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 事务隔离级别设置为默认的</span><br><span class="line">set session transaction isolation level  REPEATABLE READ</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="for-update测试"><a href="#for-update测试" class="headerlink" title="for update测试"></a>for update测试</h4><table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>select * from tb_user where id&#x3D;1 for update;</td>
</tr>
<tr>
<td>3</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>update tb_user set age&#x3D;40 where id &#x3D; 2;（被阻塞）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>commit；（释放X锁）</td>
</tr>
<tr>
<td>6</td>
<td>update tb_user set age&#x3D;40 where id &#x3D; 2;（成功）</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>commit；</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>– 事务A开启事务后使用一致性的锁定读操作给id&#x3D;1的行上了X锁</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tb_user where id = 1 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/886e1cc7e5134e5980dbbe42b6f7d47e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601165621942"></p>
<blockquote>
<p>– 事务B此时开启事务，对id&#x3D;1的行进行更新操作，<strong>出现被阻塞情况</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">update tb_user set age=40 where id = 1;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcf9cd9b682d42cdb72f3b273fa847e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601170306504"></p>
<blockquote>
<p>– 同样的使用for update操作对表上X锁（锁不兼容），<strong>一样会被阻塞</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_user where id = 1 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed32d91abb1144a39984572814eeede7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601170251538"></p>
<h4 id="lock-in-share-mode测试"><a href="#lock-in-share-mode测试" class="headerlink" title="lock in share mode测试"></a>lock in share mode测试</h4><blockquote>
<p>– <strong>事务A</strong>开启事务后使用一致性的锁定读操作给id&#x3D;1的行上了S锁</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin ;</span><br><span class="line">select * from tb_user where id=1 lock in share mode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02afdfff8c5b4c41b1f59c4f38e48acc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601170949968"></p>
<blockquote>
<p>– <strong>事务B</strong>开启事务后也请求对id&#x3D;1的行数据上S锁，因为S锁之间互相兼容，并<strong>没有出现阻塞</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from tb_user where id=1 lock in share mode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88713e1a1516426d8d4f5b368aba2431~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601171112299"></p>
<blockquote>
<p>– 事务B也请求对id&#x3D;1的行数据上X锁，会<strong>出现阻塞的情况</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_user where id = 1 for update</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd8d49ae2ffa475baece156a2e4cce0f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601171250234"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p><code>SELECT…FOR UPDATE</code>对读取的行记录<strong>加一个X锁</strong>，其他事务不能对已锁定的行加上任何锁。</p>
<p><code>SELECT…LOCK IN SHARE MODE</code>对读取的行记录<strong>加一个S锁</strong>，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。</p>
</blockquote>
<h2 id="非锁定读与锁定读注意点"><a href="#非锁定读与锁定读注意点" class="headerlink" title="非锁定读与锁定读注意点"></a>非锁定读与锁定读注意点</h2><blockquote>
<ol>
<li><strong>对于一致性非锁定读</strong>，即使读取的行已被执行了，也是可以进行读取的，这和之前讨论的情况一样。<code>SELECT…FOR UPDATE</code></li>
<li>此外，，必须在一个事务中，当事务提交了，锁也就释放了。<strong>因此在使用上述两句SELECT锁定语句时，务必加上BEGIN，START TRANSACTION或SETAUTOCOMMIT&#x3D;0。</strong><code>SELBCT…FOR UPDATE``SELECT…LOCK IN SHARE MODE</code></li>
</ol>
</blockquote>
<h2 id="2-5-自增长与锁——AUTO-INC-Locking"><a href="#2-5-自增长与锁——AUTO-INC-Locking" class="headerlink" title="2.5 自增长与锁——AUTO-INC Locking"></a>2.5 自增长与锁——AUTO-INC Locking</h2><p>自增长在数据库中是非常常见的一种属性，也是很多DBA或开发人员首选的主键方式。在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（ auto-increment counter)。当对含有自增长的计数器的表进行插人操作时，这个计数器会被初始化，<strong>插人操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式称做AUTO-INC Locking。**这种锁其实是**采用一种特殊的表锁机制**，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后</strong>立即释放**。</p>
<p><strong>注意点</strong>：</p>
<ul>
<li>在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第个列。</li>
<li>如果不是第一个列，则 MySQL数据库会抛出异常，而MyISAM存储引擎没有这个问题。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/222108cc4c214b7cade6f2a04aaa0369~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601201848034"></p>
<p><strong>存在的问题</strong>：</p>
<p>虽然AUTO-INC Locking 从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。</p>
<ol>
<li>首先，对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待事务的完成)。</li>
<li>其次，对于 INSERT…SELECT 的大数据量的插人会影响插入的性能，因为另一个事务中的插入会被阻塞。</li>
</ol>
<h2 id="2-6-外键和锁"><a href="#2-6-外键和锁" class="headerlink" title="2.6 外键和锁"></a>2.6 外键和锁</h2><p>​    外键主要用于引用完整性的约束检查。<strong>在InnoDB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其加一个索引，因为这样可以避免表锁</strong>（这比Oracle数据库做得好，Oracle数据库不会自动添加索引，用户必须自己手动添加，这也导致了Oracle数据库中可能产生死锁。）</p>
<p><strong>注意点</strong>：</p>
<p>对于外键值的插入或更新，首先需要查询父表中的记录，即SELECT父表。但是<strong>对于父表的SELECT操作</strong>，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，<strong>因此这时使用的是SELECT…LOCK IN SHARE MODE方式</strong>，即<strong>主动对父表加一个S锁。</strong></p>
<p><strong>解释</strong>：</p>
<blockquote>
<p>设想如果这时父表上已经这样加X锁，子表上的操作会被阻塞，如下图：</p>
<p><strong>parent是父表，child是子表</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7278f865339942888c2dafb5bce8f5e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601202657505"></p>
<blockquote>
<p>设想，如果访问父表时，使用的是一致性的非锁定读，这时的Session B会读到父表有id&#x3D;3的记录，可以进行插入操作。但是如果会话A对事务提交了，则父表中就不存在id为3的记录。数据在父、子表就会存在不一致的情况。若这时用户查询，会看到如下结果:<code>INNODB_LOCKS表</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ed84fb74ba64fe7b468a398c92e39f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601203302777"></p>
<p>参数说明：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25b7e071621e42d493e91291ba505ca2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601203339844"></p>
</blockquote>
<h1 id="3-锁的算法"><a href="#3-锁的算法" class="headerlink" title="3. 锁的算法"></a>3. 锁的算法</h1><h2 id="3-1-行锁的三种算法"><a href="#3-1-行锁的三种算法" class="headerlink" title="3.1 行锁的三种算法"></a>3.1 行锁的三种算法</h2><p>InnoDB存储引擎有三种行锁的算法：</p>
<ol>
<li><strong>Record Lock</strong>：单个行记录上的锁</li>
<li><strong>Gap Lock</strong>：间隙锁，锁定一个范围，但不包含记录本身</li>
<li><strong>Next-Key Lock</strong>：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ol>
<p><strong>锁类型锁定的大致范围：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e8683dbabcf4b2ca98439e1459ace52~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<blockquote>
<p>Record Lock：10</p>
<p>Gap Lock：（-∞，10），（10，20），（20，+∞）</p>
<p>Next-Key Lock：（-∞，10]，（10，20]，（20，+∞）</p>
</blockquote>
<h3 id="1️⃣Record-Lock"><a href="#1️⃣Record-Lock" class="headerlink" title="1️⃣Record Lock"></a>1️⃣Record Lock</h3><p><strong>Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</strong></p>
<blockquote>
<p>行锁是加在索引上的，<strong>如果当你的查询语句不走索引的话，那么它就会升级到表锁</strong>，最终造成效率低下，所以在写SQL语句时需要特别注意。</p>
</blockquote>
<h3 id="2️⃣Gap-Lock"><a href="#2️⃣Gap-Lock" class="headerlink" title="2️⃣Gap Lock"></a>2️⃣Gap Lock</h3><p>当我们使用范围条件而不是相等条件去检索，并请求锁时，InnoDB就会给符合条件的记录的索引项加上锁；而对于键值在条件范围内但并不存在（参考上面所说的空闲块）的记录，就叫做间隙，InnoDB在此时也会对间隙加锁</p>
<blockquote>
<ul>
<li>间隙锁只有一个目的就是在RR、SERIALIZABLE隔离级别下为了防止其他事务插入数据。</li>
<li>假如一个索引有2、4、5、9、12 五个值，那该索引可能被间隙锁锁的范围为(-∞ , 2),(2 , 4),(4 , 5),(5 , 9),(9 , 12),(12 , +∞)。</li>
</ul>
</blockquote>
<h3 id="3️⃣Next-Key-Lock"><a href="#3️⃣Next-Key-Lock" class="headerlink" title="3️⃣Next-Key Lock"></a>3️⃣Next-Key Lock</h3><p><strong>Next-Key Lock是结合了Gap Lock和 Record Lock的一种锁定算法，在Next-KeyLock算法下，InnoDB对于行的查询都是采用这种锁定算法。</strong>其目的就是为了解决Phantom Problem（幻象问题）。</p>
<blockquote>
<ul>
<li>对【某一个行记录】和【这条记录与它前一条记录之间的范围&#x2F;间隙】都上锁，这里我们称它为邻键锁。</li>
<li>假如一个索引有2、4、5、9、12 五个值，那该索引可能被邻键锁锁的范围为(-∞ , 2],(2 , 4],(4 , 5],(5 , 9],(9 , 12],(12 , +∞)。在InnoDB中，加锁的基本单位是Next-Key Lock，只不过在某些特殊情况下会退化为 Record Lock 或者 Gap Lock。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>特别说明：</strong></p>
<p>然而，<strong>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。</strong>（可在下面测试代码中看到）</p>
</blockquote>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建a作为主键（即唯一索引），b为辅助索引</span><br><span class="line">CREATE TABLE lock_test ( a INT,b INT,PRIMARY KEY(a),KEY(b));</span><br><span class="line">INSERT INTO lock_test SELECT 1,1;</span><br><span class="line">INSERT INTO lock_test SELECT 3,1;</span><br><span class="line">INSERT INTO lock_test SELECT 5,3;</span><br><span class="line">INSERT INTO lock_test SELECT 7,6;</span><br><span class="line">INSERT INTO lock_test SELECT 10,8;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63179baa8b8540d6994e222042b787e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601223051155"></p>
<h3 id="唯一索引的锁定示例"><a href="#唯一索引的锁定示例" class="headerlink" title="唯一索引的锁定示例"></a>唯一索引的锁定示例</h3><blockquote>
<p><strong>当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from lock_test where a&#x3D;5 for update；</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin；</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><strong>insert into lock_test select 4,5;</strong></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>commit； #成功，不需要等待</td>
</tr>
<tr>
<td>6</td>
<td>commit；</td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d61e6c7c08841b88ec19f011f811d7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601223019835"></p>
<blockquote>
<p>– 事务A开启事务后，先给记录a&#x3D;5上一个X锁，但是因为此时a索引是主键即唯一索引，Next-Key Lock会降级为Record Lock，<strong>仅仅锁住了a&#x3D;5这一行的记录</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A先给记录a=5上一个X锁，但是因为此时a索引是主键即唯一索引，Next-Key Lock会降级为Record Lock</span><br><span class="line">begin;</span><br><span class="line">select * from lock_test where a=5 for update</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>– 事务B插入一条a&#x3D;4，b&#x3D;5的记录，<strong>因为事务A的X锁仅仅加在了a&#x3D;5这一行，所以事务B在执行插入操作时候可以正常获取X锁，并不会被阻塞</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 事务B插入一条a=4，b=5的记录，因为事务A的X锁仅仅加在了a=5这一行，所以事务B在执行插入操作时候可以正常获取X锁</span><br><span class="line">begin;</span><br><span class="line">insert into lock_test select 4,5;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/879b058e828c48e1b5be3e8b77d824df~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601223526341"></p>
<h3 id="辅助索引的锁定示例"><a href="#辅助索引的锁定示例" class="headerlink" title="辅助索引的锁定示例"></a>辅助索引的锁定示例</h3><blockquote>
<p><strong>对于辅助索引，其加上的是Next-Key Lock，锁定的是一个范围值（即Record Lock和Gap Lock的混合锁）</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from lock_test where a&#x3D;5 for update；</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin；</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><strong>select * from lock_test where b&#x3D;3 for update</strong> #阻塞</td>
</tr>
</tbody></table>
<blockquote>
<p>在上个操作的事务B中进行一致性锁定读操作，请求对辅助索引b&#x3D;3加上一个X锁，<strong>会有阻塞的出现</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 在上个操作的事务B中进行一致性锁定读操作，请求对辅助索引b=3加上一个X锁</span><br><span class="line">select * from lock_test where b=3 for update</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edb40207d579499c87f603da34fe0698~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601224329511"></p>
<blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ee5e80e1b384568b324fe7a12e26bf5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601224653635"></p>
<p><strong>说明：</strong></p>
<p>这是因为，针对辅助索引，其上锁上的是Next-Key Lock，这个邻键锁会对辅助索引的上一个键值和下一个键值上一个范围锁，示例中<strong>加X锁的辅助索引是b&#x3D;3，其上一个键值是1，后一个键值是6</strong>，故Next-Key Lock锁定的范围是 <strong>(1, 3],(3,6)<strong>，</strong>这区间内的都被加上了X锁，其他事务无法获取，若获取会被阻塞</strong></p>
<p><strong>所以，此时，因为<code>select \* from lock_test where b=3 for update</code>无法获取a&#x3D;5这一行记录的X锁而导致了事务B发生了阻塞</strong></p>
</blockquote>
<p><strong>此时重新进行操作</strong></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from lock_test where b&#x3D;3 for update</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>select * from lock_test where a&#x3D;5 lock in share mode; #阻塞</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>insert into lock_test select 4,2；#阻塞</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>insert into lock_test select 6,5;  #阻塞</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>insert into lock_test select 8,6;  #正常执行</td>
</tr>
</tbody></table>
<blockquote>
<p>– 事务A开启事务，对b&#x3D;3这条记录进行一致性锁读（X锁），<strong>此时被加锁的范围：(1, 3],(3,6)</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0ea27e922dc497db8b5ce755df39dac~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601232131174"></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 事务A开启事务，对b=3这条记录上锁</span><br><span class="line">begin;</span><br><span class="line">select * from lock_test where b=3 for update;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d0fe386b01f4e55818c4e85f992ace5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601230805400"></p>
<blockquote>
<p>– 开启事务B，对a&#x3D;5的记录上X锁，会出现阻塞</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 开启事务B，对a=5的记录上X锁，会出现阻塞</span><br><span class="line">begin;</span><br><span class="line">select * from lock_test where a=5 lock in share mode;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0201fcd3da1d49439cd723a1bfcbd0ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601231731724"></p>
<blockquote>
<p>– 事务B插入一条a&#x3D;4，b&#x3D;2的数据（X锁）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into lock_test select 4,2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed4bc5359f014b2594a376cf332d51d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601233714262"></p>
<blockquote>
<p>– 事务B插入一条a&#x3D;6，b&#x3D;5的数据（X锁），会出现阻塞</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into lock_test select 6,5;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82bf1d4e1a0243f58ac89ae342ebef24~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601234025094"></p>
<blockquote>
<p>解释：</p>
<p><strong>第一个SQL语句不能执行</strong>，因为在会话A中执行的SQL语句已经对聚集索引中列a &#x3D;5的值加上X锁，因此执行会被阻塞。</p>
<p>第二个SQL语句，主键插入4，没有问题，但是插人的辅助索引值2在锁定的范围(1，3)中，因此执行同样会被阻塞。</p>
<p>第三个SQL语句，插入的主键6没有被锁定，5也不在范围(1，3)之间。但插入的值5在另一个锁定的范围(3，6)中，故同样需要等待。</p>
</blockquote>
<p>而<strong>下面的SQL语句，不会被阻塞</strong>，可以立即执行:</p>
<blockquote>
<p>– 事务B插入一条a&#x3D;8，b&#x3D;6的数据（X锁），不会出现阻塞</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 下面sql</span><br><span class="line">insert into lock_test select 8,6;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edecf561fe394c6f857dcdd83780f30b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220602005321000"></p>
<h2 id="3-2-深入分析MySQL行锁加锁规则"><a href="#3-2-深入分析MySQL行锁加锁规则" class="headerlink" title="3.2 深入分析MySQL行锁加锁规则"></a>3.2 深入分析MySQL行锁加锁规则</h2><p>具体详细的可以看——》<a href="https://link.juejin.cn/?target=https://huyuyang.blog.csdn.net/article/details/123508245?spm=1001.2014.3001.5502">深入分析MySQL行锁加锁规则</a></p>
<h2 id="3-3-幻象问题（幻读）"><a href="#3-3-幻象问题（幻读）" class="headerlink" title="3.3 幻象问题（幻读）"></a>3.3 幻象问题（幻读）</h2><blockquote>
<p>Phantom Problem是指在同一事务下，<strong>连续执行两次同样的SQL语句可能导致不同的结果</strong>，第二次的SQL语句可能会返回之前不存在的行。</p>
</blockquote>
<p>​	**在默认的事务隔离级别下，即REPEATABLE READ 下，InnoDB存储引擎采用Next-Key Locking机制来避免Phantom Problem（幻像问题)**。（这点可能不同于与其他的数据库，如Oracle数据库，因为其可能需要在SERIALIZABLE的事务隔离级别下才能解决Phantom Problem。）</p>
<blockquote>
<p>此外，用户可以通过InnoDB存储引擎的Next-Key Locking机制在应用层面实现唯一性的检查。</p>
</blockquote>
<p>​	如果用户通过索引查询一个值，并对该行加上一个SLock，那么即使查询的值不在，其锁定的也是一个范围，因此若没有返回任何行，那么新插人的值一定是唯一的。也许有读者会有疑问，如果在进行第一步SELECT…LOCK IN SHARE MODE操作时，有多个事务并发操作，那么这种唯一性检查机制是否存在问题。<strong>其实并不会，因为这时会导致死锁，只有一个事务的插人操作会成功，而其余的事务会抛出死锁的错误</strong>，如表6-14所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d9f8301d124eb580f99113a870abca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220602010206860"></p>
<h1 id="4-锁问题"><a href="#4-锁问题" class="headerlink" title="4. 锁问题"></a>4. 锁问题</h1><h2 id="4-1-脏读"><a href="#4-1-脏读" class="headerlink" title="4.1 脏读"></a>4.1 脏读</h2><blockquote>
<p>脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186bf15a970b47b1aace2e5dc5138836~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601234330312"></p>
<p>事务的隔离级别进行了更换，由默认的 ——&gt;。<code>REPEATABLE READ``READ UNCOMMITTED</code></p>
<ul>
<li>可以看到，在会话A中，在事务并没有提交的前提下，会话B中的两次SELECT操作取得了不同的结果。</li>
<li>并且2这条记录是在会话A中并未提交的数据，即产生了脏读，违反了事务的隔离性。</li>
</ul>
<h2 id="4-2-不可重复读"><a href="#4-2-不可重复读" class="headerlink" title="4.2 不可重复读"></a>4.2 不可重复读</h2><blockquote>
<p>不可重复读是指在一个事务内多次读取同一数据集合。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea6a46d9c0144e888221781aa647d07~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601234514701"></p>
<ul>
<li>在事务开始前，会话A和会话B的事务隔离级别都调整为。<code>READ COMMITTED</code></li>
<li>在<strong>会话A</strong>中开始一个事务，第一次读取到的记录是1。</li>
<li>在另一个<strong>会话B</strong>中开始了另一个事务，插入一条为2的记录。</li>
<li>在没有提交之前，对<strong>会话A</strong>中的事务进行再次读取时，读到的记录还是1，没有发生脏读的现象。</li>
<li><strong>但会话B中的事务提交后</strong>，在对<strong>会话A</strong>中的事务进行读取时，这时<strong>读到是1和2两条记录</strong>。</li>
</ul>
<h2 id="4-3-丢失更新"><a href="#4-3-丢失更新" class="headerlink" title="4.3 丢失更新"></a>4.3 丢失更新</h2><blockquote>
<p>丢失更新是另一个锁导致的问题，简单来说其就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。</p>
</blockquote>
<h1 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5. 死锁"></a>5. 死锁</h1><h2 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h2><blockquote>
<p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。</p>
</blockquote>
<h2 id="5-2-死锁的检测"><a href="#5-2-死锁的检测" class="headerlink" title="5.2 死锁的检测"></a>5.2 死锁的检测</h2><p>死锁的检查方法：</p>
<ol>
<li>超时机制——<strong>被动</strong>检测死锁</li>
<li>wait-for group(等待图)——主动检测死锁</li>
</ol>
<h3 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h3><p>​	解决死锁问题最简单的一种方法是超时，<strong>即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。</strong>在 InnoDB存储引擎中，参数innodb_lock_wait_timeout用来设置超时的时间。</p>
<blockquote>
<p><strong>注意：</strong>超时机制虽然简单，但是其仅通过超时后对事务进行回滚的方式来处理，或者说其是根据FIFO的顺序选择回滚对象。但若超时的事务所占权重比较大，如事务操作更新了很多行，占用了较多的undo log，这时采用FIFO的方式，就显得不合适了，因为回滚这个事务的时间相对另一个事务所占用的时间可能会很多。</p>
</blockquote>
<h3 id="wait-for-group-等待图"><a href="#wait-for-group-等待图" class="headerlink" title="wait-for group(等待图)"></a>wait-for group(等待图)</h3><p>wait-for graph要求数据库保存以下两种信息：</p>
<ol>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ol>
<p><strong>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。</strong></p>
<ul>
<li>在 wait-for graph 中，事务为图中的节点。</li>
<li>事务T1指向T2边的定义为：<ul>
<li>事务T1等待事务T2所占用的资源</li>
<li>事务T1最终等待T2所占用的资源，也就是事务之间在等待相同的资源，而事务T1发生在事务T2的后面</li>
</ul>
</li>
</ul>
<p><strong>根据下图</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/500228d94f854938b19a52968eb70808~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601214238586"></p>
<p><strong>解释：</strong></p>
<ul>
<li>在Transaction Wait Lists中可以看到共有4个事务t1、t2、t3、t4，故在wait-forgraph中应有4个节点。</li>
<li>而事务t2对row1占用x锁，事务t1对row2占用s锁。</li>
<li>事务t1需要等待事务t2中row1的资源，因此在wait-for graph中有条边从节点t1指向节点t2。</li>
<li>事务t2需要等待事务t1、t4所占用的row2对象，故而存在节点t2到节点t1、t4的边。</li>
<li>同样，存在节点t3到节点t1、t2、t4的边，因此最终的wait-for graph，如图6-6所示。</li>
</ul>
<p><strong>产生的wait-for group(等待图)</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2df0b5dfec904dc4821fce32e01fbb6f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601214259726"></p>
<blockquote>
<p><strong>通过图6-6可以发现存在回路(t1，t2)，因此存在死锁。</strong></p>
<p>通过上述的介绍，可以发现wait-for graph是一种较为主动的死锁检测机制，<strong>在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说InnoDB存储引擎选择回滚undo量最小的事务。</strong></p>
</blockquote>
<h2 id="5-3-死锁的示例"><a href="#5-3-死锁的示例" class="headerlink" title="5.3 死锁的示例"></a>5.3 死锁的示例</h2><p><strong>表结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t (</span><br><span class="line">	a INT PRIMARY KEY</span><br><span class="line">)ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">INSERT INTO t VALUES (1), (2), (4), (5);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>经典的AB-BA死锁</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b424e5c1442413cba047b6cc631feda~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601214725244"></p>
<blockquote>
<p><strong>解释</strong>：</p>
<p>在上述操作中，会话B中的事务抛出了1213这个错误提示，即表示事务发生了死锁。</p>
<p>死锁的原因是<strong>会话A和B的资源在互相等待</strong>。大多数的死锁InnoDB存储引擎本身可以侦测到，不需要人为进行干预。</p>
<p>但是在上面的例子中，在<strong>会话B</strong>中的事务抛出死锁异常后，<strong>会话A</strong>中马上得到了记录为2的这个资源，这其实是因为会话B中的事务发生了回滚，否则会话A中的事务是不可能得到该资源的。</p>
<p><strong>因为InnoDB存储引擎并不会回滚大部分的错误异常，但是死锁除外。发现死锁后，InnoDB存储引擎会马上回滚一个事务，这点是需要注意的。因此如果在应用程序中捕获了1213这个错误，其实并不需要对其进行回滚。</strong></p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfea99ffcf234e94816198857400dab0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20220601215650438"></p>
<blockquote>
<p>可以看到，<strong>会话A</strong>中已经对持有了X锁，但是<strong>会话A</strong>中插人时会导致死锁发生。<code>记录4``记录3</code></p>
<p>这个问题的产生是由于<strong>会话B</strong>中请求的S锁而发生等待，但之前请求的锁对于主键值记录1、2都已经成功，若在事件点5能插入记录，那么<strong>会话B</strong>在获得持有的S锁后，还需要向后获得的记录，这样就显得有点不合理。<code>记录4``记录4``记录3</code></p>
<p>因此InnoDB存储引擎在这里主动选择了死锁，而回滚的是undo log记录大的事务，这与AB-BA死锁的处理方式又有所不同。</p>
</blockquote>
<blockquote>
<p>资料来源——&gt;《MySQL技术内幕》</p>
<p><a href="https://link.juejin.cn/?target=https://huyuyang.blog.csdn.net/article/details/123508245?spm=1001.2014.3001.5502">深入分析MySQL行锁加锁规则</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/explain%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/explain%E8%AF%A6%E8%A7%A3/" itemprop="url">explain详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:36+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h2><p><strong>1.含义</strong></p>
<p>Explain可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析所查询的语句或者表结构的性能瓶颈。</p>
<p><strong>2.作用</strong></p>
<p>能够获取以下信息：</p>
<ul>
<li>表的读取顺序</li>
<li>哪些索引可以使用</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被物理查询</li>
<li><strong>SQL语句性能分析</strong></li>
</ul>
<p><strong>3.如何使用</strong></p>
<p>Explain+SQL语句</p>
<p>运行结果字段：</p>
<p><img src="/.%5Cmedia%5Cv2-5d33487e208ea34c92370efcdcc55a1e_1440w.png" alt="img">Explain包含字段</p>
<h2 id="二、字段解释："><a href="#二、字段解释：" class="headerlink" title="二、字段解释："></a>二、字段解释：</h2><p><strong>1.id–执行顺序</strong></p>
<p>select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序。</p>
<p>★<strong>注意</strong>：id号每个号码，表示一趟独立的查询。<strong>一个sql 的查询趟数越少越好。</strong></p>
<p><img src="/.%5Cmedia%5Cv2-a061744a09bbf25b10035fc0e954c0e5_1440w.jpg" alt="img"></p>
<p><strong>2.select_type–查询类型</strong></p>
<p>★<strong>注意： DEPENDENT SUBQUERY</strong></p>
<ul>
<li>会严重消耗性能</li>
<li>不会进行子查询，会先进行外部查询,生成结果集,再在内部进行关联查询</li>
<li>子查询的执行效率受制于外层查询的记录数</li>
<li>可以尝试改成join查询</li>
</ul>
<p><img src="/.%5Cmedia%5Cv2-a7035dd17f951bb6dc4b21f7d81d8137_1440w.jpg" alt="img"></p>
<p><strong>3.table–正在访问哪个表</strong></p>
<p><strong>4.partitions–匹配的分区</strong></p>
<p><strong>5.type–访问类型</strong></p>
<p>结果值从最好到最坏依次是：</p>
<p><strong>system &gt; const &gt; eq_ref &gt; ref</strong> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery <strong>&gt; range &gt; index &gt; ALL</strong></p>
<p>★<strong>注意：</strong>一般来说，得保证查询<strong>至少达到range级别，最好能达到ref</strong>。</p>
<p><img src="/.%5Cmedia%5Cv2-279f40b0b73278ea55719f86e5c31219_1440w.jpg" alt="img"></p>
<p><strong>6.possible_keys–可能使用的索引</strong></p>
<p>显示可能应用在这张表中的索引，一个或多个。</p>
<p>查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>
<p><strong>7.key–实际使用的索引</strong></p>
<p>实际使用的索引。如果为NULL，则没有使用索引；查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p>
<p><strong>8.key_len–索引中使用的字节数</strong></p>
<p>可通过该列计算查询中使用的索引的长度。 key_len字段能够帮你检查是否充分的利用上了索引。</p>
<p>如何计算？</p>
<ol>
<li>先看索引上字段的类型+长度比如 int&#x3D;4 ; varchar(20) &#x3D;20 ; char(20) &#x3D;20</li>
<li>如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf-8 要乘3，GBK要乘2</li>
<li>varchar这种动态字符串要加2个字节</li>
<li>允许为空的字段要加1个字节</li>
</ol>
<p>例子：</p>
<p><img src="/.%5Cmedia%5Cv2-399c7a3c702585e52a2557244d8f1c1f_1440w.jpg" alt="img"></p>
<p><strong>9.ref–显示索引中被使用的列</strong></p>
<p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p>
<p><strong>10.rows–必须检查的行数</strong></p>
<p><strong>11.filtered–过滤比例</strong></p>
<p>表示存储引擎返回的数据<strong>在server层过滤后，剩下多少满足查询的记录数量的比例</strong>，注意是百分比，不是具体记录数</p>
<p><strong>12.Extra</strong></p>
<p><img src="/.%5Cmedia%5Cv2-2bb309a8663a404785be5507832ec92f_1440w.jpg" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/04/01/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/01/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%20/" itemprop="url">MySQL的可重复读级别能解决幻读吗</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-04-01T17:21:05+08:00">
                2023-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL的可重复读级别能解决幻读吗"><a href="#MySQL的可重复读级别能解决幻读吗" class="headerlink" title="MySQL的可重复读级别能解决幻读吗"></a>MySQL的可重复读级别能解决幻读吗</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>之前在深入了解数据库理论的时候，了解到事务的不同隔离级别可能存在的问题。为了更好的理解所以在MySQL数据库中测试复现这些问题。关于脏读和不可重复读在相应的隔离级别下都很容易的复现了。但是对于幻读，我发现在可重复读的隔离级别下没有出现，当时想到难道是MySQL对幻读做了什么处理？</p>
<p>测试：</p>
<p>创建一张测试用的表dept：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">12</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept(name) <span class="keyword">values</span>(&quot;后勤部&quot;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>事务 1</th>
<th>事务 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>select * from dept</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>insert into dept(name) values(“研发部”)</td>
</tr>
<tr>
<td>-</td>
<td>commit</td>
</tr>
<tr>
<td>select * from dept</td>
<td></td>
</tr>
<tr>
<td>commit</td>
<td></td>
</tr>
</tbody></table>
<p>根据上面的流程执行，预期来说应该是事务1的第一条select查询出一条数据，第二个select查询出两条数据(包含事务2提交的数据)。</p>
<p>但是在实际测试中发现第二条select实际上也只查询处理一条数据。这是但是根据数据库理论的可重复读的实现(排他锁和共享锁)这是不应该的情况。</p>
<p>在了解实际原因前我们先复习下事务的相关理论。</p>
<h3 id="数据库原理理论"><a href="#数据库原理理论" class="headerlink" title="数据库原理理论"></a>数据库原理理论</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务由事务开始(begin transaction)和事务结束(end transaction)之间执行的全体操作组成。在关系数据库中，一个事务可以是一组SQL语句或整个程序。</p>
<h4 id="为什么要有事务"><a href="#为什么要有事务" class="headerlink" title="为什么要有事务"></a>为什么要有事务</h4><p>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：</p>
<ol>
<li>为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库在异常状态下仍能保持一致性的方法。</li>
<li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，保证彼此的操作互相干扰。</li>
</ol>
<h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p>事务具有4个特性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。</p>
<ul>
<li>原子性（atomicity）： 一个事务应该是一个不可分割的工作单位，事务中包括的操作要么都成功，要么都不成功。</li>
<li>一致性（consistency）： 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
<li>隔离性（isolation）： 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据在事务未提交前对并发的其他事务是隔离的，并发执行的各个事务之间不能互相影响。</li>
<li>持久性（durability）： 一个事务一旦成功提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</li>
</ul>
<p>事务之间的几个特性并不是一组同等的概念：</p>
<p>如果在任何时刻都只有一个事务，那么其天然是具有隔离性的，这时只要保证原子性就能具有一致性。</p>
<p>如果存在并发的情况下，就需要保证原子性和隔离性才能保证一致性。</p>
<h4 id="数据库并发事务中存在的问题"><a href="#数据库并发事务中存在的问题" class="headerlink" title="数据库并发事务中存在的问题"></a>数据库并发事务中存在的问题</h4><p>如果不考虑事务的隔离性，会发生以下几种问题：</p>
<ul>
<li>脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</li>
<li>不可重复读：不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询返回不同的数据值(这里不同是指某一条或多条数据的内容前后不一致，但数据条数相同)，这是由于在查询间隔，该事务需要用到的数据被另一个事务修改并提交了。不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了其他事务提交的数据。需要注意的是在某些情况下不可重复读并不是问题。</li>
<li>幻读：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中。</li>
</ul>
<h4 id="排他锁，共享锁"><a href="#排他锁，共享锁" class="headerlink" title="排他锁，共享锁"></a>排他锁，共享锁</h4><p>排它锁（Exclusive），又称为X 锁，写锁。</p>
<p>共享锁（Shared），又称为S 锁，读锁。</p>
<p>读写锁之间有以下的关系：</p>
<ul>
<li>一个事务对数据对象O加了 S 锁，可以对 O进行读取操作，但是不能进行更新操作。加锁期间其它事务能对O 加 S 锁，但是不能加 X 锁。</li>
<li>一个事务对数据对象 O 加了 X 锁，就可以对 O 进行读取和更新。加锁期间其它事务不能对 O 加任何锁。</li>
</ul>
<p>即读写锁之间的关系可以概括为：多读单写</p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>在事务中存在以下几种隔离级别：</p>
<ul>
<li>读未提交(Read Uncommitted)：解决更新丢失问题。如果一个事务已经开始写操作，那么其他事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据不需要加 S 锁。</li>
<li>读已提交(Read Committed)：解决了脏读问题。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。这可以通过“瞬间共享读锁”和“排他写锁”实现， 即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事务结束。</li>
<li>可重复读取(Repeatable Read)：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事务结束后再释放。</li>
<li>串行化(Serializable)：解决了幻读的问题的。提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。</li>
</ul>
<h3 id="MySQL中的隔离级别的实现"><a href="#MySQL中的隔离级别的实现" class="headerlink" title="MySQL中的隔离级别的实现"></a>MySQL中的隔离级别的实现</h3><p>上面的内容解释了一些数据库理论的概念，但是在MySQL、ORACLE这样的数据库中，为了性能的考虑并不是完全按照上面介绍的理论来实现的。</p>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>多版本并发控制(Multi-Version Concurrency Control, MVCC)是MySQL中基于乐观锁理论实现隔离级别的方式，用于实现读已提交和可重复读取隔离级别的实现。</p>
<h5 id="实现-隔离级别为可重复读"><a href="#实现-隔离级别为可重复读" class="headerlink" title="实现(隔离级别为可重复读)"></a>实现(隔离级别为可重复读)</h5><p>在说到如何实现前先引入两个概念：</p>
<blockquote>
<p>系统版本号：一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</p>
</blockquote>
<blockquote>
<p>事务版本号：事务开始时的系统版本号。</p>
</blockquote>
<p>在MySQL中，会在表中每一条数据后面添加两个字段：</p>
<p>创建版本号：创建一行数据时，将当前系统版本号作为创建版本号赋值</p>
<p>删除版本号：删除一行数据时，将当前系统版本号作为删除版本号赋值</p>
<h5 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h5><p>select时读取数据的规则为：创建版本号&lt;&#x3D;当前事务版本号，删除版本号为空或&gt;当前事务版本号。</p>
<p>创建版本号&lt;&#x3D;当前事务版本号保证取出的数据不会有后启动的事务中创建的数据。这也是为什么在开始的示例中我们不会查出后来添加的数据的原因</p>
<p>删除版本号为空或&gt;当前事务版本号保证了至少在该事务开启之前数据没有被删除，是应该被查出来的数据。</p>
<h5 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h5><p>insert时将当前的系统版本号赋值给创建版本号字段。</p>
<h5 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h5><p>插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行，实际上这里的更新是通过delete和insert实现的。</p>
<h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>删除时将当前的系统版本号赋值给删除版本号字段，标识该行数据在那一个事务中会被删除，即使实际上在位commit时该数据没有被删除。根据select的规则后开启懂数据也不会查询到该数据。</p>
<h4 id="MVCC真的解决了幻读？"><a href="#MVCC真的解决了幻读？" class="headerlink" title="MVCC真的解决了幻读？"></a>MVCC真的解决了幻读？</h4><p>从最开始我们的测试示例和上面的理论支持来看貌似在MySQL中通过MVCC就解决了幻读的问题，那既然这样串行化读貌似就没啥意义了，带着疑问继续测试。</p>
<p>测试前数据：</p>
<p><img src="/media/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/16993816f09c6135tplv-t2oaga2asx-zoom-in-crop-mark4536000-16803406085273.awebp" alt="测试前数据"></p>
<table>
<thead>
<tr>
<th>事务 1</th>
<th>事务 2</th>
</tr>
</thead>
<tbody><tr>
<td>begin</td>
<td>begin</td>
</tr>
<tr>
<td>select * from dept</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>insert into dept(name) values(“研发部”)</td>
</tr>
<tr>
<td>-</td>
<td>commit</td>
</tr>
<tr>
<td>update dept set name&#x3D;”财务部”(工作中如果不想被辞退一定要写where条件)</td>
<td></td>
</tr>
<tr>
<td>commit</td>
<td></td>
</tr>
</tbody></table>
<p>根据上面的结果我们期望的结果是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span>  name</span><br><span class="line">1   财务部</span><br><span class="line">2   研发部</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但是实际上我们的经过是：</p>
<p><img src="/media/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/16993816f0a588dctplv-t2oaga2asx-zoom-in-crop-mark4536000-16803406085274.awebp" alt="测试后数据"></p>
<p>本来我们希望得到的结果只是第一条数据的部门改为财务，但是结果确实两条数据都被修改了。这种结果告诉我们其实在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。</p>
<h4 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h4><p>出现了上面的情况我们需要知道为什么会出现这种情况。在查阅了一些资料后发现在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，我们叫它快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。</p>
<h5 id="select-快照读"><a href="#select-快照读" class="headerlink" title="select 快照读"></a>select 快照读</h5><p>当执行select操作是innodb默认会执行快照读，会记录下这次select后的结果，之后select 的时候就会返回这次快照的数据，即使其他事务提交了不会影响当前select的数据，这就实现了可重复读了。快照的生成当在第一次执行select的时候，也就是说假设当A开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有B添加的那条数据。之后无论再有其他事务commit都没有关系，因为快照已经生成了，后面的select都是根据快照来的。</p>
<h5 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h5><p>对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。也正是因为这样所以才导致上面我们测试的那种情况。</p>
<p>select的当前读需要手动的加锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="有个问题说明下"><a href="#有个问题说明下" class="headerlink" title="有个问题说明下"></a>有个问题说明下</h4><p>在测试过程中最开始我以为使用<code>begin</code>语句就是开始一个事务了，所以在上面第二次测试中因为先开始的事务1，结果在事务1中却查到了事务2新增的数据，当时认为这和前面MVCC中的select的规则不一致了，所以做了如下测试：</p>
<p><img src="/media/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/16993816f0b117ddtplv-t2oaga2asx-zoom-in-crop-mark4536000-16803406085275.awebp" alt="image"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.INNODB_TRX <span class="operator">/</span><span class="operator">/</span>用于查询当前正在执行中的事务</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到如果只是执行<code>begin</code>语句实际上并没有开启一个事务。</p>
<p>下面在<code>begin</code>后添加一条select语句：</p>
<p><img src="/media/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/16993816f090efbbtplv-t2oaga2asx-zoom-in-crop-mark4536000-16803406085276.awebp" alt="事务2"></p>
<p>所以要明白实际上是对数据进行了增删改查等操作后才开启了一个事务。</p>
<h4 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h4><p>很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：</p>
<ul>
<li>使用串行化读的隔离级别</li>
<li>MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)</li>
</ul>
<p>实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2023/03/30/quartz/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shoushi`s Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/03/30/quartz/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" itemprop="url">记一次Quartz重复调度(任务重复执行)的问题排查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2023-03-30T23:06:20+08:00">
                2023-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="记一次Quartz重复调度-任务重复执行-的问题排查"><a href="#记一次Quartz重复调度-任务重复执行-的问题排查" class="headerlink" title="记一次Quartz重复调度(任务重复执行)的问题排查"></a>记一次Quartz重复调度(任务重复执行)的问题排查</h1><p> </p>
<h2 id="1-引子"><a href="#1-引子" class="headerlink" title="1. 引子"></a>1. 引子</h2><p>公司前期改用quartz做任务调度，一日的调度量均在两百万次以上。随着调度量的增加，突然开始出现job重复调度的情况，且没有规律可循。网上也没有说得较为清楚的解决办法，于是我们开始调试Quartz源码，并最终找到了问题所在。 如果没有耐性看完源码解析，可以直接拉到文章最末，有直接简单的解决办法。<br>注：本文中使用的quartz版本为2.3.0，且使用JDBC模式存储Job。</p>
<h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h2><p>首先，因为本文是代码级别的分析文章，因而需要提前了解Quartz的用途和用法，网上还是有很多不错的文章，可以提前自行了解。</p>
<p>其次，在用法之外，我们还需要了解一些Quartz框架的基础概念：</p>
<p>\1) Quartz把触发job，叫做<strong>fire</strong>。<strong>TRIGGER_STATE</strong>是当前trigger的状态，<strong>PREV_FIRE_TIME</strong>是上一次触发时间，<strong>NEXT_FIRE_TIME</strong>是下一次触发时间，<strong>misfire</strong>是指这个job在某一时刻要触发，却因为某些原因没有触发的情况。</p>
<p>\2) Quartz在运行时，会起两类线程（不止两类），一类用于调度job的调度线程（单线程），一类是用于执行job具体业务的工作池。</p>
<p>\3) Quartz自带的表里面，本文主要涉及以下3张表：</p>
<ul>
<li>triggers表。triggers表里记录了，某个trigger的PREV_FIRE_TIME（上次触发时间），NEXT_FIRE_TIME（下一次触发时间），TRIGGER_STATE（当前状态）。虽未尽述，但是本文用到的只有这些。</li>
<li>locks表。Quartz支持分布式，也就是会存在多个线程同时抢占相同资源的情况，而Quartz正是依赖这张表，处理这种状况，至于如何做到，参见3.1。</li>
<li>fired_triggers表，记录正在触发的triggers信息。</li>
</ul>
<p>\4) TRIGGER_STATE，也就是trigger的状态，主要有以下几类：<br><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdx7u.png" alt="图片描述"></p>
<p>图2-1 trigger状态变化图</p>
<p>trigger的初始状态是<strong>WAITING</strong>，处于<strong>WAITING</strong>状态的trigger等待被触发。调度线程会不停地扫triggers表，根据NEXT_FIRE_TIME提前拉取即将触发的trigger，如果这个trigger被该调度线程拉取到，它的状态就会变为<strong>ACQUIRED</strong>。因为是提前拉取trigger，并未到达trigger真正的触发时刻，所以调度线程会等到真正触发的时刻，再将trigger状态由<strong>ACQUIRED</strong>改为<strong>EXECUTING</strong>。如果这个trigger不再执行，就将状态改为<strong>COMPLETE</strong>,否则为<strong>WAITING</strong>，开始新的周期。如果这个周期中的任何环节抛出异常，trigger的状态会变成<strong>ERROR</strong>。如果手动暂停这个trigger，状态会变成<strong>PAUSED</strong>。</p>
<h2 id="3-开始排查"><a href="#3-开始排查" class="headerlink" title="3. 开始排查"></a>3. 开始排查</h2><h3 id="3-1分布式状态下的数据访问"><a href="#3-1分布式状态下的数据访问" class="headerlink" title="3.1分布式状态下的数据访问"></a>3.1分布式状态下的数据访问</h3><p>前文提到，trigger的状态储存在数据库，Quartz支持分布式，所以如果起了多个quartz服务，会有多个调度线程来抢夺触发同一个trigger。mysql在默认情况下执行select 语句，是不上锁的，那么如果同时有1个以上的调度线程抢到同一个trigger，是否会导致这个trigger重复调度呢？我们来看看，Quartz是如何解决这个问题的。</p>
<p>首先，我们先来看下<code>JobStoreSupport</code>类的<code>executeInNonManagedTXLock()</code>方法：</p>
<p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdaoM.png" alt="图片描述"></p>
<p>图3-1 executeInNonManagedTXLock方法的具体实现</p>
<p>这个方法的官方介绍：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line">*Execute <span class="keyword">the</span> <span class="keyword">given</span> callback having acquired <span class="keyword">the</span> <span class="keyword">given</span> lock.</span><br><span class="line"></span><br><span class="line">*Depending <span class="keyword">on</span> <span class="keyword">the</span> JobStore,<span class="keyword">the</span> surrounding <span class="keyword">transaction</span> maybe</span><br><span class="line"></span><br><span class="line">*assumed <span class="keyword">to</span> be already present(managed).</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line"></span><br><span class="line">*@param lockName The <span class="built_in">name</span> <span class="keyword">of</span> <span class="keyword">the</span> lock <span class="keyword">to</span> acquire,<span class="keyword">for</span> example</span><br><span class="line"></span><br><span class="line">*<span class="string">&quot;TRIGGER_ACCESS&quot;</span>.If null, <span class="keyword">then</span> no lock <span class="keyword">is</span> acquired ,<span class="keyword">but</span> <span class="keyword">the</span></span><br><span class="line"></span><br><span class="line">*lockCallback <span class="keyword">is</span> still executed <span class="keyword">in</span> a <span class="keyword">transaction</span>.</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>也就是说，传入的callback方法在执行的过程中是携带了指定的锁，并开启了事务，注释也提到，lockName就是指定的锁的名字，如果lockName是空的，那么callback方法的执行不在锁的保护下，但依然在事务中。</p>
<p>这意味着，我们使用这个方法，不仅可以保证事务，还可以选择保证，callback方法的线程安全。</p>
<p>接下来，我们来看一下<code>executeInNonManagedTXLock（…）</code>中的<code>obtainLock(conn,lockName)</code>方法，即抢锁的过程。这个方法是在<code>Semaphore</code>接口中定义的，<code>Semaphore</code>接口通过锁住线程或者资源，来保护资源不被其他线程修改，由于我们的调度信息是存在数据库的，所以现在查看<code>DBSemaphore.java</code>中<code>obtainLock</code>方法的具体实现：</p>
<p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdaoW.png" alt="图片描述"></p>
<p>图3-2 obtainLock方法具体实现</p>
<p>我们通过调试查看<code>expandedSQL</code>和<code>expandedInsertSQL</code>这两个变量：</p>
<p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdaoZ.png" alt="图片描述"></p>
<p>图3-3 expandedSQL和expandedInsertSQL的具体内容</p>
<p>图3-3可以看出，<code>obtainLock</code>方法通过locks表的一个行锁（lockName确定）来保证callback方法的事务和线程安全。拿到锁后，<code>obtainLock</code>方法将<code>lockName</code>写入<code>threadlocal</code>。当然在<code>releaseLock</code>的时候，会将<code>lockName</code>从<code>threadlocal</code>中删除。</p>
<p>总而言之，<code>executeInNonManagedTXLock()</code>方法，保证了在分布式的情况，同一时刻，只有一个线程可以执行这个方法。</p>
<h3 id="3-2-quartz的调度过程"><a href="#3-2-quartz的调度过程" class="headerlink" title="3.2 quartz的调度过程"></a>3.2 quartz的调度过程</h3><p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdao5.png" alt="图片描述"></p>
<p>图3-4 Quartz的调度时序图</p>
<p><code>QuartzSchedulerThread</code>是调度线程的具体实现，图3-4 是这个线程<code>run()</code>方法的主要内容，图中只提到了正常的情况下，也就是流程中没有出现异常的情况下的处理过程。由图可以看出，调度流程主要分为以下三步：</p>
<h4 id="1）拉取待触发trigger"><a href="#1）拉取待触发trigger" class="headerlink" title="1）拉取待触发trigger:"></a>1）拉取待触发trigger:</h4><p>调度线程会一次性拉取距离现在，一定时间窗口内的，一定数量内的，即将触发的trigger信息。那么，时间窗口和数量信息如何确定呢，我们先来看一下，以下几个参数：</p>
<ul>
<li><code>idleWaitTime</code>： 默认30s，可通过配置属性<code>org.quartz.scheduler.idleWaitTime</code>设置。</li>
<li><code>availThreadCount</code>：获取可用（空闲）的工作线程数量，总会大于1，因为该方法会一直阻塞，直到有工作线程空闲下来。</li>
<li><code>maxBatchSize</code>：一次拉取trigger的最大数量，默认是1，可通过<code>org.quartz.scheduler.batchTriggerAcquisitionMaxCount</code>改写</li>
<li><code>batchTimeWindow</code>：时间窗口调节参数，默认是0，可通过<code>org.quartz.scheduler.batchTriggerAcquisitionFireAheadTimeWindow</code>改写</li>
<li><code>misfireThreshold</code>： 超过这个时间还未触发的trigger,被认为发生了misfire,默认60s，可通过<code>org.quartz.jobStore.misfireThreshold</code>设置。</li>
</ul>
<p>调度线程一次会拉取<strong>NEXT_FIRE_TIME</strong>小于（<code>now + idleWaitTime +batchTimeWindow</code>）,大于（<code>now - misfireThreshold</code>）的，<code>min(availThreadCount,maxBatchSize)</code>个triggers，默认情况下，会拉取未来30s，过去60s之间还未fire的1个trigger。随后将这些triggers的状态由<strong>WAITING</strong>改为<strong>ACQUIRED</strong>，并插入fired_triggers表。</p>
<h4 id="2）触发trigger："><a href="#2）触发trigger：" class="headerlink" title="2）触发trigger："></a>2）触发trigger：</h4><p>首先，我们会检查每个trigger的状态是不是<strong>ACQUIRED</strong>，如果是，则将状态改为<strong>EXECUTING</strong>，然后更新trigger的<strong>NEXT_FIRE_TIME</strong>，如果这个trigger的<strong>NEXT_FIRE_TIME</strong>为空，也就是未来不再触发，就将其状态改为<strong>COMPLETE</strong>。如果trigger不允许并发执行（即Job的实现类标注了<code>@DisallowConcurrentExecution</code>），则将状态变为<strong>BLOCKED</strong>，否则就将状态改为<strong>WAITING</strong>。</p>
<h4 id="3）包装trigger，丢给工作线程池："><a href="#3）包装trigger，丢给工作线程池：" class="headerlink" title="3）包装trigger，丢给工作线程池："></a>3）包装trigger，丢给工作线程池：</h4><p>遍历triggers，如果其中某个trigger在第二步出错，即返回值里面有exception或者为null，就会做一些triggers表，fired_triggers表的内容修正，跳过这个trigger，继续检查下一个。否则，则根据trigger信息实例化<code>JobRunShell</code>（实现了Thread接口），同时依据<code>JOB_CLASS_NAME</code>实例化<code>Job</code>，随后我们将<code>JobRunShell</code>实例丢入工作线。</p>
<p>在<code>JobRunShell</code>的<code>run()</code>方法，Quartz会在执行<code>job.execute()</code>的前后通知之前绑定的监听器，如果<code>job.execute()</code>执行的过程中有异常抛出，则执行结果<code>jobExEx</code>会保存异常信息，反之如果没有异常抛出，则<code>jobExEx</code>为null。然后根据<code>jobExEx</code>的不同，得到不同的执行指令<code>instCode</code>。</p>
<p><code>JobRunShell</code>将trigger信息，job信息和执行指令传给<code>triggeredJobComplete()</code>方法来完成最后的数据表更新操作。例如如果job执行过程有异常抛出，就将这个trigger状态变为<strong>ERROR</strong>，如果是<strong>BLOCKED</strong>状态，就将其变为<strong>WAITING</strong>等等，最后从fired_triggers表中删除这个已经执行完成的trigger。注意，这些是在工作线程池异步完成。</p>
<h3 id="3-3-排查问题"><a href="#3-3-排查问题" class="headerlink" title="3.3 排查问题"></a>3.3 排查问题</h3><p>在前文，我们可以看到，Quartz的调度过程中有3次（可选的）上锁行为，为什么称为可选？因为这三个步骤虽然在<code>executeInNonManagedTXLock</code>方法的保护下，但<code>executeInNonManagedTXLock</code>方法可以通过设置传入参数lockName为空，取消上锁。在翻阅代码时，我们看到第一步拉取待触发的trigger时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;OperableTrigger&gt; <span class="title function_">acquireNextTriggers</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> noLaterThan, <span class="keyword">final</span> <span class="type">int</span> maxCount, <span class="keyword">final</span> <span class="type">long</span> timeWindow)</span> JobPersistenceException &#123;</span><br><span class="line">    String lockName;</span><br><span class="line">    <span class="comment">//判断是否需要上锁</span></span><br><span class="line">    <span class="keyword">if</span> (isAcquireTriggersWithinLock() || maxCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        lockName = LOCK_TRIGGER_ACCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lockName = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executeInNonManagedTXLock(lockName, </span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">TransactionCallback</span>&lt;List&lt;OperableTrigger&gt;&gt;()&#123;</span><br><span class="line">        <span class="keyword">public</span> List&lt;OperableTrigger&gt; <span class="title function_">execute</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> JobPersistenceException &#123;</span><br><span class="line">            <span class="keyword">return</span> acquireNextTrigger(conn, noLaterThan, maxCount, timeWindow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="keyword">new</span> <span class="title class_">TransactionValidator</span>&lt;List&lt;OperableTrigger&gt;&gt;() &#123;</span><br><span class="line">         <span class="comment">//省略</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在加锁之前对lockName做了一次判断，而非像其他加锁方法一样，默认传入的就是<strong>LOCK_TRIGGER_ACCESS</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TriggerFiredResult&gt; <span class="title function_">triggersFired</span><span class="params">(<span class="keyword">final</span> List&lt;OperableTrigger&gt; triggers)</span> <span class="keyword">throws</span> JobPersistenceException &#123;</span><br><span class="line">    <span class="comment">//默认上锁</span></span><br><span class="line">    <span class="keyword">return</span> executeInNonManagedTXLock(LOCK_TRIGGER_ACCESS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TransactionCallback</span>&lt;List&lt;TriggerFiredResult&gt;&gt;() &#123;</span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">        &#125;,<span class="keyword">new</span> <span class="title class_">TransactionValidator</span>&lt;List&lt;TriggerFiredResult&gt;&gt;() &#123;</span><br><span class="line">            <span class="comment">//省略</span></span><br><span class="line">           &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调试发现<code>isAcquireTriggersWithinLock()</code>的值是<code>false</code>，因而导致传入的lockName是null。我在代码中加入日志，可以更清楚的看到这个过程。<br><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdapa.png" alt="图片描述"><br>图3-5 调度日志</p>
<p>由图3-5可以清楚看到，在拉取待触发的trigger时，默认是不上锁。如果这种默认配置有问题，岂不是会频繁发生重复调度的问题？而事实上并没有，原因在于Quartz默认采取乐观锁，也就是允许多个线程同时拉取同一个trigger。我们看一下Quartz在调度流程的第二步fire trigger的时候做了什么，注意此时是上锁状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TriggerFiredBundle <span class="title function_">triggerFired</span><span class="params">(Connection conn, OperableTrigger trigger)</span></span><br><span class="line">    <span class="keyword">throws</span> JobPersistenceException &#123;</span><br><span class="line">    JobDetail job;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Make sure trigger wasn&#x27;t deleted, paused, or completed...</span></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// if trigger was deleted, state will be STATE_DELETED</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> getDelegate().selectTriggerState(conn,trigger.getKey());</span><br><span class="line">         <span class="keyword">if</span> (!state.equals(STATE_ACQUIRED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JobPersistenceException</span>(<span class="string">&quot;Couldn&#x27;t select trigger state: &quot;</span></span><br><span class="line">                    + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调度线程如果发现当前trigger的状态不是<strong>ACQUIRED</strong>，也就是说，这个trigger被其他线程fire了，就会返回null。在3.2，我们提到，在调度流程的第三步，如果发现某个trigger第二步的返回值是null，就会跳过第三步，取消fire。在通常的情况下，乐观锁能保证不发生重复调度，但是难免发生ABA问题，我们看一下这是发生重复调度时的日志：</p>
<p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdapd.png" alt="图片描述"></p>
<p>图3-5 重复调度的日志</p>
<p>在第一步时，也就是quartz在拉取到符合条件的triggers 到将他们的状态由<strong>WAITING</strong>改为<strong>ACQUIRED</strong>之间停顿了有超过9ms的时间，而另一台服务器正是趁着这9ms的空档完成了<strong>WAITING–&gt;ACQUIRED–&gt;EXECUTING–&gt;WAITING</strong>（也就是一个完整的状态变化周期）的全部过程，图示参见图3-6。</p>
<p><img src="/media/%E8%AE%B0%E4%B8%80%E6%AC%A1Quartz%E9%87%8D%E5%A4%8D%E8%B0%83%E5%BA%A6(%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C)%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/bVbdapg.png" alt="图片描述"></p>
<p>图3-6 重复调度原因示意图</p>
<h3 id="3-4-解决办法"><a href="#3-4-解决办法" class="headerlink" title="3.4 解决办法"></a>3.4 解决办法</h3><p>如何去解决这个问题呢？在配置文件加上<code>org.quartz.jobStore.acquireTriggersWithinLock=true</code>，这样，在调度流程的第一步，也就是拉取待即将触发的triggers时，是上锁的状态，即不会同时存在多个线程拉取到相同的trigger的情况，也就避免的重复调度的危险。</p>
<h3 id="3-5-心得"><a href="#3-5-心得" class="headerlink" title="3.5 心得"></a>3.5 心得</h3><p>此次排查过程并非一帆风顺，走过一些坑，也有一些非技术相关的体会：</p>
<p>1）学习是一个需要不断打磨，修正的能力。就我个人而言，为了学Quartz，刚开始去翻一个2.4MB大小的源码是毫无头绪，并且效率低下的，所以立刻转换方向，先了解这个框架的运行模式，在做什么，有哪些模块，是怎么做的，再找主线，翻相关的源码。之后在一次次使用中，碰到问题再翻之前没看的源码，就越来越顺利。</p>
<p>之前也听过其他同事的学习方法，感觉并不完全适合自己，可能每个人状态经验不同，学习方法也稍有不同。在平时的学习中，需要去感受自己的学习效率，参考建议，尝试，感受效果，改进，会越来越清晰自己适合什么。这里很感谢我的师父，用简短的话先帮我捋顺了调度流程，这样我再看源码就不那么吃力了。</p>
<p>2）要质疑“经验”和“理所应当”，惯性思维会蒙住你的双眼。在大规模的代码中很容易被习惯迷惑，一开始，我们看到上锁的那个方法的时候，认为这个上锁技巧很棒，这个方法就是为了解决并发的问题，“应该”都上锁了，上锁了就不会有并发的问题了，怎么可能几次与数据库的交互都上锁，突然某一次不上锁呢？直到看到拉取待触发的trigger方法时，觉得有丝丝不对劲，打下日志，才发现实际上是没上锁的。</p>
<p>3）日志很重要。虽然我们可以调试，但是没有日志，我们是无法发现并证明，程序发生了ABA问题。</p>
<p>4）最重要的是，不要害怕问题，即使是Quartz这样大型的框架，解决问题也不一定需要把2.4MB的源码通通读懂。只要有时间，问题都能解决，只是好的技巧能缩短这个时间，而我们需要在一次次实战中磨练技巧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/index">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/tags.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/shoushi" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liqun.guan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
